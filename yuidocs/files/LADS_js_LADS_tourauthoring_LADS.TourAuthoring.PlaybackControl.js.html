<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>LADS/js/LADS/tourauthoring/LADS.TourAuthoring.PlaybackControl.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../LADS/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/CryptoJS.html">CryptoJS</a></li>
            
                <li><a href="../classes/LADS.Layout.Artmode.html">LADS.Layout.Artmode</a></li>
            
                <li><a href="../classes/LADS.Layout.InternetFailurePage.js.html">LADS.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/LADS.Layout.StartPage.html">LADS.Layout.StartPage</a></li>
            
                <li><a href="../classes/LADS.Layout.VideoPlayer.html">LADS.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: LADS/js/LADS/tourauthoring/LADS.TourAuthoring.PlaybackControl.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿LADS.Util.makeNamespace(&#x27;LADS.TourAuthoring.PlaybackControl&#x27;);

/**
 * Component menu at the bottom of the screen
 * Contains controls for playing and seeking tour
 * @param spec      timeManager attr undoManager
 * @param my        not used
 */
LADS.TourAuthoring.PlaybackControl = function (spec, my) {
    &quot;use strict&quot;;

    var that = {},
        bottombar = $(document.createElement(&#x27;div&#x27;)),
        playing = false,//keeps track of when the player is on
        undoManager = spec.undoManager,
        timeManager = spec.timeManager,
        viewer = spec.viewer,
        timeline = spec.timeline,
        root = spec.root,
        playHeadGroup,//represents the black, long playhead
        lastScale = timeManager.getDuration().scale;//stores the scale of the timeline, which can change because of zoom (?)

    (function _createHTML() {
        bottombar.css({
            &quot;background-color&quot;: &quot;rgb(219,218,199)&quot;,
            &quot;height&quot;: &quot;9.25%&quot;,
            &quot;width&quot;: &quot;96.95%&quot;, &quot;bottom&quot;: &quot;0%&quot;,
            &#x27;margin-left&#x27;: &#x27;1.25%&#x27;,
            &quot;position&quot;: &quot;absolute&quot;,
            &quot;box-shadow&quot;: &quot;0px -16px 14px -14px #888&quot;,
            &#x27;z-index&#x27;: &#x27;102&#x27;,

        });
        bottombar.attr(&#x27;id&#x27;, &#x27;playback-controls&#x27;);

        // Play button
        var playButton = $(document.createElement(&#x27;img&#x27;));
        playButton.css({
            &quot;margin-top&quot;: &quot;1%&quot;,
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;width&#x27;: &#x27;4%&#x27;,
            &#x27;height&#x27;: &#x27;60%&#x27;,
            &quot;position&quot;: &quot;relative&quot;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        });
        playButton.attr(&#x27;src&#x27;, &#x27;images/icons/Play.svg&#x27;);
        playButton.attr(&#x27;id&#x27;, &#x27;playButton&#x27;);
        playButton.click(function () { // Start and stop playback
            togglePlay();
        });
        bottombar.append(playButton);

        //allow space bar to play/pause
        root.on(&#x27;keyup&#x27;, function (evt) { // Start and stop playback
            if (evt.keyCode === 32) {
                togglePlay();
            }
        });

        function togglePlay() {
            if (!timeline.getEditInkOn()) {
                if (!playing) {
                    timeManager.play();
                } else {
                    timeManager.stop();
                }
            }
        }

        // on play and stop update the play button image and internal state
        timeManager.onPlayStart(function () {
            playButton.attr(&#x27;src&#x27;, &#x27;images/icons/Pause.svg&#x27;);
            playing = true;
        });
        timeManager.onStop(function () {
            playButton.attr(&#x27;src&#x27;, &#x27;images/icons/Play.svg&#x27;);
            playing = false;
        });

        // Playhead Location slider
        var playheadLocContainer = $(document.createElement(&#x27;div&#x27;));
        playheadLocContainer.attr(&#x27;id&#x27;, &#x27;playhead-location&#x27;);
        playheadLocContainer.css({
            &#x27;margin-left&#x27;: &#x27;12%&#x27;, &#x27;height&#x27;: &#x27;100%&#x27;, &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;width&#x27;: &#x27;37.5%&#x27;, &#x27;position&#x27;: &#x27;relative&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;color&#x27;: &#x27;black&#x27;,
        });
        bottombar.append(playheadLocContainer);

        // Label for control
        var locationLabel = $(document.createElement(&#x27;label&#x27;));
        locationLabel.attr(&#x27;id&#x27;, &#x27;playLabel&#x27;);
        locationLabel.text(&#x27;Timeline Overview&#x27;);
        locationLabel.css({
            &#x27;font-weight&#x27;: &#x27;600&#x27;, &#x27;font-size&#x27;: LADS.Util.getFontSize(150)
        });
        playheadLocContainer.append(locationLabel);

        //container for slider
        var sliderContainer = $(document.createElement(&#x27;div&#x27;));
        sliderContainer.attr(&#x27;id&#x27;, &#x27;sliderContainer&#x27;);
        sliderContainer.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;width&#x27;: &#x27;40%&#x27;, &#x27;height&#x27;: &#x27;100%&#x27;, &#x27;margin-top&#x27;: &#x27;-2%&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;,
        });
        playheadLocContainer.append(sliderContainer);

        // Container and background for Slider
        var slider = $(document.createElement(&#x27;div&#x27;));
        slider.attr(&#x27;id&#x27;, &#x27;timelineSlider&#x27;);
        slider.css({
            &#x27;position&#x27;: &#x27;relative&#x27;, &#x27;margin-left&#x27;: &#x27;4%&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;width&#x27;: &#x27;100%&#x27;, &#x27;height&#x27;: &#x27;20%&#x27;,
            &#x27;border&#x27;: &#x27;1px&#x27;, &#x27;border-style&#x27;: &#x27;solid&#x27;, &#x27;border-color&#x27;: &#x27;gray&#x27;, &#x27;background-color&#x27;: &#x27;white&#x27;, &#x27;margin-top&#x27;: &#x27;8.5%&#x27;,
        });
        sliderContainer.append(slider);

        // HK25
        // Slider box to display the current view of the timeline

        // Hardcoded the slider box width currently as the css width of tracks region and time ruler returned 0.
        // The hardcoded value is the inital value for the track.
        var sliderBoxWidth = 125;
        var sliderBox = $(document.createElement(&#x27;div&#x27;));
        sliderBox.attr(&#x27;id&#x27;, &#x27;timelineSliderBox&#x27;);
        sliderBox.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;width&#x27;: sliderBoxWidth + &#x27;px&#x27;,
            &#x27;height&#x27;: &#x27;130%&#x27;, &#x27;border&#x27;: &#x27;2px none black&#x27;, &#x27;margin-top&#x27;: &#x27;-2%&#x27;
        });
        sliderBox.draggable({
            // Updates the view using the element id. Be careful changing element ids
            axis: &#x27;x&#x27;,
            drag: function (evt, ui) {
                if (timeline.getEditInkOn()) {
                    return false;
                }

                //var tracks = $(&#x27;.track&#x27;);
                // Be careful changing timelineSliderBox border!
                var sliderMax = slider.width() - sliderBox.width();//-7; Why was this here? jake

                ui.position.left = Math.constrain(ui.position.left, 0, sliderMax);

                var leftt = (ui.position.left / (sliderMax + Math.ceil(sliderBox.width())) * timeline.getTimeRuler().width());
                timeline.registerUpdateSlider(null);
                timeline.getTrackBody().scrollLeft(leftt);
                timeline.cancelAccel();
                timeline.registerUpdateSlider(sliderBoxUpdate);
                //tracks.css(&#x27;left&#x27;, leftt + &#x27;px&#x27;)
                //playhead.css(&#x27;left&#x27;, leftt + &#x27;px&#x27;)
            }
        });
        slider.append(sliderBox);

        sliderBox.mousedown(function (evt) {
            evt.stopPropagation();
        });



        //represents the green part of the timeline for artworks and the gray part for inks -- indicates the length
        var greenBoxInSlider = $(document.createElement(&#x27;div&#x27;));
        greenBoxInSlider.css({
            &#x27;background-color&#x27;: &#x27;DarkGreen&#x27;, &#x27;top&#x27;: &#x27;10%&#x27;, &#x27;height&#x27;: &#x27;80%&#x27;, &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;, &#x27;border&#x27;: &#x27;2px solid black&#x27;,
        });
        sliderBox.append(greenBoxInSlider);

        // Fader
        var fader = createPlayhead();
        fader.css({
            &#x27;height&#x27;: &#x27;155%&#x27;, &#x27;width&#x27;: &#x27;0%&#x27;, &#x27;margin-top&#x27;: &#x27;-4%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;left&#x27;: &#x27;0%&#x27;
        });
        fader.attr(&#x27;id&#x27;, &#x27;fader&#x27;);
        fader.draggable({
            axis: &#x27;x&#x27;,
            drag: function (event, ui) {//changes ui on dragging end keyframes
                if (timeline.getEditInkOn()) {
                    return false;
                }
                var sliderWidth = slider.width();
                ui.position.left = Math.constrain(ui.position.left, 0, sliderWidth);

                var percent = Math.constrain(ui.position.left / (sliderWidth - fader.width()), 0, 1);
                timeManager.seekToPercent(percent);
            },
            stop: function () {
                if (fader.offset().left &gt; slider.offset().left + slider.width()) {
                    fader.css(&#x27;left&#x27;, slider.width() + &#x27;px&#x27;);
                }
            }
        });
        var faderUpdate = function (ev) {
            fader.css(&#x27;left&#x27;, ((fader.offsetParent().width() - fader.width()) * ev.percent) + &#x27;px&#x27;);
        };
        that.faderUpdate = faderUpdate;

        function updateFader() {
            timeManager.onSeek(faderUpdate);
            timeManager.onPlay(faderUpdate);
            timeManager.onSizing(faderUpdate);
            slider.append(fader);
        }
        that.updateFader = updateFader;
        updateFader();

        var sliderLabel = $(document.createElement(&#x27;label&#x27;));
        sliderLabel.attr(&#x27;id&#x27;, &#x27;playhead-position&#x27;);
        sliderLabel.css({
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;left&#x27;: &#x27;45%&#x27;,
            &#x27;color&#x27;: &#x27;black&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;font-weight&#x27;: &#x27;600&#x27;,
            &#x27;font-size&#x27;: LADS.Util.getFontSize(150)
        });
        sliderLabel.text(&#x27;0:00/1:00&#x27;);
        var labelUpdate = function (ev) {
            var current = timeManager.getCurrentTime();
            var end = timeManager.getDuration().end;
            var timeLeft;
            var timeRight;

            if (isNaN(current) || isNaN(end)) {
                timeLeft = &#x27;0:00&#x27;;
                timeRight = &#x27;0:00&#x27;;
            } else {
                timeLeft = timeManager.formatTime(current);
                timeRight = timeManager.formatTime(end);
            }
            sliderLabel.text(timeLeft + &#x27;/&#x27; + timeRight);
        };
        timeManager.onSeek(labelUpdate);
        timeManager.onPlay(labelUpdate);
        timeManager.onSizing(labelUpdate);
        playheadLocContainer.append(sliderLabel);

        var zoomSliderContainter = $(document.createElement(&#x27;div&#x27;));
        zoomSliderContainter.css({
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;, &#x27;height&#x27;: &#x27;60%&#x27;,
            &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;margin-top&#x27;: &#x27;-1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;2%&#x27;
        });
        bottombar.append(zoomSliderContainter);

        // Container for smaller lens.png
        var imgContainer = $(document.createElement(&#x27;div&#x27;));
        imgContainer.attr(&#x27;id&#x27;, &#x27;imgContainer&#x27;);
        imgContainer.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;height&#x27;: &#x27;50%&#x27;
        });
        zoomSliderContainter.append(imgContainer);

        // lens smaller
        var lensSmaller = $(document.createElement(&#x27;img&#x27;));
        lensSmaller.css({
            &quot;margin-top&quot;: &quot;8%&quot;,
            &#x27;margin-left&#x27;: &#x27;0%&#x27;,
            &#x27;height&#x27;: &#x27;85%&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &quot;position&quot;: &quot;relative&quot;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        });
        lensSmaller.attr(&#x27;src&#x27;, &#x27;images/icons/Lens.svg&#x27;);
        lensSmaller.attr(&#x27;id&#x27;, &#x27;lensSmall&#x27;);
        lensSmaller.click(function () {
            var pos = zoomfader.position().left - 0.1 * (zoomslider.width());
            if (pos &gt;= 0) {
                zoomfader.css(&#x27;left&#x27;, pos + &quot;px&quot;);
            } else {
                zoomfader.css(&#x27;left&#x27;, &quot;0px&quot;);
            }
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
        });
        imgContainer.append(lensSmaller);

        // Container and background for zoom bar
        var zoomslider = $(document.createElement(&#x27;div&#x27;));
        zoomslider.attr(&#x27;id&#x27;, &#x27;zoomslider&#x27;);
        zoomslider.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;width&#x27;: &#x27;68%&#x27;, &#x27;height&#x27;: &#x27;35%&#x27;, &#x27;margin-top&#x27;: &#x27;2%&#x27;, &#x27;margin-left&#x27;: &#x27;10%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgb(136, 134, 134)&#x27;, &quot;border-radius&quot;: &quot;25px&quot;
        });
        zoomslider.mousedown(function (evt) {
            if (evt.which != 1)
                return;
            zoomfader.css(&#x27;left&#x27;,
                Math.constrain(evt.pageX - zoomslider.offset().left - zoomfader.width() / 2, 0, zoomslider.width() - zoomfader.width()));
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
            //timeline.onUpdate();
            zoomfader.trigger(evt);
        });
        zoomSliderContainter.append(zoomslider);

        // zoomFader
        var zoomfader = $(document.createElement(&#x27;div&#x27;));
        zoomfader.attr(&#x27;id&#x27;, &#x27;zoomPoint&#x27;);
        var currScale = timeManager.getDuration().scale;
        // Hardcoded the zoomPoint left
        var minScale = 1581 / timeManager.getDuration().end;
        var zoomFaderLeftInit = (currScale - minScale) / (LADS.TourAuthoring.Constants.maxZoom - minScale) * 100;
        zoomfader.css({
            &#x27;background-color&#x27;: &#x27;white&#x27;, &#x27;height&#x27;: &#x27;110%&#x27;, &#x27;width&#x27;: &#x27;10%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;top&#x27;: &#x27;-10%&#x27;, &#x27;left&#x27;: zoomFaderLeftInit + &#x27;%&#x27;,
            &#x27;border&#x27;: &#x27;1px&#x27;, &#x27;border-style&#x27;: &#x27;solid&#x27;, &#x27;border-color&#x27;: &#x27;gray&#x27;, &quot;border-radius&quot;: &quot;50%&quot;
        });
        zoomslider.append(zoomfader);
        zoomfader.mousedown(function (evt) {
            evt.stopPropagation();
        });
        zoomfader.draggable({
            axis: &#x27;x&#x27;, containment: &#x27;parent&#x27;,
            drag: function () {
                var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
                zoom(percent);
                timeline.cancelAccel();
            }
        });
        $(&#x27;#timeRuler&#x27;).livequery(function () {
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
            $(&#x27;#timeRuler&#x27;).expire();
        });

        var zoomfaderUpdate = function (ev) {
            zoomfader.css(&#x27;left&#x27;, ((zoomfader.offsetParent().width() - zoomfader.width()) * ev.percent) + &#x27;px&#x27;);
        };

        var oldpercent = 0;
        var oldPos = 0.0;
        var newPos = 0.0;

        // dan zhang - revamped zoom to lock when playhead is onscreen and zoom more intelligently while playhead is offscreen
        // handles zoom
        function zoom(percent) {
            var trackBody = timeline.getTrackBody(),
                timeRuler = timeline.getTimeRuler(),
                dur = timeManager.getDuration(),
                oldScale = dur.scale,
                totalTime = dur.end,
                minScale = trackBody.width() / totalTime,
                newScale = minScale + percent * (LADS.TourAuthoring.Constants.maxZoom - minScale);

            newScale = Math.min(Math.max(newScale, minScale), LADS.TourAuthoring.Constants.maxZoom);
            lastScale = oldScale;

            // zoom is getting called on onSizing now to appropriately adjust to timeline
            // length changes.  Zoom also causes onSizing events to fire when it adjusts
            // the scale, so if the scale doesn&#x27;t change don&#x27;t call setScale.   
            if (newScale === oldScale) {
                return;
            }

            // data for zooming
            var viewWidth = trackBody.width();
            var midpoint = viewWidth * 0.5;
            var anchorPoint = viewWidth * 0.45; // see below for explanation
            var oldTrackLength = timeManager.timeToPx(totalTime);
            var newTrackLength = newScale * dur.end; // (px per second) x (total seconds)
            var oldPlayheadPosition = timeManager.timeToPx(timeManager.getCurrentTime());
            var oldWindowPosition = trackBody.scrollLeft();
            var newWindowPosition; //for use later
            // if playhead is onscreen, zooming in and out fixes left viewer boundary at the 
            // same pixel distance to the playhead.
            if (oldPlayheadPosition &gt;= oldWindowPosition &amp;&amp; oldPlayheadPosition &lt;= oldWindowPosition + viewWidth) {

                // hack is necessary for the moment because setScale causes the scroll to 
                // crash into the right edge while zooming out by a large magnification 
                // factor. SetScale will need to be restructured or assimilated into zoom 
                // to accomodate an implementation which avoids collisions intelligently.
                if (newScale &lt; oldScale) {
                    //timeRuler.scrollLeft(0);
                    trackBody.scrollLeft(0);
                }

                // checking zoom boundaries and applying scale to timeManager
                if (newScale &gt;= minScale) { // min zoom
                    if (newTrackLength &gt;= trackBody.width()) {
                        timeManager.setScale(newScale);
                    }
                } else if (newScale &lt;= LADS.TourAuthoring.Constants.maxZoom) { // max zoom
                    timeManager.setScale(newScale);
                }
                // end checking zoom boundaries

                // begin zoom functionality
                var leftViewerBoundaryOffset = oldPlayheadPosition - oldWindowPosition;
                var newPlayheadPosition = timeManager.getCurrentPx();
                var windowPosition = newPlayheadPosition - leftViewerBoundaryOffset;
                trackBody.scrollLeft(windowPosition);
                //timeRuler.scrollLeft(windowPosition);

            } else { // if playhead not onscreen, zoom in and zoom out have different anchor points

                // zooming out anchors to center
                if (newScale &lt; oldScale) {
                    // hack is necessary for the moment because setScale causes the scroll to 
                    // crash into the right edge while zooming out by a large magnification 
                    // factor. SetScale will need to be restructured or assimilated into zoom 
                    // to accomodate an implementation which avoids collisions intelligently.
                    //timeRuler.scrollLeft(0);
                    trackBody.scrollLeft(0);

                    // checking zoom boundaries and applying scale to timeManager
                    if (newScale &gt;= minScale) { // min zoom
                        if (newTrackLength &gt;= trackBody.width()) {
                            timeManager.setScale(newScale);
                        }
                    } else if (newScale &lt;= LADS.TourAuthoring.Constants.maxZoom) { // max zoom
                        timeManager.setScale(newScale);
                    }
                    // end scale check

                    // begin zoom functionality
                    // find viewer center&#x27;s relative position to the entire track length
                    var relativeCenterPosition = (oldWindowPosition + midpoint) / oldTrackLength;

                    // calculate viewer center&#x27;s new absolute position for new track length
                    var newAbsoluteCenterPosition = relativeCenterPosition * newTrackLength;

                    // determine window position by subtracting midpoint pixel distance
                    newWindowPosition = newAbsoluteCenterPosition - midpoint;

                    // determine practical view window position based on theoretical position and boundaries
                    if (newWindowPosition + viewWidth &gt; newTrackLength) {
                        // at hard right boundary (track end), expand left side
                        //timeRuler.scrollLeft(newTrackLength - viewWidth);
                        trackBody.scrollLeft(newTrackLength - viewWidth);
                    } else if (newWindowPosition &lt; 0) {
                        // at hard left boundary (track start), expand right side
                        //timeRuler.scrollLeft(0);
                        trackBody.scrollLeft(0);
                    } else {
                        // somewhere in between, expand from center as calculated
                        //timeRuler.scrollLeft(newWindowPosition);
                        trackBody.scrollLeft(newWindowPosition);
                    }
                }

                    // zooming in anchors 45% left because we read left-to-right; this makes zoom more intuitive as while you are traversing the timeline you are more likely to be reading from the left side.
                    // eventual TODO: if display or keyframe is selected, anchor (or soft-anchor?) to display or keyframe since keyframe/display selection (keyframes in particular) does not guarantee playhead is onscreen
                else {
                    // checking zoom boundaries and applying scale to timeManager
                    if (newScale &gt;= minScale) { // min zoom
                        if (newTrackLength &gt;= trackBody.width()) {
                            timeManager.setScale(newScale);
                        }
                    } else if (newScale &lt;= LADS.TourAuthoring.Constants.maxZoom) { // max zoom
                        timeManager.setScale(newScale);
                    }
                    // end scale check

                    // begin zoom functionality
                    // find anchor&#x27;s relative position to the entire track length
                    var relativeAnchorPosition = (oldWindowPosition + anchorPoint) / oldTrackLength;

                    // calculate anchor&#x27;s new absolute position for new track length
                    var newAbsoluteAnchorPosition = relativeAnchorPosition * newTrackLength;

                    // determine window position by subtracting anchor pixel distance
                    newWindowPosition = newAbsoluteAnchorPosition - midpoint;

                    // and then position window based on theoretical position and boundaries
                    if (newWindowPosition + viewWidth &gt; newTrackLength) {
                        // at hard right boundary (track end), expand left side
                        //timeRuler.scrollLeft(newTrackLength - viewWidth);
                        trackBody.scrollLeft(newTrackLength - viewWidth);
                    } else if (newWindowPosition &lt; 0) {
                        // at hard left boundary (track start), expand right side
                        //timeRuler.scrollLeft(0);
                        trackBody.scrollLeft(0);
                    } else {
                        // somewhere in between, expand from center as calculated
                        //timeRuler.scrollLeft(newWindowPosition);
                        trackBody.scrollLeft(newWindowPosition);
                    }
                }
            }
            oldpercent = percent;
        }

        // Container for bigger lens.png
        var imgContainer2 = $(document.createElement(&#x27;div&#x27;));
        imgContainer2.attr(&#x27;id&#x27;, &#x27;imgContainer&#x27;);
        imgContainer2.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;height&#x27;: &#x27;40%&#x27;, &#x27;margin-left&#x27;: &#x27;80%&#x27;
        });
        zoomSliderContainter.append(imgContainer2);

        // lens bigger
        var lensBigger = $(document.createElement(&#x27;img&#x27;)); //larger lens icon, shown on the right
        lensBigger.height = 1;
        lensBigger.width = 1;
        lensBigger.css({
            &quot;margin-top&quot;: &quot;-7%&quot;,
            &#x27;height&#x27;: &#x27;170%&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &quot;position&quot;: &quot;relative&quot;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        });
        lensBigger.attr(&#x27;src&#x27;, &#x27;images/icons/Lens.svg&#x27;);
        lensBigger.attr(&#x27;id&#x27;, &#x27;lensBig&#x27;);
        lensBigger.click(function () {
            var pos = zoomfader.position().left + 0.1 * (zoomslider.width());
            if (pos &lt;= (zoomfader.offsetParent().width() - zoomfader.width())) {
                zoomfader.css(&#x27;left&#x27;, pos + &quot;px&quot;);
            } else {
                zoomfader.css(&#x27;left&#x27;, (zoomfader.offsetParent().width() - zoomfader.width()) + &quot;px&quot;);
            }
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
        });
        imgContainer2.append(lensBigger);

        //container for volume
        var volumeSliderContainer = $(document.createElement(&#x27;div&#x27;));
        volumeSliderContainer.css({
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;width&#x27;: &#x27;5%&#x27;, &#x27;height&#x27;: &#x27;60%&#x27;,
            &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;margin-top&#x27;: &#x27;-1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;2%&#x27;
        });
        bottombar.append(volumeSliderContainer);

        //// Container for the mute image
        //var muteContainer = $(document.createElement(&#x27;div&#x27;));
        //muteContainer.css({
        //    &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;height&#x27;: &#x27;50%&#x27;
        //});
        //volumeSliderContainer.append(muteContainer);

        //// mute volume
        //var muteVolumeImage = $(document.createElement(&#x27;img&#x27;));
        //muteVolumeImage.css({
        //    &quot;margin-top&quot;: &quot;1%&quot;,
        //    &#x27;margin-left&#x27;: &#x27;0%&#x27;,
        //    &#x27;height&#x27;: &#x27;100%&#x27;,
        //    &#x27;width&#x27;: &#x27;auto&#x27;,
        //    &quot;position&quot;: &quot;relative&quot;,
        //    &#x27;display&#x27;: &#x27;inline-block&#x27;
        //});
        //muteVolumeImage.attr(&#x27;src&#x27;, &#x27;images/icons/VolumeDown4.svg&#x27;);
        //muteVolumeImage.attr(&#x27;id&#x27;, &#x27;muteVolume&#x27;);
        //muteVolumeImage.click(function () {
        //    var pos = volumefader.position().left - 0.1 * (volumeslider.width());
        //    if (pos &gt;= 0) {
        //        volumefader.css(&#x27;left&#x27;, pos + &quot;px&quot;);
        //    } else {
        //        volumefader.css(&#x27;left&#x27;, &quot;0px&quot;);
        //    }
        //    var percent = Math.constrain(volumefader.position().left / (volumeslider.width() - volumefader.width()), 0, 1);
        //    viewer.volume(percent);
        //});
        //muteContainer.append(muteVolumeImage);

        //// Container and background for zoom bar
        //var volumeslider = $(document.createElement(&#x27;div&#x27;));
        //volumeslider.css({
        //    &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;width&#x27;: &#x27;70%&#x27;, &#x27;height&#x27;: &#x27;35%&#x27;, &#x27;margin-top&#x27;: &#x27;2%&#x27;, &#x27;margin-left&#x27;: &#x27;12%&#x27;,
        //    &#x27;background-color&#x27;: &#x27;rgb(136, 134, 134)&#x27;, &quot;border-radius&quot;: &quot;25px&quot;
        //});
        //volumeSliderContainer.append(volumeslider);

        //// volumeFader
        //var volumefader = $(document.createElement(&#x27;div&#x27;));
        //volumefader.css({
        //    &#x27;background-color&#x27;: &#x27;white&#x27;, &#x27;height&#x27;: &#x27;113%&#x27;, &#x27;width&#x27;: &#x27;13%&#x27;,
        //    &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;top&#x27;: &#x27;-11%&#x27;, &#x27;right&#x27;: &#x27;0%&#x27;,
        //    &#x27;border&#x27;: &#x27;1px&#x27;, &#x27;border-style&#x27;: &#x27;solid&#x27;, &#x27;border-color&#x27;: &#x27;gray&#x27;, &quot;border-radius&quot;: &quot;50%&quot;
        //});
        //volumefader.draggable({
        //    axis: &#x27;x&#x27;, containment: &#x27;parent&#x27;,
        //    drag: function () {
        //        var percent = Math.constrain(volumefader.position().left / (volumeslider.width()-volumefader.width()), 0, 1);
        //        viewer.volume(percent);
        //        console.log(&quot;volume: &quot; + percent);
        //    }
        //});

        //volumeslider.mousedown(function (evt) {
        //    if (evt.which != 1)
        //        return;
        //    volumefader.css(&#x27;left&#x27;,
        //        Math.constrain(evt.pageX - volumeslider.offset().left - volumefader.width() / 2, 0, volumeslider.width() - volumefader.width()));
        //    var percent = Math.constrain(volumefader.position().left / (volumeslider.width() - volumefader.width()), 0, 1);
        //    viewer.volume(percent);
        //    volumefader.trigger(evt);
        //});

        //volumefader.mousedown(function (evt) {
        //    evt.stopPropagation();
        //});

        //volumeslider.append(volumefader);

        //// Container for volume up
        //var volumeContainer = $(document.createElement(&#x27;div&#x27;));
        //volumeContainer.css({
        //    &#x27;position&#x27;: &#x27;absolute&#x27;, &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;height&#x27;: &#x27;50%&#x27;, &#x27;margin-left&#x27;: &#x27;85%&#x27;
        //});
        //volumeSliderContainer.append(volumeContainer);

        //// volume up
        //var volumeUpImage = $(document.createElement(&#x27;img&#x27;));
        //volumeUpImage.css({
        //    &quot;margin-top&quot;: &quot;1%&quot;,
        //    &#x27;margin-left&#x27;: &#x27;2%&#x27;,
        //    &#x27;height&#x27;: &#x27;100%&#x27;,
        //    &#x27;width&#x27;: &#x27;auto&#x27;,
        //    &quot;position&quot;: &quot;relative&quot;,
        //    &#x27;display&#x27;: &#x27;inline-block&#x27;
        //});
        //volumeUpImage.attr(&#x27;src&#x27;, &#x27;images/icons/VolumeUp.svg&#x27;);
        //volumeUpImage.click(function () {
        //    var pos = volumefader.position().left + 0.1 * (volumeslider.width());
        //    if (pos &lt;= (volumeslider.width() - volumefader.width())) {
        //        volumefader.css(&#x27;left&#x27;, pos + &quot;px&quot;);
        //    } else {
        //        volumefader.css(&#x27;left&#x27;, (volumeslider.width() - volumefader.width()) + &quot;px&quot;);
        //    }
        //    var percent = Math.constrain(volumefader.position().left / (volumeslider.width() - volumefader.width()), 0, 1);
        //    viewer.volume(percent);
        //});
        //volumeContainer.append(volumeUpImage);

        /**
         * HK25: Wrote this function for updating the slider box as it is moved.
         */
        function sliderBoxUpdate(ev) {
            var timeRuler = timeline.getTimeRuler();
            var trackBody = timeline.getTrackBody();
            ev = ev || timeManager.getDuration();
            var oldWidth = sliderBox.width();

            // Check if the function is getting called before the elements are added to the page
            if (timeRuler.position()) {
                var newWidth = trackBody.width() / timeManager.timeToPx(ev.end) * (slider.width());
                // subtract extra 4px to remove influence of border
                var newLeft = (trackBody.scrollLeft()) / timeManager.timeToPx(ev.end) * (slider.width()) - 2;

                if (newWidth &amp;&amp; oldWidth !== Math.ceil(newWidth)) {
                    // If the sliderBox would go past the edge of the slider then adjust
                    // it so that it does not.  This requires moving the timeline to the correct
                    // position to match the sliderBox.
                    if (newWidth + newLeft &gt; slider.position().left + slider.width()) {
                        if (newWidth &gt; slider.width()) {
                            newWidth = slider.width();
                        }
                        newLeft = slider.position().left + slider.width() - newWidth;
                    }
                    sliderBox.css(&#x27;width&#x27;, newWidth + &#x27;px&#x27;);
                }
                sliderBox.css(&#x27;left&#x27;, newLeft + &#x27;px&#x27;);
            }
        }
        // Livequery plugin calls the specified function when the element is
        // actually added to the DOM.  This makes the slider box update for the
        // initial time properly.
        $(&#x27;#editor&#x27;).livequery(function () {
            sliderBoxUpdate(timeManager.getDuration());
            $(&#x27;#editor&#x27;).expire();
        });
        // Update the sliderBox when the timeManager changes size
        timeManager.onSizing(sliderBoxUpdate);
        timeline.registerUpdateSlider(sliderBoxUpdate);

        //undo/redo buttons

        // create div for undo and redo button
        var undoRedoButtonArea = $(document.createElement(&#x27;div&#x27;));
        var undoRedoInkOnly = $(document.createElement(&#x27;div&#x27;));
        that.undoRedoInkOnly = undoRedoInkOnly;

        undoRedoInkOnly.text(&quot;Affects Ink Only&quot;);
        undoRedoInkOnly.css({
            &quot;color&quot;: &quot;green&quot;,
            &quot;margin-top&quot;: &quot;-1%&quot;,
            &quot;position&quot;: &quot;relative&quot;,
            &#x27;display&#x27;: &#x27;none&#x27;,
            &#x27;margin-left&#x27;: &#x27;15%&#x27;, &#x27;font-weight&#x27;: &#x27;600&#x27;, &#x27;font-size&#x27;: LADS.Util.getFontSize(150)
        });

        undoRedoButtonArea.css({
            &quot;margin-top&quot;: &quot;-2%&quot;,
            &quot;position&quot;: &quot;relative&quot;,
            &#x27;z-index&#x27;: 0,
            &#x27;height&#x27;: &#x27;60%&#x27;,
            &#x27;width&#x27;: &#x27;15%&#x27;,
            &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        });
        undoRedoButtonArea.attr(&#x27;id&#x27;, &#x27;undoRedoButtonArea&#x27;);

        var undoRedoButtonCSS = { &#x27;height&#x27;: &#x27;70%&#x27;, &#x27;width&#x27;: &#x27;auto&#x27;, &#x27;margin-left&#x27;: &#x27;15%&#x27;, &#x27;opacity&#x27;: &#x27;0.4&#x27; };

        // undo and redo buttons
        var undoButton = $(document.createElement(&#x27;img&#x27;));
        $(undoButton).addClass(&#x27;undoButton&#x27;);
        undoButton.attr(&#x27;src&#x27;, &#x27;images/icons/Undo.svg&#x27;);
        undoButton.css(undoRedoButtonCSS);
        undoButton.click(function () {
            undoManager.undo();
        });
        undoRedoButtonArea.append(undoButton);
        that.undoButton = undoButton;

        var redoButton = $(document.createElement(&#x27;img&#x27;));
        $(redoButton).addClass(&#x27;redoButton&#x27;);
        redoButton.attr(&#x27;src&#x27;, &#x27;images/icons/Redo.svg&#x27;);
        redoButton.css(undoRedoButtonCSS);
        redoButton.click(function () {
            undoManager.redo();
        });
        undoRedoButtonArea.append(redoButton);
        that.redoButton = redoButton;
        undoRedoButtonArea.append(undoRedoInkOnly);
        bottombar.append(undoRedoButtonArea);

        function createPlayhead() {
            var playHeadDiv = $(document.createElement(&#x27;div&#x27;));
            var playheadSVG = d3.select(playHeadDiv[0])
                                        .append(&quot;svg&quot;)
                                        .style(&#x27;position&#x27;, &#x27;absolute&#x27;)
                                        .style(&#x27;left&#x27;, &#x27;0px&#x27;).style(&#x27;top&#x27;, &#x27;-110%&#x27;)
                                        .attr(&quot;width&quot;, &#x27;0%&#x27;)
                                        .attr(&quot;height&quot;, &#x27;100%&#x27;); // div to be transformed into an svg group

            playHeadGroup = playheadSVG.append(&quot;g&quot;);

            var playHeadTop = playHeadGroup.append(&quot;circle&quot;)
                                       .attr(&#x27;cx&#x27;, &#x27;0&#x27;)
                                       .attr(&#x27;cy&#x27;, &#x27;80%&#x27;)
                                       .attr(&#x27;r&#x27;, &#x27;40%&#x27;)
                                       .attr(&#x27;fill&#x27;, &#x27;black&#x27;)
                                       .attr(&#x27;stroke&#x27;, &#x27;black&#x27;)
                                       .attr(&#x27;stroke-width&#x27;, &#x27;10%&#x27;)
                                       .attr(&#x27;fill-opacity&#x27;, &#x27;0&#x27;);

            var playHead = playHeadGroup.append(&quot;line&quot;)
                                             .attr(&#x27;x1&#x27;, &#x27;0&#x27;)
                                             .attr(&#x27;y1&#x27;, &#x27;110%&#x27;) // 11.4%
                                             .attr(&#x27;x2&#x27;, &#x27;0&#x27;)
                                             .attr(&#x27;y2&#x27;, &#x27;210%&#x27;)
                                             .attr(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                                             .attr(&#x27;stroke&#x27;, &#x27;black&#x27;)
                                             .attr(&#x27;stroke-width&#x27;, &#x27;10%&#x27;);
            return playHeadDiv;
        }
    })();

    function addToDOM(container) {
        container.appendChild(bottombar[0]);
    }
    that.addToDOM = addToDOM;

    return that;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
