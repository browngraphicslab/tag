<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>TAG/js/TAG/tourauthoring/TAG.TourAuthoring.InkController.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../TAG/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/TAG.AnnotatedImage.html">TAG.AnnotatedImage</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkViewer.html">TAG.Layout.ArtworkViewer</a></li>
            
                <li><a href="../classes/TAG.Layout.CollectionsPage.html">TAG.Layout.CollectionsPage</a></li>
            
                <li><a href="../classes/TAG.Layout.InternetFailurePage.js.html">TAG.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/TAG.Layout.StartPage.html">TAG.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG.Layout.VideoPlayer.html">TAG.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG.Util.Artwork.html">TAG.Util.Artwork</a></li>
            
                <li><a href="../classes/TAG.Util.IdleTimer.html">TAG.Util.IdleTimer</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: TAG/js/TAG/tourauthoring/TAG.TourAuthoring.InkController.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿TAG.Util.makeNamespace(&quot;TAG.TourAuthoring.InkController&quot;);

TAG.TourAuthoring.InkController = (function (canvasid) {
    &quot;use strict&quot;;

    var that = {};

    //init();
    //function init(canvId) { //similar to old &#x27;load&#x27; function
    //    //sets up the inkAuthoring object, which allows drawing
    //    iA = new inkController(canvId);
    //    paper = iA.paper;
    //    datastring = &quot;&quot;;
    //    currpaths = &quot;&quot;;
    //    click = false;
    //    set_mode(1);
    //};

    function inkController(canvId) {
        /**
         * definition of the inkAuthoring class members:
         *   paper -- a Raphael object (a canvas to draw on) fit to the div specified by canvasId
         *   loadInk -- loads an Ink to the canvas using the string format specified in update_datastring() below
         *   getters and setters for different Ink attributes
         *   update functions which take in DOM element IDs and use the settings stored in their values
         */
        // member variables //
        this.canvid = canvId;
        this.cw = $(&quot;#&quot; + this.canvid).css(&quot;width&quot;);
        this.ch = $(&quot;#&quot; + this.canvid).css(&quot;height&quot;);
        this.paper = Raphael(this.canvid, &quot;100%&quot;, &quot;100%&quot;);
        
        this.penColor = &quot;#ffffff&quot;;
        this.penOpacity = 1.0;
        this.penWidth = 4;
        this.eraserWidth = 5;
        this.shapeStrokeColor = &quot;#000000&quot;;
        this.shapeStrokeOpacity = 1.0;
        this.shapeStrokeWidth = 0;
        this.shapeFillColor = &quot;#000000&quot;;
        this.shapeFillOpacity = 0.5;
        this.marqueeFillColor = &quot;#000000&quot;;
        this.marqueeFillOpacity = 0.8;

        this.marquees = [];
        this.marquees_on = 1;
        this.click = false;
        this.ml = [];
        this.xy = [];
        this.paths = [];
        this.pathObjects = [];
        this.currpaths = &quot;&quot;; //this will be the string representing all of our paths; to get the paths individually, split at &#x27;M&#x27;
        this.pathattrs = &quot;&quot;;
        this.datastring = &quot;&quot;;
        this.mode = 1;

        // methods //
        var self = this;
        this.add_attributes = function (elt, fillColor, fillOpacity, strokeColor, strokeOpacity, strokeWidth) {
            //adds drag event handlers, color attributes, etc to rectangles and ellipses
            //console.log(&quot;add_attributes called&quot;);
            var gl;
            var resize = 0; //if 1, we are in zoom mode rather than pan mode
            var noglow = 0; //if 1, glowing is disabled
            var origmousex;
            var origmousey;

            if (fillColor == undefined)
                fillColor = self.shapeFillColor; //FIX THESE!!!!
            if (fillOpacity == undefined)
                fillOpacity = self.shapeFillOpacity;
            if (strokeColor == undefined)
                strokeColor = self.shapeStrokeColor;
            if (strokeOpacity == undefined)
                strokeOpacity = self.shapeStrokeOpacity;
            if (strokeWidth == undefined)
                strokeWidth = self.shapeStrokeWidth;

            //console.log(&quot;fc=&quot; + fillColor + &quot;, fo=&quot; + fillOpacity + &quot;, sc=&quot; + strokeColor + &quot;, so=&quot; + strokeOpacity + &quot;, sw=&quot; + strokeWidth);

            elt.mouseover(function () { //glowing
                if (!noglow &amp;&amp; (mode == 0)) {
                    gl = elt.glow({ &quot;width&quot;: 15, &quot;color&quot;: &quot;#33ff00&quot;, &quot;opacity&quot;: 0.8 });
                }
            })
            elt.mouseout(function () {
                if (mode == 0) {
                    gl.remove();
                }
            })
            elt.attr({ //color attributes
                &quot;stroke-width&quot;: strokeWidth,
                &quot;stroke&quot;: strokeColor,
                &quot;stroke-opacity&quot;: strokeOpacity,
                &quot;fill&quot;: fillColor,
                &quot;fill-opacity&quot;: fillOpacity
            });

            //the drag handler looks like: drag(move, start, stop,...)
            elt.drag(function (dx, dy, mousex, mousey) {
                if (!mode) {
                    this.toFront();
                    if (!resize) {
                        //drag an element
                        var currx = parseInt(this.data(&quot;currx&quot;));//x position at the start of drag
                        var curry = parseInt(this.data(&quot;curry&quot;));
                        var xpos = currx + dx; //to get new x position, just add dx
                        var ypos = curry + dy;
                        this.attr({
                            cx: xpos + parseInt(this.data(&quot;curr_rx&quot;)), //xcenter is left+xradius
                            cy: ypos + parseInt(this.data(&quot;curr_ry&quot;)), //ycenter is top+yradius
                            x: xpos,
                            y: ypos
                        });
                    }
                    else {
                        //resize an element
                        var bbox = this.getBBox();
                        this.attr({
                            cx: bbox.x + bbox.width * 0.5 + (mousex - origmousex) * 0.5,
                            cy: bbox.y + bbox.height * 0.5 + (mousey - origmousey) * 0.5,
                            rx: bbox.width / 2.0 + (mousex - origmousex) * 0.5,
                            ry: bbox.height / 2.0 + (mousey - origmousey) * 0.5,
                            width: bbox.width + mousex - origmousex,
                            height: bbox.height + mousey - origmousey
                        });
                    }
                    origmousex = mousex;
                    origmousey = mousey;
                }
            }, function (x, y) { //onstart
                //console.log(&quot;mode = &quot; + mode);
                if (!mode) {

                    origmousex = x;
                    origmousey = y;
                    var bbox = this.getBBox();
                    console.log(&quot;bbox.height = &quot; + bbox.height);
                    resize = 0;
                    var canvx = 0;// parseInt($(&quot;#&quot; + canvId).css(&quot;left&quot;));
                    var canvy = 0;//parseInt($(&quot;#&quot; + canvId).css(&quot;top&quot;));
                    console.log(&quot;canvx=&quot; + canvx + &quot;, canvy=&quot; + canvy, &quot;, bbox.x=&quot; + bbox.x + &quot;, bbox.width=&quot; + bbox.width);
                    if ((x &gt; (bbox.x + bbox.width * 0.5 + canvx)) &amp;&amp; (y &gt; (bbox.y + bbox.height * 0.5 + canvy))) {
                        resize = 1;
                    }
                    gl.remove();
                    noglow = 1;
                    this.animate({ opacity: .25 }, 500, &quot;&lt;&gt;&quot;);
                }
                console.log(&quot;at end of start&quot;);
            }, function () { //onstop
                console.log(&quot;at beginning of stop&quot;);
                if (!mode) {
                    this.data(&quot;currx&quot;, this.getBBox().x); //reset data using bounding box coords
                    this.data(&quot;curry&quot;, this.getBBox().y);
                    this.data(&quot;curr_rx&quot;, this.getBBox().width / 2.0);
                    this.data(&quot;curr_ry&quot;, this.getBBox().height / 2.0);
                    noglow = 0;
                    resize = 0;
                    this.animate({ opacity: 1 }, 500, &quot;&lt;&gt;&quot;);
                }
            });
        }
        this.add_marq_attributes = function(marq, marqFillColor, marqFillOpacity) {
            /**
             * analogous to add_attributes(...), but for marquees. The difference is that a marquee
             * is a collection of five rectangles, and the center rectangle is the only one that gets
             * the drag handler, while the others have the color attributes.
             */
            var elt = marq.rc;
            var gl;
            var resize = 0; //if 1, we are in zoom mode rather than pan mode
            var noglow = 0; //if 1, glowing is disabled
            var origmousex;
            var origmousey;
            var w = parseInt($(&#x27;#&#x27; + self.canvid).css(&quot;width&quot;));
            var h = parseInt($(&#x27;#&#x27; + self.canvid).css(&quot;height&quot;));
            var mode = self.mode;
            //console.log(&quot;w=&quot; + w + &quot;, h=&quot; + h);
            if (marqFillColor == undefined)
                marqFillColor = self.marqueeFillColor;////////FIX &quot;#&quot; + document.getElementById(&quot;marq_color&quot;).value;
            if (marqFillOpacity == undefined)
                marqFillOpacity = self.marqueeFillOpacity;/////FIX document.getElementById(&quot;marq_opacity&quot;).value;

            elt.mouseover(function () {
                if (!noglow &amp;&amp; (mode == 3)) {
                    gl = elt.glow({ &quot;width&quot;: 10, &quot;color&quot;: &quot;#33ff00&quot;, &quot;opacity&quot;: .8 });
                }
            });
            elt.mouseout(function () {
                if (mode == 3)
                    gl.remove();
            });
            elt.attr({
                &quot;stroke-width&quot;: 0,
                &quot;stroke&quot;: &quot;#222222&quot;,
                &quot;fill&quot;: &quot;#ffffff&quot;,
                &quot;fill-opacity&quot;: 0
            });
            elt.data(&quot;surr-fill&quot;, marqFillColor);
            elt.data(&quot;surr-opac&quot;, marqFillOpacity);
            var mset = self.paper.set();
            mset.push(marq.rn, marq.re, marq.rs, marq.rw);
            mset.attr({
                &quot;stroke-width&quot;: 0,
                &quot;stroke&quot;: &quot;#222222&quot;,
                &quot;fill&quot;: marqFillColor,
                &quot;fill-opacity&quot;: marqFillOpacity
            });

            //drag(move, start, stop,...)
            elt.drag(function (dx, dy, mousex, mousey) {
                //onmove
                if (mode == 3) {
                    this.toFront();
                    var bbox = this.getBBox();
                    if (!resize) {
                        //drag an marquee -- need to update all relevant rectangles
                        var currx = parseInt(this.data(&quot;currx&quot;));//x position at the start of drag
                        var curry = parseInt(this.data(&quot;curry&quot;));
                        var xpos = currx + dx; //to get new x position, just add dx
                        var ypos = curry + dy;
                        this.attr({
                            x: xpos,
                            y: ypos
                        });
                        marq.rn.attr({
                            height: ypos
                        });
                        marq.re.attr({
                            x: xpos + bbox.width,
                            y: ypos,
                            width: w - (xpos + bbox.width),
                            height: bbox.height
                        });
                        marq.rs.attr({
                            y: ypos + bbox.height,
                            height: h - (ypos + bbox.height)
                        })
                        marq.rw.attr({
                            y: ypos,
                            width: xpos,
                            height: bbox.height
                        })

                    }
                    else {
                        //resize a marquee -- need to update all relevant rectangles
                        this.attr({
                            width: bbox.width + mousex - origmousex,
                            height: bbox.height + mousey - origmousey
                        });
                        marq.rs.attr({
                            y: bbox.y + bbox.height + mousey - origmousey,
                            height: h - (bbox.y + bbox.height + mousey - origmousey)
                        });
                        marq.re.attr({
                            x: bbox.x + bbox.width + mousex - origmousex,
                            width: w - (bbox.x + bbox.width + mousex - origmousex),
                            height: bbox.height + mousey - origmousey
                        })
                        marq.rw.attr({
                            height: bbox.height + mousey - origmousey
                        })
                    }
                    origmousex = mousex;
                    origmousey = mousey;
                }
            }, function (x, y) {
                //onstart
                if (mode == 3) {
                    origmousex = x;
                    origmousey = y;
                    var bbox = this.getBBox();
                    if ((x &gt; (bbox.x + bbox.width * 0.5)) &amp;&amp; (y &gt; (bbox.y + bbox.height * 0.5))) {
                        resize = 1;
                    }
                    gl.remove();
                    noglow = 1;
                    this.animate({ opacity: .25 }, 500, &quot;&lt;&gt;&quot;);
                }
            }, function () {
                //onstop
                if (mode == 3) {
                    this.data(&quot;currx&quot;, this.getBBox().x); //reset data using bounding box coords
                    this.data(&quot;curry&quot;, this.getBBox().y);
                    marq.re.data(&quot;currx&quot;, this.getBBox().x + this.getBBox().width);
                    marq.rs.data(&quot;curry&quot;, this.getBBox().y + this.getBBox().height);
                    resize = 0;
                    this.animate({ opacity: 1 }, 500, &quot;&lt;&gt;&quot;);
                    noglow = 0;
                }
            });
        }
        this.add_ellipse = function () {
            self.set_mode(0);
            console.log(&quot;setting cx and cy for the ellipse&quot;);
            var x = 100;//Math.floor(Math.random() * 300);
            var y = 100;//Math.floor(Math.random() * 300);
            var rx = 50;//20 + Math.floor(Math.random() * 40);
            var ry = 50;//20 + Math.floor(Math.random() * 40);
            var ellipse = self.paper.ellipse(x, y, rx, ry);
            ellipse.data(&quot;currx&quot;, ellipse.getBBox().x);
            ellipse.data(&quot;curry&quot;, ellipse.getBBox().y);
            ellipse.data(&quot;curr_rx&quot;, rx);
            ellipse.data(&quot;curr_ry&quot;, ry);
            ellipse.data(&quot;type&quot;, &quot;ellipse&quot;);
            self.add_attributes(ellipse);
        }
        this.add_rectangle = function() {
            self.set_mode(0);
            var x = Math.floor(Math.random() * 300);
            var y = Math.floor(Math.random() * 300);
            var rect = self.paper.rect(x, y, 50, 50);
            rect.data(&quot;currx&quot;, x);
            rect.data(&quot;curry&quot;, y);
            rect.data(&quot;type&quot;, &quot;rect&quot;);
            self.add_attributes();
        }
        this.add_marquee = function() {
            self.set_mode(3);
            console.log(&quot;mode = &quot; + mode);
            var topx = 200 + Math.floor(Math.random() * 10), botx = 300 + Math.floor(Math.random() * 10), topy = 200 + Math.floor(Math.random() * 10), boty = 300 + Math.floor(Math.random() * 10);
            var w = parseInt($(&#x27;#&#x27; + self.canvid).css(&quot;width&quot;));
            var h = parseInt($(&#x27;#&#x27; + self.canvid).css(&quot;height&quot;));
            var rn = self.paper.rect(0, 0, w, topy);
            rn.data(&quot;currx&quot;, 0);
            rn.data(&quot;curry&quot;, 0);
            var re = self.paper.rect(botx, topy, w - botx, boty - topy);
            re.data(&quot;currx&quot;, botx);
            re.data(&quot;curry&quot;, topy);
            var rs = self.paper.rect(0, boty, w, h - boty);
            rs.data(&quot;currx&quot;, 0);
            rs.data(&quot;curry&quot;, boty);
            var rw = self.paper.rect(0, topy, topx, boty - topy);
            rw.data(&quot;currx&quot;, 0);
            rw.data(&quot;curry&quot;, topy);
            var rc = self.paper.rect(topx, topy, botx - topx, boty - topy);
            rc.data(&quot;currx&quot;, topx);
            rc.data(&quot;curry&quot;, topy);
            rc.data(&quot;type&quot;, &quot;marquee&quot;);
            var m = new marquee(rn, re, rs, rw, rc);
            self.add_marq_attributes(canvId, rpaper, m);
            marquees.push(m);
            self.show_marquees();
            marquees_on = 1;
        }
        this.drawPaths = function(paths, strokeColor, strokeOpacity, strokeWidth) {
            if (paths == undefined) {
                var len = pathObjects.length;
                for (var i = 0; i &lt; pathObjects.length; i++) { //removes paths from canvas
                    pathObjects[i].remove();
                }
                for (var i = 0; i &lt; len; i++) { //clears the pathObjects array
                    pathObjects.shift();
                }
                for (var i = 0; i &lt; ml.length; i++) { //constructs the path
                    if (ml[i] !== &#x27;X&#x27;) {
                        paths += ml[i] + xy[i][0] + &#x27;,&#x27; + xy[i][1];;
                    }
                }
            }
            if (strokeColor == undefined)
                strokeColor = self.penColor;
            if (strokeOpacity == undefined)
                strokeOpacity = self.penOpacity
            if (strokeWidth == undefined)
                strokeWidth = self.penWidth;

            //removes all objects in pathObjects to be redrawn
            if (paths.length &gt; 0) {
                var path = paths.split(&#x27;M&#x27;);
            }
            for (var i = 1; i &lt; path.length; i++) {
                var drawing = self.paper.path(&#x27;M&#x27; + path[i]);
                drawing.data(&quot;type&quot;, &quot;path&quot;);
                drawing.attr({
                    &quot;stroke-width&quot;: strokeWidth,
                    &quot;stroke-opacity&quot;: strokeOpacity,
                    &quot;stroke&quot;: strokeColor,
                    &quot;stroke-linejoin&quot;: &quot;round&quot;,
                    &quot;stroke-linecap&quot;: &quot;round&quot;
                });
                drawing.toFront();
                pathObjects.push(drawing);
            }
            currpaths = paths;
            pathattrs = &quot;[stroke]&quot; + strokeColor + &quot;[strokeo]&quot; + strokeOpacity + &quot;[strokew]&quot; + strokeWidth;
        }
        this.erase = function (location) {
            var range = 5;////FIX parseInt(document.getElementById(&quot;eraser_width&quot;).value);
            for (var i = 0; i &lt; xy.length; i++) {
                if (location[0] - range &lt;= xy[i][0] &amp;&amp; xy[i][0] &lt;= location[0] + range) {
                    if (location[1] - range &lt;= xy[i][1] &amp;&amp; xy[i][1] &lt;= location[1] + range) {
                        if (ml[i + 1] === &#x27;L&#x27;) {
                            ml[i + 1] = &#x27;M&#x27;;
                        }
                        ml.splice(i, 1);
                        xy.splice(i, 1);
                        self.drawPaths();
                    }
                }
            }
        }
        this.hide_marquees = function() {
            var i;
            var len = marquees.length;
            for (i = 0; i &lt; len; i++) {
                marquees[i].rn.hide();
                marquees[i].re.hide();
                marquees[i].rs.hide();
                marquees[i].rw.hide();
                marquees[i].rc.hide();
            }
        }
        this.show_marquees = function() {
            var i;
            var len = self.marquees.length;
            for (i = 0; i &lt; len; i++) {
                var m = self.marquees[i];
                m.rn.show();
                m.re.show();
                m.rs.show();
                m.rw.show();
                m.rc.show();
            }
        }
        this.toggle_marquees = function() {
            self.marquees_on = 1 - self.marquees_on;
            if (self.marquees_on) {
                self.show_marquees();
            }
            else {
                self.hide_marquees();
            }
        }
        this.get_attr = function (str, attr, parsetype) {
            //parse==&quot;s&quot;: return as string, parse==&quot;i&quot;: return as int, parse==&quot;f&quot;: return as float
            if (parsetype == undefined)
                parsetype = &quot;f&quot;;

            if (parsetype == &quot;s&quot;)
                return str.split(&quot;[&quot; + attr + &quot;]&quot;)[1].split(&quot;[&quot;)[0];
            else if (parsetype == &quot;i&quot;)
                return parseInt(str.split(&quot;[&quot; + attr + &quot;]&quot;)[1].split(&quot;[&quot;)[0]);
            else
                return parseFloat(str.split(&quot;[&quot; + attr + &quot;]&quot;)[1].split(&quot;[&quot;)[0]);
        }
        this.rel_dims = function(abs_dim, canv_dim) {
            return parseFloat(abs_dim) / canv_dim;
        }
        this.abs_dims = function(rel_dim, canv_dim) {
            return parseFloat(rel_dim) * canv_dim;
        }
        this.discard = function() {
            remove_all(self.canvid, self.paper);
            self.paper = Raphael(0, 0, 0, 0);
        }
        this.set_mode = function(i) {
            i = parseInt(i);
            if ((i &lt; 1) || (i &gt; 3)) {
                self.mode = 0;
            }
            else {
                self.mode = i;
            }
        }
        this.transform_pathstring = function(currpaths, trans_factor_x, trans_factor_y, rnd) {
            //the trans_factors will be 1/w, 1/h if we are going from absolute to relative
            //to keep representations short, currently only storing three decimal points
            if (rnd == undefined) { rnd = 0; }
            else { rnd = 1; }

            var currpaths = self.currpaths;
            var nums = currpaths.match(/[0-9.]+/g);
            var newpath = &quot;&quot;;
            var j = 0, i = 0, n = currpaths.length;
            for (i = 0; i &lt; n; i++) {
                if ((currpaths[i] == &quot;M&quot;) || (currpaths[i] == &quot;L&quot;)) {
                    if (rnd) {
                        //alert(newpath);
                        newpath = newpath + currpaths[i] + Math.round(parseFloat(nums[j]) * trans_factor_x) + &quot;,&quot;;
                        newpath += Math.round(parseFloat(nums[j + 1]) * trans_factor_y);
                    }
                    else {
                        newpath = newpath + currpaths[i] + (parseFloat(nums[j]) * trans_factor_x).toFixed(3) + &quot;,&quot;;
                        newpath += (parseFloat(nums[j + 1]) * trans_factor_y).toFixed(3);
                    }
                    j = j + 2;
                }
            }
            return newpath;
        }
        this.update_datastring = function() {
            /*
              Returns a string giving all necessary information to recreate the current scene.
              This is helpful for saving Inks to be loaded later. The format is as follows:
                -Pen paths are all stored together in the substring
                
                    PATH::[pathstring]&lt;Raphael-format path string&gt;[stroke]&lt;stroke color&gt;\
                          [strokeo]&lt;stroke opacity[strokew]strokeWidth[]
                          
                 The trailing &#x27;[]&#x27; makes it easier to parse this string.
                -Rectangles are stored individually in the following format:
                    
                    RECT::[x]&lt;top corner x&gt;[y]&lt;top corner y&gt;[w]&lt;width&gt;[h]&lt;height&gt;\
                          [fillc]&lt;fill color&gt;[fillo]&lt;fill opacity&gt;[strokec]&lt;stroke color&gt;\
                          [strokeo]&lt;stroke opacity&gt;[strokew]&lt;stroke width&gt;[]
                          
                -Ellipses are stored individually in the following format:
                
                    ELLIPSE::[cx]&lt;center x&gt;[cy]&lt;center y&gt;[rx]&lt;x radius&gt;[ry]&lt;y radius&gt;\
                             [fillc]&lt;fill color&gt;[fillo]&lt;fill opacity&gt;[strokec]&lt;stroke color&gt;\
                             [strokeo]&lt;stroke opacity&gt;[strokew]&lt;stroke width&gt;[]
                             
                -The substrings are separated by &quot;|&quot; characters.
            */
            //document.getElementById(&quot;test_layers_div&quot;).innerHTML = &quot;&quot;;
            datastring = &quot;&quot;;
            var currpaths = self.currpaths;
            var canv_height = parseFloat($(&quot;#&quot; + self.canvid).css(&quot;width&quot;));
            var canv_height = parseFloat($(&quot;#&quot; + self.canvid).css(&quot;height&quot;));
            if (currpaths != &quot;&quot;) {
                var nound = currpaths;
                if (currpaths.split(&quot;undefined&quot;).length &gt; 1)
                    nound = currpaths.split(&quot;undefined&quot;)[1]
                var newpath = transform_pathstring(nound, 1.0 / canv_height, 1.0 / canv_width);

                var pth = &quot;PATH::[pathstring]&quot; + newpath + pathattrs + &quot;[]&quot;;
                datastring += pth + &quot;|&quot;;
            }
            paper.forEach(function (elt) {
                if (elt.data(&quot;type&quot;) == &quot;rect&quot;) {

                    var pth = &quot;RECT::[x]&quot; + self.rel_dims(elt.attr(&quot;x&quot;), canv_width) + &quot;[y]&quot; + self.rel_dims(elt.attr(&quot;y&quot;), canv_height);
                    pth += &quot;[w]&quot; + self.rel_dims(elt.attr(&quot;width&quot;), canv_width) + &quot;[h]&quot; + self.rel_dims(elt.attr(&quot;height&quot;), canv_height);
                    pth += &quot;[fillc]&quot; + elt.attr(&quot;fill&quot;) + &quot;[fillo]&quot; + elt.attr(&quot;fill-opacity&quot;);
                    pth += &quot;[strokec]&quot; + elt.attr(&quot;stroke&quot;) + &quot;[strokeo]&quot; + elt.attr(&quot;stroke-opacity&quot;) + &quot;[strokew]&quot; + elt.attr(&quot;stroke-width&quot;) + &quot;[]&quot;;

                    datastring += pth + &quot;|&quot;;
                }
                else if (elt.data(&quot;type&quot;) == &quot;ellipse&quot;) {

                    var pth = &quot;ELLIPSE::[cx]&quot; + self.rel_dims(elt.attr(&quot;cx&quot;), canv_width) + &quot;[cy]&quot; + self.rel_dims(elt.attr(&quot;cy&quot;), canv_height);
                    pth += &quot;[rx]&quot; + self.rel_dims(elt.attr(&quot;rx&quot;), canv_width) + &quot;[ry]&quot; + self.rel_dims(elt.attr(&quot;ry&quot;), canv_height);
                    pth += &quot;[fillc]&quot; + elt.attr(&quot;fill&quot;) + &quot;[fillo]&quot; + elt.attr(&quot;fill-opacity&quot;);
                    pth += &quot;[strokec]&quot; + elt.attr(&quot;stroke&quot;) + &quot;[strokeo]&quot; + elt.attr(&quot;stroke-opacity&quot;) + &quot;[strokew]&quot; + elt.attr(&quot;stroke-width&quot;) + &quot;[]&quot;;

                    datastring += pth + &quot;|&quot;;
                }
                else if (elt.data(&quot;type&quot;) == &quot;marquee&quot;) {

                    var pth = &quot;MARQUEE::[x]&quot; + self.rel_dims(elt.attr(&quot;x&quot;), canv_width) + &quot;[y]&quot; + self.rel_dims(elt.attr(&quot;y&quot;), canv_height);
                    pth += &quot;[w]&quot; + self.rel_dims(elt.attr(&quot;width&quot;), canv_width) + &quot;[h]&quot; + self.rel_dims(elt.attr(&quot;height&quot;), canv_height);
                    pth += &quot;[surrfillc]&quot; + elt.data(&quot;surr-fill&quot;) + &quot;[surrfillo]&quot; + elt.data(&quot;surr-opac&quot;) + &quot;[]&quot;;
                
                    datastring += pth + &quot;|&quot;;
                }
            });
            return datastring;
        }
        this.clearAndLoadInk = function (datastr) {
            remove_all(canvId, PAPER);
            this.loadInk(datastr);
        }
        this.resizePaper = function (width, height) {
            PAPER.setSize(width, height);
        }
        this.remove_all = function() {
            //removes all Raphael elements from the canvas
            self.paper.clear();
            //rpaper = Raphael(document.getElementById(&quot;#&quot;+canvId), &quot;100%&quot;, &quot;100%&quot;);//500, 500);
            ml.length=0;
            xy.length=0;
            paths.length=0;
            pathObjects.length=0;
            marquees.length=0;
            currpaths=&quot;&quot;;
            self.update_datastring();
        }
        this.update_ml_xy = function(str) {
            /*
              When we load a pen path, we need to add its information to the ml and
              xy arrays.
            */

            var i, j;

            //add info to ml
            for (i = 0; i &lt; str.length; i++) {
                if ((str[i] == &quot;L&quot;) || (str[i] == &quot;M&quot;)) {
                    self.ml.push(str[i]);
                }
            }

            //add info to xy
            var arr1 = str.split(&quot;L&quot;);
            for (i = 0; i &lt; arr1.length; i++) {
                if (arr1[i].length &gt; 0) {
                    var arr2 = arr1[i].split(&quot;M&quot;);
                    for (j = 0; j &lt; arr2.length; j++) {
                        if (arr2[j].length &gt; 0) {
                            var arr3 = arr2[j].split(&quot;,&quot;);
                            self.xy.push([arr3[0], arr3[1]]);
                        }
                    }
                }
            }
            self.click = false;
        }
        this.manipCanvas = function() {
            setDraggable(true);
        }
        this.setDraggable = function(option) {
            if (option === true) {
                self.set_mode(4);
                $(&quot;#&quot; + self.canvid).draggable({ disabled: false });
                $(&quot;#&quot; + self.canvid).resizable({ disabled: false });
            }
            else {
                //console.log(&quot;set not draggable&quot;);
                $(&quot;#&quot; + self.canvid).draggable({ disabled: true });
                $(&quot;#&quot; + self.canvid).resizable({ disabled: true });
                //CSS bug, sets undraggable opacity to 0.35
                $(&quot;#&quot; + self.canvid).css({ opacity: 1 });
            }
        }
        this.resizeObjects = function(scale_x, scale_y) {
            self.paper.forEach(function (elt) {
                if (elt.data(&quot;type&quot;) != &quot;path&quot;) {
                    elt.attr({
                        x: elt.attr(&quot;x&quot;) * scale_x,
                        y: elt.attr(&quot;y&quot;) * scale_y,
                        cx: elt.attr(&quot;cx&quot;) * scale_x,
                        cy: elt.attr(&quot;cy&quot;) * scale_y,
                        rx: elt.attr(&quot;rx&quot;) * scale_x,
                        ry: elt.attr(&quot;ry&quot;) * scale_y,
                        width: elt.attr(&quot;width&quot;) * scale_x,
                        height: elt.attr(&quot;height&quot;) * scale_y,
                    });

                    if (elt.data(&quot;type&quot;) == &quot;ellipse&quot;) {
                        elt.data(&quot;currx&quot;, elt.attr(&quot;cx&quot;) - elt.attr(&quot;rx&quot;));
                        elt.data(&quot;curry&quot;, elt.attr(&quot;cy&quot;) - elt.attr(&quot;ry&quot;));
                        elt.data(&quot;curr_rx&quot;, elt.attr(&quot;rx&quot;));
                        elt.data(&quot;curr_ry&quot;, elt.attr(&quot;ry&quot;));
                    }
                    else {
                        elt.data(&quot;currx&quot;, elt.attr(&quot;x&quot;));
                        elt.data(&quot;curry&quot;, elt.attr(&quot;y&quot;));
                    }
                    var gl = elt.glow({ &quot;width&quot;: 15, &quot;color&quot;: &quot;#33ff00&quot;, &quot;opacity&quot;: 0.8 });
                    gl.remove();
                }
            });
            for (var i = 0; i &lt; self.xy.length; i++) {
                self.xy[i][0] = self.xy[i][0] * scale_x;
                self.xy[i][1] = self.xy[i][1] * scale_y;
            }
            for (var i = 0; i &lt; pathObjects.length; i++) {
                self.pathObjects[i].scale(scale_x, scale_y, 0, 0);
            }
        }


        this.loadInk = function (datastr) {
            // load an ink from the input string of data (formats given below)
            var shapes = datastr.split(&quot;|&quot;);
            var i;
            var cw = self.cw;
            var ch = self.ch;
            for (i = 0; i &lt; shapes.length; i++) {
                var shape = shapes[i];
                var type = shape.split(&quot;::&quot;)[0];
                type = type.toLowerCase();
                switch (type) {
                    case &quot;rect&quot;:
                        //format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var x = abs_dims(get_attr(shape, &quot;x&quot;), cw);
                        var y = abs_dims(get_attr(shape, &quot;y&quot;), ch);
                        var w = abs_dims(get_attr(shape, &quot;w&quot;), cw);
                        var h = abs_dims(get_attr(shape, &quot;h&quot;), ch);

                        var fillc = get_attr(shape, &quot;fillc&quot;, &quot;s&quot;);
                        var fillo = get_attr(shape, &quot;fillo&quot;, &quot;f&quot;);
                        var strokec = get_attr(shape, &quot;strokec&quot;, &quot;s&quot;);
                        var strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        var strokew = get_attr(shape, &quot;strokew&quot;);
                        var R = self.paper.rect(x, y, w, h);
                        R.data(&quot;currx&quot;, x);
                        R.data(&quot;curry&quot;, y);
                        R.data(&quot;type&quot;, &quot;rect&quot;);
                        add_attributes(R, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case &quot;ellipse&quot;:
                        //format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var cx = abs_dims(get_attr(shape, &quot;cx&quot;), cw);
                        var cy = abs_dims(get_attr(shape, &quot;cy&quot;), ch);
                        var rx = abs_dims(get_attr(shape, &quot;rx&quot;), cw);
                        var ry = abs_dims(get_attr(shape, &quot;ry&quot;), ch);

                        var fillc = get_attr(shape, &quot;fillc&quot;, &quot;s&quot;);
                        var fillo = get_attr(shape, &quot;fillo&quot;, &quot;f&quot;);
                        var strokec = get_attr(shape, &quot;strokec&quot;, &quot;s&quot;);
                        var strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        var strokew = get_attr(shape, &quot;strokew&quot;);
                        var E = self.paper.ellipse(cx, cy, rx, ry);
                        E.data(&quot;currx&quot;, E.getBBox().x);
                        E.data(&quot;curry&quot;, E.getBBox().y);
                        E.data(&quot;curr_rx&quot;, rx);
                        E.data(&quot;curr_ry&quot;, ry);
                        E.data(&quot;type&quot;, &quot;ellipse&quot;);
                        add_attributes(E, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case &quot;marquee&quot;:
                        //format: [x]206[y]207[w]102[h]93[surrfillc]#222222[surrfillo].8[]
                        //where surrfillc and surrfillo define the color and opacity of the surrounding rects
                        var topx = abs_dims(get_attr(shape, &quot;x&quot;), cw);
                        var topy = abs_dims(get_attr(shape, &quot;y&quot;), ch);
                        var w = abs_dims(get_attr(shape, &quot;w&quot;), cw);
                        var h = abs_dims(get_attr(shape, &quot;h&quot;), ch);

                        var surrfillc = get_attr(shape, &quot;surrfillc&quot;, &quot;s&quot;);
                        var surrfillo = get_attr(shape, &quot;surrfillo&quot;, &quot;f&quot;);
                        var botx = topx + w;
                        var boty = topy + h;
                        var rn = self.paper.rect(0, 0, cw, topy);
                        rn.data(&quot;currx&quot;, 0);
                        rn.data(&quot;curry&quot;, 0);
                        var re = self.paper.rect(botx, topy, cw - botx, boty - topy);
                        re.data(&quot;currx&quot;, botx);
                        re.data(&quot;curry&quot;, topy);
                        var rs = self.paper.rect(0, boty, cw, ch - boty);
                        rs.data(&quot;currx&quot;, 0);
                        rs.data(&quot;curry&quot;, boty);
                        var rw = self.paper.rect(0, topy, topx, boty - topy);
                        rw.data(&quot;currx&quot;, 0);
                        rw.data(&quot;curry&quot;, topy);
                        var rc = self.paper.rect(topx, topy, botx - topx, boty - topy);
                        rc.data(&quot;currx&quot;, topx);
                        rc.data(&quot;curry&quot;, topy);
                        rc.data(&quot;type&quot;, &quot;marquee&quot;);
                        var m = new marquee(rn, re, rs, rw, rc);
                        self.add_marq_attributes(m, surrfillc, surrfillo);
                        self.marquees.push(m);
                        self.show_marquees();
                        self.marquees_on = 1;
                        break;
                    case &quot;path&quot;:
                        //format: [pathstring]M284,193L284,193[stroke]000000[strokeo]1[strokew]10[]
                        var pathstring = get_attr(shape, &quot;pathstring&quot;, &quot;s&quot;);
                        var strokec = get_attr(shape, &quot;stroke&quot;, &quot;s&quot;);
                        var strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        var strokew = get_attr(shape, &quot;strokew&quot;);
                        self.currpaths = self.transform_pathstring(pathstring, cw, ch, &quot;round&quot;);
                        self.update_ml_xy(self.currpaths);
                        self.drawPaths(self.currpaths, strokec, strokeo, strokew);
                        break;
                }
            }
        };

        // allow drawing on the Raphael paper
        var self = this;
        $(&quot;#&quot; + self.canvid).mousedown(function (e) {
            self.click = true;
            // console.log(&quot;mousedown&quot;);
            switch (mode) {
                case 1:
                    console.log(&quot;mousedown case 1&quot;);
                    self.ml.push(&#x27;M&#x27;);
                    self.xy.push([e.offsetX, e.offsetY]);
                    self.ml.push(&#x27;L&#x27;); //to allow drawing single dots
                    self.xy.push([e.offsetX, e.offsetY]);
                    self.drawPaths();
                    break;
                case 2:
                    self.erase([e.offsetX, e.offsetY]);
                    break;
            }
            //update_datastring();
        }).mouseup(function () {
            self.click = false;
        }).mouseleave(function () {
            if (self.click === true) {
                self.click = false;
            }
        }).mousemove(function (e) {
            //console.log(&quot;mousemove&quot;);
            if ((self.mode == 1) || (self.mode == 2)) {
                $(&quot;#&quot; + self.canvid).css(&#x27;cursor&#x27;, &#x27;crosshair&#x27;);
            }
            else {
                $(&quot;#&quot; + self.canvid).css(&#x27;cursor&#x27;, &#x27;pointer&#x27;);
            }
            if (self.click === false)
                return;
            switch (self.mode) {
                case 1:
                    self.ml.push(&#x27;L&#x27;);
                    self.xy.push([e.offsetX, e.offsetY]);
                    self.drawPaths();
                    break;
                case 2:
                    self.erase([e.offsetX, e.offsetY]);
                    break;
            }
        }).hover(function (e) {
            if (self.mode == 1) {
                $(&quot;#&quot; + self.canvid).css(&#x27;cursor&#x27;, &quot;pointer&quot;);
            }
        });

        this.setPenColor = function (c) { console.log(&quot;setting pen color to &quot; + c); this.penColor = c; };
        this.setPenOpacity = function (o) { console.log(&quot;setting pen opacity to &quot; + o); this.penOpacity = o; };
        this.setPenWidth = function (w) { console.log(&quot;setting pen width to &quot; + w); this.penWidth = w; };
        this.setEraserWidth = function (w) { this.eraserWidth = w; };
        this.setShapeStrokeColor = function (c) { this.shapeStrokeColor = c; };
        this.setShapeStrokeOpacity = function (o) { this.shapeStrokeOpacity = o; };
        this.setShapeStrokeWidth = function (w) { this.shapeStrokeWidth = w; };
        this.setMarqueeFillColor = function (c) { this.marqueeFillColor = c; };
        this.setMarqueeFillOpacity = function (o) { this.marqueeFillOpacity = o; };

        this.getPenColor = function () { return this.penColor; };
        this.getPenOpacity = function () { return this.penOpacity; };
        this.getPenWidth = function () { return this.penWidth; };
        this.getEraserWidth = function () { return this.eraserWidth; };
        this.getShapeStrokeColor = function () { return this.shapeStrokeColor; };
        this.getShapeStrokeOpacity = function () { return this.shapeStrokeOpacity; };
        this.getShapeStrokeWidth = function () { return this.shapeStrokeWidth; };
        this.getMarqueeFillColor = function () { return this.marqueeFillColor; };
        this.getMarqueeFillOpacity = function () { return this.marqueeFillOpacity; };

        this.updatePenColor = function (id) {
            var val = document.getElementById(id).value;
            if (val.length == 6)
                this.penColor = &quot;#&quot; + val;
        }
        this.updatePenOpacity = function (id) {
            var val = document.getElementById(id).value;
            if (val != undefined)
                this.penOpacity = val;
        }
        this.updatePenWidth = function (id) {
            var val = document.getElementById(id).value;
            if (val != undefined)
                this.penWidth = val;
        }
        this.updateShapeStrokeColor = function (id) {
            var val = document.getElementById(id).value;
            if (val.length == 6) {
                this.shapeStrokeColor = &quot;#&quot; + val;
            }
        }
        this.updateShapeStrokeOpacity = function (id) {
            var val = document.getElementById(id).value;
            if (val != undefined)
                this.shapeStrokeOpacity = val;
        }
        this.updateShapeStrokeWidth = function (id) {
            var val = document.getElementById(id).value;
            if (val != undefined)
                this.shapeStrokeWidth = val;
        }
        this.updateShapeFillColor = function (id) {
            var val = document.getElementById(id).value;
            if (val.length == 6)
                this.shapeFillColor = &quot;#&quot; + val;
        }
        this.updateShapeFillOpacity = function (id) {
            var val = document.getElementById(id).value;
            if (val != undefined)
                this.shapeFillOpacity = val;
        }
        this.updateMarqueeColor = function (id) {
            var val = document.getElementById(id).value;
            if (val.length == 6)
                this.marqueeFillColor = val;
        }
        this.updateMarqueeColor = function (id) {
            var val = document.getElementById(id).value;
            if (val != undefined)
                this.marqueeFillOpacity = val;
        }
    }

    function marquee(rectN, rectE, rectS, rectW, rectC) {
        //constructor for the marquee class
        this.rn = rectN;
        this.re = rectE;
        this.rs = rectS;
        this.rw = rectW;
        this.rc = rectC;
    }

    that.inkController = inkController;
    that.marquee = marquee;

    return that;
    ///////////////////////////////////////////////////////////////

}());
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
