<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>TAG/js/TAG/authoring/TAG.Authoring.SettingsView.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../TAG/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/TAG.AnnotatedImage.html">TAG.AnnotatedImage</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkViewer.html">TAG.Layout.ArtworkViewer</a></li>
            
                <li><a href="../classes/TAG.Layout.CollectionsPage.html">TAG.Layout.CollectionsPage</a></li>
            
                <li><a href="../classes/TAG.Layout.InternetFailurePage.js.html">TAG.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/TAG.Layout.StartPage.html">TAG.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG.Layout.VideoPlayer.html">TAG.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG.Util.Artwork.html">TAG.Util.Artwork</a></li>
            
                <li><a href="../classes/TAG.Util.IdleTimer.html">TAG.Util.IdleTimer</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: TAG/js/TAG/authoring/TAG.Authoring.SettingsView.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿TAG.Util.makeNamespace(&quot;TAG.Authoring.SettingsView&quot;);

/*  Creates a SettingsView, which is the first UI in authoring mode.  Note that
 *  left label, left container, etc... (anything with left) really refers to the
 *  middle panel, while the left-most bar is the navigation panel. Anything with right refers
 *  to the right panel which includes the viewer.
 *  @class TAG.Authoring.SettingsView
 *  @constructor
 *  @param startView sets the starting setting.  This can be &quot;Exhibitions&quot;, &quot;Artworks&quot;, &quot;Tours&quot;, 
 *       or &quot;General Settings&quot;.  Undefined/null, etc. goes to General Settings.
 *       TODO: Use constants instead of strings
 *   @param {Function} callback  called after the UI is done being created.
 *   @param {Function} backPage is a function to create the page to go back to (null/undefined goes
 *      back to the main page).  This function, when called with no arguments,
 *      should return a dom element that can be provided as an argument to 
 *      slidePageRight.
 *   @param startLabelID selects a left label automatically if it matches that id.
 *      The label will be scrolled to if it is off screen
 *   @return {Object} public methods and variables
 */
TAG.Authoring.SettingsView = function (startView, callback, backPage, startLabelID) {
    &quot;use strict&quot;;

        
    var root = TAG.Util.getHtmlAjax(&#x27;SettingsView.html&#x27;), //Get html from html file

        //get all of the ui elements from the root and save them in variables
        leftLoading = root.find(&#x27;#setViewLoadingCircle&#x27;),
        settingsContainer = root.find(&#x27;#setViewSettingsContainer&#x27;),
        searchContainer = root.find(&#x27;#setViewSearchContainer&#x27;),
        navBar = root.find(&#x27;#setViewNavBar&#x27;),
        searchbar = root.find(&#x27;#setViewSearchBar&#x27;),
        newButton = root.find(&#x27;#setViewNewButton&#x27;),
        secondaryButton = root.find(&#x27;#setViewSecondaryButton&#x27;),
        leftbar = root.find(&#x27;#setViewLeftBar&#x27;),
        leftLabelContainer = root.find(&#x27;#setViewLeftLabelContainer&#x27;),
        rightbar = root.find(&#x27;#setViewRightBar&#x27;),
        viewer = root.find(&#x27;#setViewViewer&#x27;),
        buttonContainer = root.find(&#x27;#setViewButtonContainer&#x27;),
        settings = root.find(&#x27;#setViewSettingsBar&#x27;),
        label = root.find(&#x27;#setViewLoadingLabel&#x27;),
        circle = root.find(&#x27;#setViewLoadingCircle&#x27;),

        // Constants
        VIEWER_ASPECTRATIO = $(window).width() / $(window).height(),
        //Should probably get rid of any hard-coded values here:
        RIGHT_WIDTH = &#x27;54&#x27;, 
        CONTENT_HEIGHT = &#x27;92&#x27;,
        HIGHLIGHT = &#x27;white&#x27;,
        BUTTON_HEIGHT = &#x27;40&#x27;,
        DEFAULT_SEARCH_TEXT = &#x27;Search...&#x27;,
        PICKER_SEARCH_TEXT = &#x27;Search by Name, Artist, or Year...&#x27;,

        // Text for Navagation labels
        NAV_TEXT = {
        general: {
            text: &#x27;General Settings&#x27;,
            subtext: &#x27;Customize TAG experience&#x27;
        },
        exhib: {
            text: &#x27;Collections&#x27;,
            subtext: &#x27;Create and edit collections&#x27;
        },
        art: {
            text: &#x27;Artworks&#x27;,
            subtext: &#x27;Import and manage artworks&#x27;
        },
        media: {
            text: &#x27;Associated Media&#x27;,
            subtext: &#x27;Manage associated media&#x27;
        },
        tour: {
            text: &#x27;Tours&#x27;,
            subtext: &#x27;Build interactive tours&#x27;
        },
        feedback: {
            text: &#x27;Feedback&#x27;,
            subtext: &#x27;View comments and reports&#x27;
        },
    },

    that = {
        getRoot: getRoot,
    },
    
        prevSelectedSetting,
        prevSelectedLeftLabel,
        // These are &#x27;asynchronous&#x27; queues to perform tasks. These queues will process events in order, but asynchronously so
        // they can be completed in the &#x27;background&#x27;. Calling .add(fn) adds a function to the queue while .clear() clears the queue.  
        //Note that an in progress function will not be canceled by .clear().
        leftQueue = TAG.Util.createQueue(),  //used to add things to the left label container
        rightQueue = TAG.Util.createQueue(), //used to add things to the right panel
        cancelLastSetting,
        artPickerOpen = false,
        nav = [],
        artworks = [],
        assetUploader,
        mediaMetadata = [],
        numFiles = 0,
        isUploading = false,
        isCreatingMedia = false,
        artworkAssociations = [], // entry i contains the artwork info for the ith associated media
        artworkList = [], // save artworks retrieved from the database
        mediaCheckedIDs = [], // artworks checked in associated media uploading
        mediaUncheckedIDs = [], // artworks unchecked in associated media uploading
        editArt; // enter artwork editor button

    loadHelper();
    if (callback) {
        callback(that);
    }

    /**
     * Helper function to set up UI elements and switch to first view
     * @method loadHelper
     * @param {Object} main  
     */
    function loadHelper(main){

        //Setting up UI:
        var backButton = root.find(&#x27;#setViewBackButton&#x27;);
        backButton.attr(&#x27;src&#x27;, &#x27;images/icons/Back.svg&#x27;);

        backButton.mousedown(function () {
            TAG.Util.UI.cgBackColor(&quot;backButton&quot;, backButton, false);
        });

        backButton.mouseleave(function () {
            TAG.Util.UI.cgBackColor(&quot;backButton&quot;, backButton, true);
        });

        backButton.click(function () {
            TAG.Auth.clearToken();
            rightQueue.clear();
            leftQueue.clear();
            backButton.off(&#x27;click&#x27;);
            if (backPage) {
                var bpage = backPage();
                TAG.Util.UI.slidePageRight(bpage);
            } else {
                TAG.Layout.StartPage(null, function (page) {
                    TAG.Util.UI.slidePageRight(page);
                });
            }
        });

        var topBarLabel = root.find(&#x27;#setViewTopBarLabel&#x27;);
        var topBarLabelSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08,
        {
            width: 0.4,
            height: 0.9,
        });
        topBarLabel.css({
            &#x27;height&#x27;: topBarLabelSpecs.height + &#x27;px&#x27;,
            &#x27;width&#x27;: topBarLabelSpecs.width + &#x27;px&#x27;,
        });
        var fontsize = TAG.Util.getMaxFontSizeEM(&#x27;Tour Authoring&#x27;, 0.5, topBarLabelSpecs.width, topBarLabelSpecs.height * 0.8, 0.1);
        topBarLabel.css({ &#x27;font-size&#x27;: fontsize });
        topBarLabel.text(&#x27;Authoring Mode&#x27;);

        //Add text to navigation bar:

        navBar.append(nav[NAV_TEXT.general.text] = createNavLabel(NAV_TEXT.general, loadGeneralView));
        navBar.append(nav[NAV_TEXT.exhib.text] = createNavLabel(NAV_TEXT.exhib, loadExhibitionsView));
        navBar.append(nav[NAV_TEXT.art.text] = createNavLabel(NAV_TEXT.art, loadArtView));
        navBar.append(nav[NAV_TEXT.media.text] = createNavLabel(NAV_TEXT.media, loadAssocMediaView)); // COMMENT!!!!!!!!
        navBar.append(nav[NAV_TEXT.tour.text] = createNavLabel(NAV_TEXT.tour, loadTourView));
        navBar.append(nav[NAV_TEXT.feedback.text] = createNavLabel(NAV_TEXT.feedback, loadFeedbackView));
        searchbar.keyup(function () {
            search(searchbar.val(), &#x27;.leftLabel&#x27;, &#x27;div&#x27;);
        });
        searchbar.change(function () {
            search(searchbar.val(), &#x27;.leftLabel&#x27;, &#x27;div&#x27;);
        });

        // Workaround for clear button (doesn&#x27;t fire a change event...)
        searchbar.mouseup(function () {
            setTimeout(function () {
                search(searchbar.val(), &#x27;.leftLabel&#x27;, &#x27;div&#x27;);
            }, 1);
        });

        searchbar.attr(&#x27;placeholder&#x27;, &#x27;Search...&#x27;);
        newButton.text(&#x27;New&#x27;);
        secondaryButton.text(&#x27;Video&#x27;);
        label.text(&#x27;Loading...&#x27;);
        circle.attr(&#x27;src&#x27;, &#x27;images/icons/progress-circle.gif&#x27;);

        viewer.css({
            &#x27;height&#x27;: $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + &#x27;px&#x27;,
        });

        buttonContainer.css({
            &#x27;top&#x27;: $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + &#x27;px&#x27;,
        });
        settings.css({
            &#x27;height&#x27;: getSettingsHeight() + &#x27;px&#x27;,
        });
        switchView(startView, startLabelID);
    }
    
    /**Switches the view based on selected navigation label
     * @method switchView
     * @param {String} view         the view to switch to
     * @param {Object} id           the id of the left label to start on
     */
    function switchView(view, id) {
        resetLabels(&#x27;.navContainer&#x27;);
        switch (view) {
            case &quot;Exhibitions&quot;:
                selectLabel(nav[NAV_TEXT.exhib.text]);
                prevSelectedSetting = nav[NAV_TEXT.exhib.text];
                loadExhibitionsView(id);
                break;
            case &quot;Artworks&quot;:
                selectLabel(nav[NAV_TEXT.art.text]);
                prevSelectedSetting = nav[NAV_TEXT.art.text];
                loadArtView(id);
                break;
            case &quot;Associated Media&quot;: 
                selectLabel(nav[NAV_TEXT.media.text]);
                prevSelectedSetting = nav[NAV_TEXT.media.text];
                loadAssocMediaView(id);
                break;
            case &quot;Tours&quot;:
                selectLabel(nav[NAV_TEXT.tour.text]);
                prevSelectedSetting = nav[NAV_TEXT.tour.text];
                loadTourView(id);
                break;
            case &quot;Feedback&quot;:
                selectLabel(nav[NAV_TEXT.feedback.text]);
                prevSelectedSetting = nav[NAV_TEXT.feedback.text];
                loadFeedbackView(id);
                break;
            case &quot;General Settings&quot;:
            default:
                selectLabel(nav[NAV_TEXT.general.text]);
                prevSelectedSetting = nav[NAV_TEXT.general.text];
                loadGeneralView();
                break;
        }
    }

    /**Returns root
     * @method getRoot
     * @return {Object} root 
     */
    function getRoot() {
        return root;
    }

    // Navigation Bar Functions:

     /**Create a navigation label
     * @method createNavLabel
     * @param {String} text         text for label
     * @param {Function} onclick    onclick function for label
     * @return {Object} container   container containing new label
     */
    function createNavLabel(text, onclick) {
        var container = $(document.createElement(&#x27;div&#x27;));
        container.attr(&#x27;class&#x27;, &#x27;navContainer&#x27;);
        container.attr(&#x27;id&#x27;, &#x27;nav-&#x27; + text.text);
        container.mousedown(function () {
            container.css({
                &#x27;background&#x27;: HIGHLIGHT
            });
        });
        container.mouseup(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.mouseleave(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.click(function () {
            // If a label is clicked return if its already selected.
            if (prevSelectedSetting === container)
                return;
            // Reset all labels and then select this one
            resetLabels(&#x27;.navContainer&#x27;);
            selectLabel(container);
            // Do the onclick function
            if (onclick)
                onclick();
            prevSelectedSetting = container;
        });

        var navtext = $(document.createElement(&#x27;label&#x27;));
        navtext.attr(&#x27;class&#x27;,&#x27;navtext&#x27;);
        navtext.text(text.text);

        var navsubtext = $(document.createElement(&#x27;label&#x27;));
        navsubtext.attr(&#x27;class&#x27;,&#x27;navsubtext&#x27;);
        navsubtext.text(text.subtext);

        container.append(navtext);
        container.append(navsubtext);
        return container;
    }

    // General Settings Functions:

    /**Loads the General Settings view
     * @method loadGeneralView
     */
    function loadGeneralView() {
        prepareNextView(false);

        // Add this to our queue so the UI doesn&#x27;t lock up
        leftQueue.add(function () {
            var label;
            // Add the Splash Screen label and set it as previously selected because its our default
            leftLoading.before(label = selectLabel(createLeftLabel(&#x27;Splash Screen&#x27;, null, loadSplashScreen), true));
            prevSelectedLeftLabel = label;
            // Default to loading the splash screen
            loadSplashScreen();
            // Add the Password Settings label
            leftLoading.before(createLeftLabel(&#x27;Password Settings&#x27;, null, loadPasswordScreen).attr(&#x27;id&#x27;, &#x27;password&#x27;));
            leftLoading.hide();
        });
        cancelLastSetting = null;
    }

    /**Sets up the right side of the UI for the splash screen
     * including the viewer, buttons, and settings container.
     * @method loadSplashScreen
     */
    function loadSplashScreen() {
        prepareViewer(true);
        clearRight();

        // Load the start page, the callback will add it to the viewer when its done
        var startPage = new TAG.Layout.StartPage(null, function (startPage) {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.general.text]) {
                return;
            }
            viewer.append(startPage);
            // Don&#x27;t allow the viewer to be clicked
            preventClickthrough(viewer);
        }, true);

        // Get DB Values
        var alpha = TAG.Worktop.Database.getMuseumOverlayTransparency();
        var overlayColor = TAG.Worktop.Database.getMuseumOverlayColor();
        var name = TAG.Worktop.Database.getMuseumName();
        var loc = TAG.Worktop.Database.getMuseumLoc();
        var info = TAG.Worktop.Database.getMuseumInfo();
        if (name === undefined) {
            name = &quot;&quot;;
        }
        if (loc === undefined) {
            loc = &quot;&quot;;
        }
        if (info === undefined) {
            info = &quot;&quot;;
        }
        var logoColor = TAG.Worktop.Database.getLogoBackgroundColor();

        // Create inputs
        var alphaInput = createTextInput(Math.floor(alpha * 100), true);
        var bgImgInput = createButton(&#x27;Change Image&#x27;, function () {
            uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                bgImgInput.val(url);
                $(&#x27;#background&#x27;).css({
                    &#x27;background-image&#x27;: &#x27;url(&quot;&#x27; + TAG.Worktop.Database.fixPath(url) + &#x27;&quot;)&#x27;,
                    &#x27;background-size&#x27;: &#x27;cover&#x27;,
                });
            });
        });
        var logoInput = createButton(&#x27;Change Logo&#x27;, function () {
            uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                logoInput.val(url);
                $(&#x27;#logo&#x27;)[0].src = TAG.Worktop.Database.fixPath(url);
            });
        });
        var overlayColorInput = createBGColorInput(overlayColor, &#x27;.infoDiv&#x27;, function () { return alphaInput.val(); });
        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(name), true, 40);
        var locInput = createTextInput(TAG.Util.htmlEntityDecode(loc), true, 45);
        var infoInput = createTextAreaInput(TAG.Util.htmlEntityDecode(info), true);
        var logoColorInput = createBGColorInput(logoColor, &#x27;.logoContainer&#x27;, function () { return 100; });

        // Handle changes
        onChangeUpdateNum(alphaInput, 0, 100, function (num) {
            updateBGColor(&#x27;.infoDiv&#x27;, overlayColorInput.val(), num);
        });
        onChangeUpdateText(nameInput, &#x27;#museumName&#x27;, 40);
        nameInput.keyup(function () {
            startPage.fixText();
        });
        nameInput.keydown(function () {
            startPage.fixText();
        });
        nameInput.change(function () {
            startPage.fixText();
        });
        onChangeUpdateText(locInput, &#x27;#subheading&#x27;, 33);
        onChangeUpdateText(infoInput, &#x27;#museumInfo&#x27;, 300);

        var bgImage = createSetting(&#x27;Background Image&#x27;, bgImgInput);
        var overlayAlpha = createSetting(&#x27;Overlay Transparency (0-100)&#x27;, alphaInput);
        var overlayColorSetting = createSetting(&#x27;Overlay Color&#x27;, overlayColorInput);
        var museumName = createSetting(&#x27;Museum Name&#x27;, nameInput);
        var museumLoc = createSetting(&#x27;Museum Location&#x27;, locInput);
        var museumInfo = createSetting(&#x27;Museum Info&#x27;, infoInput);
        var museumLogo = createSetting(&#x27;Museum Logo&#x27;, logoInput);
        var logoColorSetting = createSetting(&#x27;Museum Logo Background Color&#x27;, logoColorInput);

        settingsContainer.append(bgImage);
        settingsContainer.append(overlayColorSetting);
        settingsContainer.append(overlayAlpha);
        settingsContainer.append(museumName);
        settingsContainer.append(museumLoc);
        settingsContainer.append(museumInfo);
        settingsContainer.append(museumLogo);
        settingsContainer.append(logoColorSetting);

        // Save button
        var saveButton = createButton(&#x27;Save Changes&#x27;, function () {
            if (locInput === undefined) {
                locInput = &quot;&quot;;
            }
            if (infoInput === undefined) {
                infoInput = &quot;&quot;;
            }
            //save Splash screen and pass in inpts with following keys:
            saveSplashScreen({
                alphaInput: alphaInput,                 //Overlay Transparency
                overlayColorInput: overlayColorInput,   //Overlay Color
                nameInput: nameInput,                   //Museum Name
                locInput: locInput,                     //Museum Location
                infoInput: infoInput,                   //Museum Info
                logoColorInput: logoColorInput,         //Logo background color
                bgImgInput: bgImgInput,                 //Background image
                logoInput: logoInput,                   //Logo image
            });
        }, {
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
            &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
            &#x27;float&#x27;: &#x27;right&#x27;
        });

        buttonContainer.append(saveButton);
    }

    /**Saves the splash screen settings
     * @method saveSplashScreen
     * @param {Object} inputs       information from setting inputs
     */
    function saveSplashScreen(inputs) {
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);

        var alpha = inputs.alphaInput.val()/100;
        var overlayColor = inputs.overlayColorInput.val();
        var name = inputs.nameInput.val();
        var loc = inputs.locInput.val();
        var info = inputs.infoInput.val().replace(&#x27;/\n\r?/g&#x27;, &#x27;&lt;br /&gt;&#x27;);
        var logoColor = inputs.logoColorInput.val();
        var bgImg = inputs.bgImgInput.val();
        var logo = inputs.logoInput.val();
      
        var options = {
            Name: name,
            OverlayColor: overlayColor,
            OverlayTrans: alpha,
            Location: loc,
            Info: info,
            IconColor: logoColor,
        };
        if (bgImg) options.Background = bgImg;
        if (logo) options.Icon = logo;
        //Change the settings in the database
        TAG.Worktop.Database.changeMain(options, function () {
            TAG.Worktop.Database.getMain(loadGeneralView, error(loadGeneralView), null);
            ;
        }, authError, conflict({ Name: &#x27;Main&#x27; }, &#x27;Update&#x27;, loadGeneralView), error(loadGeneralView));
    }

    /**Set up the right side of the UI for the  password changer
     * @method loadPasswordScreen
     */
    function loadPasswordScreen() {
        //Prepare right side without showing the viewer or buttonContainer
        prepareViewer(false, null, false);
        clearRight();

        var loading = createLabel(&#x27;Loading...&#x27;);
        var loadingSetting = createSetting(&#x27;&#x27;, loading);
        settingsContainer.append(loadingSetting);

        TAG.Worktop.Database.checkSetting(&#x27;AllowChangePassword&#x27;, function (val) {
            loadingSetting.remove();
            if (val.toLowerCase() === &#x27;true&#x27;) {
                var oldInput = createTextInput(&#x27;&#x27;, false);
                var newInput1 = createTextInput(&#x27;&#x27;, false);
                var newInput2 = createTextInput(&#x27;&#x27;, false);
                var msgLabel = createLabel(&#x27;&#x27;);

                oldInput.attr(&#x27;type&#x27;, &#x27;password&#x27;);
                newInput1.attr(&#x27;type&#x27;, &#x27;password&#x27;);
                newInput2.attr(&#x27;type&#x27;, &#x27;password&#x27;);

                var old = createSetting(&#x27;Current Password&#x27;, oldInput);
                var new1 = createSetting(&#x27;New Password&#x27;, newInput1);
                var new2 = createSetting(&#x27;Confirm New Password&#x27;, newInput2);
                var msg = createSetting(&#x27;&#x27;, msgLabel);

                settingsContainer.append(old);
                settingsContainer.append(new1);
                settingsContainer.append(new2);
                settingsContainer.append(msg);

                //Hide or else unused div covers &#x27;Old Password&#x27; line
                buttonContainer.css(&#x27;display&#x27;, &#x27;none&#x27;);

                var saveButton = createButton(&#x27;Update Password&#x27;, function () {
                    savePassword({
                        old: oldInput,         // Old password
                        new1: newInput1,       // New password
                        new2: newInput2,       // New password confirmation
                        msg: msgLabel,         // Message area
                    });
                });
                // Make the save button respond to enter
                saveButton.removeAttr(&#x27;type&#x27;);
                var save = createSetting(&#x27;&#x27;, saveButton);
                settingsContainer.append(save);
            } else {
                passwordChangeNotSupported();
            }
        });
    }

    /**Display label if password change not supported by server
     *@method passwordChangeNotSupported
     */
    function passwordChangeNotSupported() {
        var label = createLabel(&#x27;&#x27;);
        var setting = createSetting(&#x27;Changing the password has been disabled by the server.  Contact the server administrator for more information&#x27;, label);
        settingsContainer.append(setting);
    }

    /**Updates the new password
     * @method savePassword
     * @param {Object} inputs    keys for password change
     */
    function savePassword(inputs) {
        inputs.msg.text(&#x27;Processing...&#x27;);
        if (inputs.new1.val() !== inputs.new2.val()) {
            inputs.msg.text(&#x27;New passwords do not match.&#x27;);
        } else {
            TAG.Auth.changePassword(inputs.old.val(), inputs.new1.val(),
                function () {
                    inputs.msg.text(&#x27;Password Saved.&#x27;);
                    inputs.old.val(&#x27;&#x27;);
                    inputs.new1.val(&#x27;&#x27;);
                    inputs.new2.val(&#x27;&#x27;);
                },
                function (msg) {
                    if (msg) {
                        inputs.msg.html(msg);
                    } else {
                        inputs.msg.text(&#x27;Incorrect Password.&#x27;);
                    }
                },
                function () {
                    inputs.msg.text(&#x27;There was an error contacting the server.&#x27;);
                });
        }
    }

    // Collection Functions:

    /**Loads the collections view
     * @method loadExhibitionsView
     * @param {Object} id       id of left label to start on
     */
    function loadExhibitionsView(id) {
        var cancel = false;
        // Set the new button text to &quot;New&quot;
        prepareNextView(true, &quot;New&quot;, createExhibition);
        clearRight();
        prepareViewer(true);

        // Make an async call to get the list of exhibitions
        TAG.Worktop.Database.getExhibitions(function (result) {
            if (cancel) return;
            sortAZ(result);
            $.each(result, function (i, val) {
                if (cancel) return;
                // Add each label as a separate function in the queue so they don&#x27;t lock up the UI
                leftQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                        return;
                    }
                    var label;
                    if (!prevSelectedLeftLabel &amp;&amp;
                        ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                        
                        // Select the first one or the specified id
                        leftLoading.before(selectLabel(label = createLeftLabel(val.Name, null, function () {
                            loadExhibition(val);
                        }, val.Identifier), true));

                        // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                        if (leftbar.scrollTop() === 0 &amp;&amp; label.offset().top - leftbar.height() &gt; 0) {
                            leftbar.animate({
                                scrollTop: (label.offset().top - leftbar.height())
                            }, 1000);
                        }
                        prevSelectedLeftLabel = label;
                        loadExhibition(val);
                    } else {
                        leftLoading.before(label = createLeftLabel(val.Name, null, function () {
                            loadExhibition(val);
                        }, val.Identifier));
                    }
                    // Hide the label if it doesn&#x27;t match the current search criteria
                    if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                        label.hide();
                    }
                });
            });
            // Hide the loading label when we&#x27;re done
            leftQueue.add(function () {
                leftLoading.hide();
            });
        });
        cancelLastSetting = function () { cancel = true; };
    }

    /**Set up the right side for a collection
     * @method loadExhibition
     * @param {Object} exhibition   exhibition to load
     */
    function loadExhibition(exhibition) {
        prepareViewer(true);
        clearRight();

        // Set the viewer to exhibition view (see function below)
        exhibitionView(exhibition);

        // Create inputs
        var privateState;
        if (exhibition.Metadata.Private) {
            privateState = (/^true$/i).test(exhibition.Metadata.Private);
        } else {
            privateState = false;
        }
        var privateInput = createButton(&#x27;Unpublish&#x27;, function () {
            privateState = true;
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            publicInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;margin-right&#x27;: &#x27;4%&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        privateInput.attr(&#x27;class&#x27;, &#x27;settingButton&#x27;);
        var publicInput = createButton(&#x27;Publish&#x27;, function () {
            privateState = false;
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            privateInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        publicInput.attr(&#x27;class&#x27;, &#x27;settingButton&#x27;);
        if (privateState) {
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        } else {
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        }
        var pubPrivDiv = $(document.createElement(&#x27;div&#x27;));
        pubPrivDiv.append(privateInput).append(publicInput);

        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(exhibition.Name), &#x27;Collection name&#x27;, 40);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(exhibition.Metadata.Description), false);
        var bgInput = createButton(&#x27;Change Background Image&#x27;, function () {
            uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                bgInput.val(url);
                $(&#x27;#bgimage&#x27;).css({
                    &#x27;background-image&#x27;: &#x27;url(&quot;&#x27; + TAG.Worktop.Database.fixPath(url) + &#x27;&quot;)&#x27;,
                    &#x27;background-size&#x27;: &#x27;cover&#x27;,
                });
            });
        });
        var previewInput = createButton(&#x27;Change Image&#x27;, function () {
            uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                previewInput.val(url);
                $(&#x27;#img1&#x27;)[0].src = TAG.Worktop.Database.fixPath(url);
            });
        });

        nameInput.focus(function () {
            if (nameInput.val() === &#x27;Collection&#x27;)
                nameInput.select();
        });

        descInput.focus(function () {
            if (descInput.val() === &#x27;Description&#x27;)
                descInput.select();
        });

        // Handle Changes
        onChangeUpdateText(nameInput, &#x27;#exhibition-title&#x27;, 40);
        onChangeUpdateText(descInput, &#x27;#description-text&#x27;, 1790);

        var privateSetting = createSetting(&#x27;Change Publish Setting&#x27;, pubPrivDiv);
        var name = createSetting(&#x27;Collection Name&#x27;, nameInput);
        var desc = createSetting(&#x27;Collection Description&#x27;, descInput);
        var bg = createSetting(&#x27;Collection Background Image&#x27;, bgInput);
        var preview = createSetting(&#x27;Collection Preview Image&#x27;, previewInput);

        settingsContainer.append(privateSetting);
        settingsContainer.append(name);
        settingsContainer.append(desc);
        settingsContainer.append(bg);
        settingsContainer.append(preview);

        // Buttons
        var saveButton = createButton(&#x27;Save Changes&#x27;, function () {
            if (nameInput.val() === undefined || nameInput.val() === &quot;&quot;) {
                nameInput.val(&quot;Untitled Collection&quot;);
            }
            saveExhibition(exhibition, {
                privateInput: privateState,  //default set unpublished
                nameInput: nameInput,        //Collection name
                descInput: descInput,        //Collection description
                bgInput: bgInput,            //Collection background image
                previewInput: previewInput,  //Collection preview image
            });
        }, {
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
            &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
            &#x27;float&#x27;: &#x27;right&#x27;,
        });

        var deleteButton = createButton(&#x27;Delete Collection&#x27;, function () {
            deleteExhibition(exhibition);
        }, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        var catalogNext = true;

        var artPickerButton = createButton(&#x27;Manage Collection&#x27;, function () {
            TAG.Util.UI.createAssociationPicker(root, &quot;Add and Remove Artworks in this Collection&quot;,
                { comp: exhibition, type: &#x27;exhib&#x27; },
                &#x27;exhib&#x27;, [{
                    name: &#x27;All Artworks&#x27;,
                    getObjs: TAG.Worktop.Database.getArtworksAndTours,
                }, {
                    name: &#x27;Artworks in this Collection&#x27;,
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }], {
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }, function () {
                    prepareNextView(true, &quot;New&quot;, createExhibition);
                    clearRight();
                    prepareViewer(true);
                    loadExhibitionsView(exhibition.Identifier);
                });

        }, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        /**Helper method to set the viewer to exhibition view
         * @method exhibitionView
         * @param {Object} exhibition    exhibition to load
         */
        function exhibitionView(exhibition) {
            rightQueue.add(function () {
                var exhibView = new TAG.Layout.NewCatalog(null, exhibition, viewer);
                var exroot = exhibView.getRoot();
                $(exroot).css(&#x27;z-index&#x27;,&#x27;-1&#x27;); // otherwise, you can use the search box and sorting tabs!
                viewer.append(exroot);
                preventClickthrough(viewer);
            });
        }

        buttonContainer.append(artPickerButton).append(deleteButton).append(saveButton);
    }

    /**Create an exhibition
     * @method createExhibition
     */
    function createExhibition() {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.createExhibition(null, function (newDoq) {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                return;
            }
            if (!newDoq) { // Shouldn&#x27;t happen!
                // TODO: Error Message
                loadExhibitionsView();
                return;
            }
            loadExhibitionsView(newDoq.Identifier);
        }, authError, error(loadExhibitionsView), true);
    }

    /** Save a collection
     * @method saveExhibition
     * @param {Object} exhibition   collection to save
     * @inputs {Object} inputs      keys from input fields
     */
    function saveExhibition(exhibition, inputs) {
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);

        var name = inputs.nameInput.val();
        var desc = inputs.descInput.val();
        var bg = inputs.bgInput.val();
        var preview = inputs.previewInput.val();
        var priv = inputs.privateInput;

        var options = {
            Name: name,
            Private: priv,
            Description: desc,
        }

        if (bg)
            options.Background = bg;
        if (preview)
            options.Img1 = preview;

        TAG.Worktop.Database.changeExhibition(exhibition.Identifier, options, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                return;
            }
            loadExhibitionsView(exhibition.Identifier);
        }, authError, conflict(exhibition, &quot;Update&quot;, loadExhibitionsView), error(loadExhibitionsView));
    }

    /**Delete a collection
     * @method deleteExhibition
     * @param {Object} exhibition     collection to delete
     */
    function deleteExhibition(exhibition) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the exhibition
            TAG.Worktop.Database.deleteDoq(exhibition.Identifier, function () {
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                    return;
                }
                loadExhibitionsView();
            }, authError, conflict(exhibition, &quot;Delete&quot;, loadExhibitionsView), error(loadExhibitionsView));
        }, &quot;Are you sure you want to delete &quot; + exhibition.Name + &quot;?&quot;, &quot;Delete&quot;, true, function() { $(confirmationBox).hide(); });
        root.append(confirmationBox);
        $(confirmationBox).show();
    }


    // Tour Functions:

    /**Load the tour view
     * @method loadTourView
     * @param {Object} id   id of left label to start on
     */
    function loadTourView(id) {
        prepareNextView(true, &quot;New&quot;, createTour);
        clearRight();
        prepareViewer(true);
        var cancel = false;
        // Make an async call to get tours
        TAG.Worktop.Database.getTours(function (result) {
            if (cancel) return;
            sortAZ(result);

            $.each(result, function (i, val) {
                if (cancel) return false;
                // Add each label as a separate function to the queue so the UI doesn&#x27;t lock up
                leftQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                        return;
                    }
                    var label;
                    if (!prevSelectedLeftLabel &amp;&amp;
                        ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                        // Select the first one
                        leftLoading.before(selectLabel(label = createLeftLabel(val.Name, null, function () {
                            loadTour(val);
                        }, val.Identifier, false, function () {
                            editTour(val);
                        }), true));

                        // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                        if (leftbar.scrollTop() === 0 &amp;&amp; label.offset().top - leftbar.height() &gt; 0) {
                            leftbar.animate({
                                scrollTop: (label.offset().top - leftbar.height())
                            }, 1000);
                        }

                        prevSelectedLeftLabel = label;
                        loadTour(val);
                    } else {
                        leftLoading.before(label = createLeftLabel(val.Name, null, function () {
                            loadTour(val);
                        }, val.Identifier, false, function () {
                            editTour(val);
                        }));
                    }
                    // Hide if it doesn&#x27;t match search criteria
                    if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                        label.hide();
                    }
                });
            });
            // Hide the loading label when we&#x27;re done
            leftQueue.add(function () {
                leftLoading.hide();
            });
        });
        cancelLastSetting = function () { cancel = true; };
    }

    /**Load a tour to the right side
     * @method loadTour
     * @param {Object} tour     tour to load
     */
    function loadTour(tour) {
        prepareViewer(true);
        clearRight();

        // Create an img element just to load the image
        var img = $(document.createElement(&#x27;img&#x27;));
        img.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(tour.Metadata.Thumbnail));

        // Create a progress circle
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;30%&#x27;,
            &#x27;top&#x27;: &#x27;22%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: viewer.height() / 2 + &#x27;px&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;
        };
        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
        var selectedLabel = prevSelectedLeftLabel;
        img.load(function () {
            // If the selection has changed since we started loading return
            if (prevSelectedLeftLabel &amp;&amp; prevSelectedLeftLabel.text() !== tour.Name) {
                TAG.Util.removeProgressCircle(circle);
                return;
            }
            TAG.Util.removeProgressCircle(circle);
            // Set the image as a background image, centered and contained
            viewer.css(&#x27;background&#x27;, &#x27;black url(&#x27; + TAG.Worktop.Database.fixPath(tour.Metadata.Thumbnail) + &#x27;) no-repeat center / contain&#x27;);
        });

        // Create inputs
        // inputs
        var privateState;
        if (tour.Metadata.Private) {
            privateState = (/^true$/i).test(tour.Metadata.Private);
        } else {
            privateState = false;
        }
        var privateInput = createButton(&#x27;Unpublish&#x27;, function () {
            privateState = true;
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            publicInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;margin-right&#x27;: &#x27;4%&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        privateInput.attr(&#x27;class&#x27;,&#x27;settingButton&#x27;);
        var publicInput = createButton(&#x27;Publish&#x27;, function () {
            privateState = false;
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            privateInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        publicInput.attr(&#x27;class&#x27;,&#x27;settingButton&#x27;);
        if (privateState) {
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        } else {
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        }
        var pubPrivDiv = $(document.createElement(&#x27;div&#x27;));
        pubPrivDiv.append(privateInput).append(publicInput);

        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(tour.Name), true, 120);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(tour.Metadata.Description).replace(/\n/g,&#x27;&lt;br /&gt;&#x27;) || &quot;&quot;, false);

        nameInput.focus(function () {
            if (nameInput.val() === &#x27;Untitled Tour&#x27;)
                nameInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === &#x27;Tour Description&#x27;)
                descInput.select();
        });

        // on change behavior
        onChangeUpdateText(descInput, null, 1500); // What should max length be?

        var privateSetting = createSetting(&#x27;Change Publish Setting&#x27;, pubPrivDiv);
        var name = createSetting(&#x27;Tour Name&#x27;, nameInput);
        var desc = createSetting(&#x27;Tour Description&#x27;, descInput);

        settingsContainer.append(privateSetting);
        settingsContainer.append(name);
        settingsContainer.append(desc);


        // Create buttons
        var editButton = createButton(&#x27;Edit Tour&#x27;,
            function () { editTour(tour); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var deleteButton = createButton(&#x27;Delete Tour&#x27;,
            function () { deleteTour(tour); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var duplicateButton = createButton(&#x27;Duplicate Tour&#x27;,
            function () {
                duplicateTour(tour, {
                    privateInput: privateState,
                    nameInput: nameInput,
                    descInput: descInput,
                });
            },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var saveButton = createButton(&#x27;Save Changes&#x27;,
            function () {
                if (nameInput.val() === undefined || nameInput.val() === &quot;&quot;) {
                    nameInput.val(&quot;Untitled Tour&quot;);
                }
                saveTour(tour, {
                    privateInput: privateState,
                    nameInput: nameInput,
                    descInput: descInput,
                });
            }, {
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
                &#x27;float&#x27;: &#x27;right&#x27;
            });

        buttonContainer.append(editButton).append(duplicateButton).append(deleteButton).append(saveButton);
    }

    /** Create a tour
     * @method createTour
     */
    function createTour() {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.createTour(null, function (newDoq) {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            if (!newDoq) {
                // TODO: ERROR
                loadTourView();
                return;
            }
            loadTourView(newDoq.Identifier);
        }, authError, error(loadTourView), true);
    }

    /**Edit a tour
     * @method editTour
     * @param {Object} tour     tour to edit
     */
    function editTour(tour) {
        // Overlay doesn&#x27;t spin... not sure how to fix without redoing tour authoring to be more async
        loadingOverlay(&#x27;Loading Tour...&#x27;);
        leftQueue.clear();
        rightQueue.clear();
        setTimeout(function () {
            var toureditor = new TAG.Layout.TourAuthoringNew(tour, function () {
                TAG.Util.UI.slidePageLeft(toureditor.getRoot());
            });
        }, 1);
    }

    /**Delete a tour
     * @method deleteTour
     * @param {Object} tour     tour to delete
     */
    function deleteTour(tour) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the tour
            TAG.Worktop.Database.deleteDoq(tour.Identifier, function () {
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                    return;
                }
                loadTourView();
            }, authError, conflict(tour, &quot;Delete&quot;, loadTourView), error(loadTourView));
        }, &quot;Are you sure you want to delete &quot; + tour.Name + &quot;?&quot;, &quot;Delete&quot;, true, function () { $(confirmationBox).hide(); });
        root.append(confirmationBox);
        $(confirmationBox).show();
    }

    /**Duplicate a tour
     * @method duplicateTour
     * @param {Object} tour     tour to duplicate
     * @param {Object} inputs   keys for name, description, and privateInput of tour
     */
    function duplicateTour(tour, inputs) {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);
        var options = {
            Name: &quot;Copy: &quot; + tour.Name,
            Description: tour.Metadata.Description,
            Content: tour.Metadata.Content,
            Thumbnail: tour.Metadata.Thumbnail,
            Private: &quot;true&quot;, // always want to create duplicates as unpublished
        };

        TAG.Worktop.Database.createTour(options, function (tewer) {
            console.log(&quot;success&quot;);
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            loadTourView(tewer.Identifier);
        }, function () {
            console.log(&quot;error&quot;);
        }, function () {
            console.log(&quot;cacheError&quot;);
        });
    }

    /**Save a tour
     * @method saveTour
     * @param {Object} tour     tour to save
     * @param {Object} inputs   keys for name, description, and privateInput of tour
     */
    function saveTour(tour, inputs) {
        var name = inputs.nameInput.val();
        var desc = inputs.descInput.val();

        if (name.indexOf(&#x27; &#x27;) === 0) {
            var messageBox = TAG.Util.UI.popUpMessage(null, &quot;Tour Name cannot start with a space.&quot;, null, true);
            $(root).append(messageBox);
            $(messageBox).show();
            return;
        }

        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.changeTour(tour.Identifier, {
            Name: name,
            Description: desc,
            Private: inputs.privateInput,
        }, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            loadTourView(tour.Identifier);
        }, authError, conflict(tour, &quot;Update&quot;, loadTourView), error(loadTourView));
    }

    // Associated Media functions:

    /**Load Associated Media view
     * @method load AssocMediaView
     * @param {Object} id   id of left label to start on
     */
    function loadAssocMediaView(id) {
        prepareNextView(true, &quot;Import&quot;, createAsset);
        prepareViewer(true);
        clearRight();
        var cancel = false;

        // Make an async call to get artworks
        TAG.Worktop.Database.getAssocMedia(function (result) {
            if (cancel) return;
            sortAZ(result);
            console.log(&#x27;media in hand&#x27;);
            if (result[0] &amp;&amp; result[0].Metadata) {
                $.each(result, function (i, val) {
                    if (cancel) return;
                    // Add each label in a separate function in the queue so the UI doesn&#x27;t lock up
                    leftQueue.add(function () {
                        if (cancel) return;
                        if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.media.text]) {
                            return;
                        }
                        var label;
                        var imagesrc;
                        switch (val.Metadata.ContentType.toLowerCase()) {
                            case &#x27;video&#x27;:
                                imagesrc = (val.Metadata.Thumbnail &amp;&amp; !val.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : &#x27;images/video_icon.svg&#x27;;
                                break;
                            case &#x27;audio&#x27;:
                                imagesrc = &#x27;images/audio_icon.svg&#x27;;
                                break;
                            case &#x27;image&#x27;:
                                imagesrc = val.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : &#x27;images/image_icon.svg&#x27;;
                                break;
                            default:
                                imagesrc = null;
                                break;
                        }
                        if (!prevSelectedLeftLabel &amp;&amp;
                            ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                            // Select the first one
                            leftLoading.before(selectLabel(label = createLeftLabel(val.Name, imagesrc, function () {
                                loadAssocMedia(val);
                            }, val.Identifier, false), true));

                            // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                            if (leftbar.scrollTop() === 0 &amp;&amp; label.offset().top - leftbar.height() &gt; 0) {
                                leftbar.animate({
                                    scrollTop: (label.offset().top - leftbar.height())
                                }, 1000);
                            }

                            prevSelectedLeftLabel = label;
                            loadAssocMedia(val);
                        } else {
                            leftLoading.before(label = createLeftLabel(val.Name, imagesrc, function () {
                                loadAssocMedia(val);
                            }, val.Identifier, false));
                        }
                        // Hide if it doesn&#x27;t match search criteria
                        if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                            label.hide();
                        }
                    });
                });
                // Hide the loading label when we&#x27;re done
                leftQueue.add(function () {
                    leftLoading.hide();
                });
            } else {
                leftLoading.hide();
            }
        });
        cancelLastSetting = function () { cancel = true; };
    }
    
    /**Loads associated media to the right side
     * @method loadAssocMedia
     * @param {Object} media    associated media to load
     */
    function loadAssocMedia(media) {
        prepareViewer(true);
        clearRight();

        // Create an img element to load the image
        var type = media.Metadata.ContentType.toLowerCase();
        var holder;
        var source = TAG.Worktop.Database.fixPath(media.Metadata.Source);
        switch (type) {
            case &quot;image&quot;:
                holder = $(document.createElement(&#x27;img&#x27;));
                break;
            case &quot;video&quot;:
                holder = $(document.createElement(&#x27;video&#x27;));
                holder.attr(&#x27;id&#x27;, &#x27;videoInPreview&#x27;);
                holder.attr(&#x27;poster&#x27;, (media.Metadata.Thumbnail &amp;&amp; !media.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(media.Metadata.Thumbnail) : &#x27;&#x27;);
                holder.attr(&#x27;identifier&#x27;, media.Identifier);
                holder.attr(&quot;preload&quot;, &quot;none&quot;);
                holder.attr(&quot;controls&quot;, &quot;&quot;);
                holder.css({ &quot;width&quot;: &quot;100%&quot;, &quot;max-width&quot;: &quot;100%&quot;, &quot;max-height&quot;: &quot;100%&quot; });
                holder[0].onerror = TAG.Util.videoErrorHandler(holder, viewer);
                break;
            case &quot;audio&quot;:
                holder = $(document.createElement(&#x27;audio&#x27;));
                holder.attr(&quot;preload&quot;, &quot;none&quot;);
                holder.attr(&quot;controls&quot;, &quot;&quot;);
                holder.css({ &#x27;width&#x27;: &#x27;80%&#x27; });
                break;
            case &quot;text&quot;:
            default:
                holder = $(document.createElement(&#x27;div&#x27;));
                holder.css({
                    &quot;font-size&quot;: &quot;24px&quot;,
                    &quot;top&quot;: &quot;20%&quot;,
                    &quot;width&quot;: &quot;80%&quot;,
                    //&quot;margin-left&quot;: &quot;10%&quot;,
                    &quot;text-align&quot;: &quot;center&quot;,
                    &quot;color&quot;: &quot;white&quot;
                });
                holder.html(media.Name + &quot;&lt;br /&gt;&lt;br /&gt;&quot; + media.Metadata.Description);
                break;
        }
        (source &amp;&amp; type !== &#x27;text&#x27;) &amp;&amp; holder.attr(&#x27;src&#x27;, source);

        // Create a progress circle
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;40%&#x27;,
            &#x27;top&#x27;: &#x27;40%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;
        };
        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
        var selectedLabel = prevSelectedLeftLabel;

        switch (type) {
            case &quot;image&quot;:
                holder.load(function () {
                    // If the selection has changed since we started loading then return
                    if (prevSelectedLeftLabel &amp;&amp; prevSelectedLeftLabel.text() !== media.Name) {
                        TAG.Util.removeProgressCircle(circle);
                        return;
                    }
                    TAG.Util.removeProgressCircle(circle);
                    // Set the image as a background image
                    viewer.css(&#x27;background&#x27;, &#x27;black url(&#x27; + source + &#x27;) no-repeat center / contain&#x27;);
                });
                break;
            case &quot;video&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                viewer.append(holder);
                break;
            case &quot;audio&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                //center the the audio element in the viewer
                viewer.append(holder);
                var left = viewer.width() / 2 - holder.width() / 2 + &quot;px&quot;;
                var top = viewer.height() /2 - holder.height() /2 + &quot;px&quot;;
                holder.css({ &quot;position&quot;: &quot;absolute&quot;, &quot;left&quot;: left, &quot;top&quot; : top });
                break;
            case &quot;text&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css({ &#x27;background&#x27;: &#x27;black&#x27;});
                viewer.append(holder);
                var left = viewer.width() / 2 - holder.width() / 2 + &quot;px&quot;;
                var top = viewer.height() / 2 - holder.height() / 2 + &quot;px&quot;;
                holder.css({ &quot;position&quot;: &quot;absolute&quot;, &quot;left&quot;: left, &quot;top&quot;: top });
                break;
            default:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                break;
        }

        // Create labels
        var titleInput = createTextInput(TAG.Util.htmlEntityDecode(media.Name) || &quot;&quot;, true, 55);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(media.Metadata.Description).replace(/\n/g,&#x27;&lt;br /&gt;&#x27;) || &quot;&quot;, true);

        titleInput.focus(function () {
            if (titleInput.val() === &#x27;Title&#x27;)
                titleInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === &#x27;Description&#x27;)
                descInput.select();
        });

        var title = createSetting(&#x27;Title&#x27;, titleInput);
        var desc = createSetting(&#x27;Description&#x27;, descInput);

        settingsContainer.append(title);
        settingsContainer.append(desc);

        // Create buttons
        var assocButton = createButton(&#x27;Associate to Artworks&#x27;,
            function () { assocToArtworks(media); },
            {
                &#x27;float&#x27;: &#x27;left&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var deleteButton = createButton(&#x27;Delete&#x27;,
            function () {
                var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                    prepareNextView(false);
                    clearRight();
                    prepareViewer(true);

                    // stupid way to force associated artworks to increment their linq counts and refresh their lists of media
                    TAG.Worktop.Database.changeHotspot(media.Identifier, { Name: media.Name }, function () {
                        // success handler
                        TAG.Worktop.Database.deleteDoq(media.Identifier, function () {
                            console.log(&quot;deleted&quot;);
                            loadAssocMediaView();
                        }, function () {
                            console.log(&quot;noauth error&quot;);
                        }, function () {
                            console.log(&quot;conflict error&quot;);
                        }, function () {
                            console.log(&quot;general error&quot;);
                        });
                    }, function () {
                        // unauth handler
                    }, function () {
                        // conflict handler
                    }, function () {
                        // error handler
                    });
                }, &quot;Are you sure you want to delete &quot; + media.Name + &quot;?&quot;, &quot;Delete&quot;, true, function () { $(confirmationBox).hide(); });
                root.append(confirmationBox);
                $(confirmationBox).show();
                 },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;,
            });

        var generateAssocMediaThumbnailButton = createButton(&#x27;Generate Thumbnail&#x27;,
            function () {
                generateAssocMediaThumbnail(media);
            }, {
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;
            });

        var saveButton = createButton(&#x27;Save Changes&#x27;,
            function () {
                if (titleInput.val() === undefined || titleInput.val() === &quot;&quot;) {
                    titleInput.val(&quot;Untitled Asset&quot;);
                }
                saveAssocMedia(media, {
                    titleInput: titleInput,
                    descInput: descInput
                });
            }, {
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
                &#x27;float&#x27;: &#x27;right&#x27;
            });

        var thumbnailButton = createButton(&#x27;Capture Thumbnail&#x27;,
            function () {
                saveThumbnail(media, false);
            }, {
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;
            });

        buttonContainer.append(assocButton);
        if (media.Metadata.ContentType.toLowerCase() === &#x27;video&#x27;) {
            buttonContainer.append(thumbnailButton);
        } else if (media.Metadata.ContentType.toLowerCase() === &#x27;image&#x27; &amp;&amp; !media.Metadata.Thumbnail &amp;&amp; media.Metadata.Source[0] === &#x27;/&#x27; &amp;&amp; !source.match(/.mp3/)) {
            // hacky way to see if asset was imported recently enough to support thumbnailing (these are /Images/_____.__
            // rather than http:// _______/Images/_______.__
            buttonContainer.append(generateAssocMediaThumbnailButton);
        }
        buttonContainer.append(deleteButton).append(saveButton);
    }

    /**Save an associated media
     * @method saveAssocMedia
     * @param {Object} media    associated media to save
     * @param {Object} inputs   keys for media title and description
     */
    function saveAssocMedia(media, inputs) {
        var name = inputs.titleInput.val();
        var desc = inputs.descInput.val();

        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.changeHotspot(media, {
            Name: name,
            Description: desc,
        }, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.media.text]) {
                return;
            }
            loadAssocMediaView(media.Identifier);
        }, authError, conflict(media, &quot;Update&quot;, loadAssocMediaView), error(loadAssocMediaView));
    }

    /**Brings up an artwork chooser for a particular associated media
     * @method assocToArtworks
     * @param {Object} media    media to associate to artworks
     */
    function assocToArtworks(media) {
        artworkAssociations = [[]];
        numFiles = 1;
        TAG.Util.UI.createAssociationPicker(root, &quot;Choose artworks&quot;, { comp: media, type: &#x27;media&#x27; }, &quot;artwork&quot;, [{
            name: &quot;All Artworks&quot;,
            getObjs: TAG.Worktop.Database.getArtworks
        }], {
            getObjs: TAG.Worktop.Database.getArtworksAssocTo,
            args: [media.Identifier]
        }, function () { });
    }

    /**Generate thumbnail for associated media
     * @method generateAssocMediaThumbnail
     * @param {Object} media        media to generate thumbnail for
     */
    function generateAssocMediaThumbnail(media) {
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.changeHotspot(media.Identifier, { Thumbnail: &#x27;generate&#x27; }, function () {
            console.log(&#x27;success?&#x27;);
            loadAssocMediaView(media.Identifier);
        }, unauth, conflict, error);
    }

    /**
     * @method createAsset
     */
    function createAsset() {
        uploadFile(TAG.Authoring.FileUploadTypes.AssociatedMedia, function (urls, names, contentTypes, files) {
            var check, i, url, name, done = 0, total = urls.length, durations = [];
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            if(files.length &gt; 0) {
                durationHelper(0);
            }

            function durationHelper(j) {
                if (contentTypes[j] === &#x27;Video&#x27;) {
                    files[j].properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        durations.push(VideoProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (err) {
                        console.log(err);
                    });
                } else if (contentTypes[j] === &#x27;Audio&#x27;) {
                    files[j].properties.getMusicPropertiesAsync().done(function (MusicProperties) {
                        durations.push(MusicProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (error) {
                        console.log(error);
                    });
                } else {
                    durations.push(null);
                    updateDoq(j);
                }
            }

            function incrDone() {
                done++;
                if (done &gt;= total) {
                    loadAssocMediaView();
                } else {
                    durationHelper(done);
                }
            }

            function updateDoq(j) {
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[j]);
                    var options = {Name: names[j]};
                    if (durations[j]) {
                        options.Duration = durations[j];
                    }
                    TAG.Worktop.Database.changeHotspot(newDoq.Identifier, options, incrDone, TAG.Util.multiFnHandler(authError, incrDone), TAG.Util.multiFnHandler(conflict(newDoq, &quot;Update&quot;, incrDone)), error(incrDone));
                } catch (error) {
                    done++;
                    console.log(&quot;error in uploading: &quot; + error.message);
                    return;
                }
            }
        }, true, [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.mp4&#x27;, &#x27;.mp3&#x27;]);
    }

    /**Create an associated media (import), possibly more than one
     * @method createMedia
     */
    function createMedia() {
        batchAssMedia();
    }

    /**
     * @method batchAssMedia
     */
    function batchAssMedia() {
        var uniqueUrls = []; // Used to make sure we don&#x27;t override data for the wrong media (not actually airtight but w/e)
        mediaMetadata = [];
        artworkAssociations = [];
        numFiles = 0;
        isUploading = true;
        assetUploader = TAG.Authoring.FileUploader( // multi-file upload now
            root,
            TAG.Authoring.FileUploadTypes.AssociatedMedia,
            function (files, localURLs) { // localCallback
                var file, localURL, i;
                var img, video, audio;
                var contentType;
                numFiles = files.length;
                for (i = 0; i &lt; files.length; i++) {
                    artworkAssociations.push([]);
                    file = files[i];
                    localURL = localURLs[i];
                    if (file.contentType.match(/image/)) {
                        contentType = &#x27;Image&#x27;;
                    } else if (file.contentType.match(/video/)) {
                        contentType = &#x27;Video&#x27;;
                    } else if (file.contentType.match(/audio/)) {
                        contentType = &#x27;Audio&#x27;;
                    }
                    uniqueUrls.push(localURL);
                    mediaMetadata.push({
                        &#x27;title&#x27;: file.displayName,
                        &#x27;contentType&#x27;: contentType,
                        &#x27;localUrl&#x27;: localURL,
                        &#x27;assetType&#x27;: &#x27;Asset&#x27;,
                        &#x27;assetLinqID&#x27;: undefined,
                        &#x27;assetDoqID&#x27;: undefined
                    });
                }
            },
            function (dataReaderLoads) { // finished callback: set proper contentUrls, if not first, save it
                var i, dataReaderLoad;
                for (i = 0; i &lt; dataReaderLoads.length; i++) {
                    dataReaderLoad = dataReaderLoads[i];
                    mediaMetadata[i].contentUrl = dataReaderLoad;
                }

                // chooseAssociatedArtworks(); // need to send in media objects here TODO
            },
            [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.mp4&#x27;, &#x27;.mp3&#x27;], // filters
            false, // useThumbnail
            null, // errorCallback
            true // multiple file upload enabled?
        );
    }

    /**
     * @method saveAssMedia
     * @param i the index of the asset 
     */
    function saveAssMedia(i) {
        var len = artworkAssociations[i].length;
        uploadHotspotHelper(i, 0, len);
    }

    /**
     * Uploads hotspot i to artwork j in its list of artworks to associate to.
     * @method uploadHotspotHelper
     * @param i    the index of the asset we&#x27;re uploading
     * @param j    each asset has a list of artworks it&#x27;ll be associated with; j is the index in this list
     * @param len  the length of the list above
     */
    function uploadHotspotHelper(i, j, len) {
        // uploads hotspot hotspot i to artwork j in its list
        var activeMM = mediaMetadata[i];
        uploadHotspot(artworkAssociations[i][j], { // this info isn&#x27;t changing, so maybe we can do this more easily in uploadHotspot
            title: TAG.Util.encodeXML(activeMM.title || &#x27;Untitled media&#x27;),
            desc: TAG.Util.encodeXML(&#x27;&#x27;),
            pos: null, // bogus entry for now -- should set it to {x: 0, y: 0} in uploadHotspot
            contentType: activeMM.contentType,
            contentUrl: activeMM.contentUrl,
            assetType: activeMM.assetType,
            metadata: {
                assetLinqID: activeMM.assetLinqID,
                assetDoqID: activeMM.assetDoqID
            }
        },
        i, j, len);
    }

    /**
     * @method uploadHotspot
     * @param artwork
     * @param info
     * @param i
     * @param j
     * @param len
     */
    function uploadHotspot(artwork, info, i, j, len) {
        var title = info.title,
            desc = info.desc,
            pixel = info.pos,
            contentType = info.contentType,
            contentUrl = info.contentUrl,
            assetType = info.assetType,
            worktopInfo = info.metadata || {},
            dzPos = pixel ? zoomimage.viewer.viewport.pointFromPixel(pixel) : { x: 0, y: 0 },
            rightbarLoadingSave;

        var options = {
            Name: title,
            ContentType: contentType,
            Duration: duration,
            Source: contentUrl,
            LinqTo: artwork.Identifier,
            X: dzPos.x,
            Y: dzPos.y,
            LinqType: assetType,
            Description: desc
        };

        TAG.Worktop.Database.createHotspot(artwork.CreatorID, artwork.Identifier, createHotspotHelper);

        /**
         * @method createHotspotHelper
         * @param isNewAsset
         * @param xmlHotspot
         */
        function createHotspotHelper(isNewAsset, xmlHotspot) { // currently for creating both hotspots and assoc media
            var $xmlHotspot,
                hotspotId,
                hotspotContentId,
                hotspotContentDoq,
                $hotspotContentDoq,
                titleField,
                metadata,
                descField,
                contentTypeField,
                sourceField,
                position;
            $xmlHotspot = $(xmlHotspot);
            hotspotId = $xmlHotspot.find(&quot;Identifier&quot;).text();
            hotspotContentId = $xmlHotspot.find(&quot;BubbleContentID:last&quot;).text();
            hotspotContentDoq = $.parseXML(TAG.Worktop.Database.getDoqXML(hotspotContentId));
            $hotspotContentDoq = $(hotspotContentDoq);
            // update doq info and send back to server
            titleField = $hotspotContentDoq.find(&#x27;Name&#x27;).text(title);
            metadata = $hotspotContentDoq.find(&#x27;Metadata&#x27;);
            descField = metadata.find(&quot;d3p1\\:Key:contains(&#x27;Description&#x27;) + d3p1\\:Value&quot;).text(desc);
            contentTypeField = metadata.find(&quot;d3p1\\:Key:contains(&#x27;ContentType&#x27;) + d3p1\\:Value&quot;).text(contentType);
            sourceField = metadata.find(&quot;d3p1\\:Key:contains(&#x27;Source&#x27;) + d3p1\\:Value&quot;).text(contentUrl);
            position = $xmlHotspot.find(&#x27;Offset &gt; d2p1\\:_x&#x27;).text(dzPos.x); // why is position getting reset?
            position = $xmlHotspot.find(&#x27;Offset &gt; d2p1\\:_y&#x27;).text(dzPos.y);
            //add linq type : Hotspot vs. Asset
            $xmlHotspot.find(&quot;d3p1\\:Key:contains(&#x27;Type&#x27;) + d3p1\\:Value&quot;).text(assetType);
            TAG.Worktop.Database.pushLinq(xmlHotspot, hotspotId);
            TAG.Worktop.Database.pushXML(hotspotContentDoq, hotspotContentId);
            if (j &lt; len - 1) {
                uploadHotspotHelper(i, j + 1, len);
            }
            else if (j === len - 1 &amp;&amp; i &lt; numFiles - 1) {
                saveAssMedia(i + 1);
            }
            else {
                isUploading = false;
                isCreatingMedia = false;
                //$topProgressDiv.css(&quot;visibility&quot;, &quot;hidden&quot;);
            }
        }
    }

    // Art Functions:

    /**Loads art view
     * @method loadArtView
     * @param {Object} id   id of left label to start on
     */
    function loadArtView(id) {
        prepareNextView(true, &quot;Import&quot;, createArtwork);
        prepareViewer(true);
        clearRight();
        var cancel = false;

        // Make an async call to get artworks
        TAG.Worktop.Database.getArtworks(function (result) {
            if (cancel) return;
            sortAZ(result);
            if (result[0] &amp;&amp; result[0].Metadata) {
                $.each(result, function (i, val) {
                    if (cancel) return;
                    // Add each label in a separate function in the queue
                    // so the UI doesn&#x27;t lock up
                    val.Name = TAG.Util.htmlEntityDecode(val.Name);
                    leftQueue.add(function () {
                        if (cancel) return;
                        if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                            return;
                        }
                        var label;
                        var imagesrc;
                        switch (val.Metadata.Type) {
                            case &#x27;Artwork&#x27;:
                                imagesrc = TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail);
                                break;
                            case &#x27;VideoArtwork&#x27;:
                                imagesrc = val.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : &quot;images/video_icon.svg&quot;;
                                break
                            default:
                                imagesrc = null;
                        }
                        if (!prevSelectedLeftLabel &amp;&amp;
                            ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                            // Select the first one
                            leftLoading.before(selectLabel(label = createLeftLabel(val.Name, imagesrc, function () {
                                loadArtwork(val);
                            }, val.Identifier, false, function () {
                                editArtwork(val);
                            }, true, val.Extension), true));

                            // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                            if (leftbar.scrollTop() === 0 &amp;&amp; label.offset().top - leftbar.height() &gt; 0) {
                                leftbar.animate({
                                    scrollTop: (label.offset().top - leftbar.height())
                                }, 1000);
                            }

                            prevSelectedLeftLabel = label;
                            loadArtwork(val);
                        } else {
                            leftLoading.before(label = createLeftLabel(val.Name, imagesrc, function () {
                                loadArtwork(val);
                            }, val.Identifier, false, function () {
                                editArtwork(val);
                            }, true, val.Extension));
                        }
                        // Hide if it doesn&#x27;t match search criteria
                        if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                            label.hide();
                        }
                    });
                });
                // Hide the loading label when we&#x27;re done
                leftQueue.add(function () {
                    leftLoading.hide();
                });
            } else {
                leftLoading.hide();
            }
        });

        cancelLastSetting = function () { cancel = true; };
    }

    /**Loads an artwork to the right side
     * @method loadArtwork
     * @param {Object} artwork  artwork to load
     */
    function loadArtwork(artwork) {
        prepareViewer(true);
        clearRight();

        // Create an img element to load the image
        var mediaElement;
        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            mediaElement = $(document.createElement(&#x27;img&#x27;));
            mediaElement.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(artwork.URL));
        } else {
            mediaElement = $(document.createElement(&#x27;video&#x27;));
            mediaElement.attr(&#x27;id&#x27;, &#x27;videoInPreview&#x27;);
            mediaElement.attr(&#x27;poster&#x27;, (artwork.Metadata.Thumbnail &amp;&amp; !artwork.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail) : &#x27;&#x27;);
            mediaElement.attr(&#x27;identifier&#x27;, artwork.Identifier);
            mediaElement.attr(&quot;preload&quot;, &quot;none&quot;);
            mediaElement.attr(&quot;controls&quot;, &quot;&quot;);
            mediaElement.css({ &quot;width&quot;: &quot;100%&quot;, &quot;max-width&quot;: &quot;100%&quot;, &quot;max-height&quot;: &quot;100%&quot; });
            mediaElement.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(artwork.Metadata.Source));
            mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer);
        }

        // Create a progress circle
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;40%&#x27;,
            &#x27;top&#x27;: &#x27;40%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;
        };
        var circle;
        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
        }
        var selectedLabel = prevSelectedLeftLabel;

        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            mediaElement.load(function () {
                // If the selection has changed since we started loading then return
                if (prevSelectedLeftLabel &amp;&amp; prevSelectedLeftLabel.text() !== artwork.Name) {
                    TAG.Util.removeProgressCircle(circle);
                    return;
                }
                TAG.Util.removeProgressCircle(circle);
                // Set the image as a background image
                viewer.css(&#x27;background&#x27;, &#x27;black url(&#x27; + TAG.Worktop.Database.fixPath(artwork.URL) + &#x27;) no-repeat center / contain&#x27;);
            });
        } else {
            viewer.append(mediaElement);
        }
        var titleInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Name), true, 55);
        var artistInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Artist), true, 55);
        var yearInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Year), true, 20);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Description).replace(/\n/g, &#x27;&lt;br /&gt;&#x27;) || &quot;&quot;, &quot;&quot;, false);
        var customInputs = {};
        var customSettings = {};

        if (artwork.Metadata.InfoFields) {
            $.each(artwork.Metadata.InfoFields, function (key, val) {
                customInputs[key] = createTextInput(TAG.Util.htmlEntityDecode(val), true);
                customSettings[key] = createSetting(key, customInputs[key]);
            });
        }

        titleInput.focus(function () {
            if (titleInput.val() === &#x27;Title&#x27;)
                titleInput.select();
        });
        artistInput.focus(function () {
            if (artistInput.val() === &#x27;Artist&#x27;)
                artistInput.select();
        });
        yearInput.focus(function () {
            if (yearInput.val() === &#x27;Year&#x27;)
                yearInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === &#x27;Description&#x27;)
                descInput.select();
        });

        var title = createSetting(&#x27;Title&#x27;, titleInput);
        var artist = createSetting(&#x27;Artist&#x27;, artistInput);
        var year = createSetting(&#x27;Year&#x27;, yearInput);
        var desc = createSetting(&#x27;Description&#x27;, descInput);

        settingsContainer.append(title);
        settingsContainer.append(artist);
        settingsContainer.append(year);
        settingsContainer.append(desc);

        $.each(customSettings, function (key, val) {
            settingsContainer.append(val);
        });

        // Create buttons
        editArt = createButton(&#x27;Enter Artwork Editor&#x27;,
            function () { editArtwork(artwork); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        editArt.attr(&quot;id&quot;, &quot;artworkEditorButton&quot;);
        var deleteArt = createButton(&#x27;Delete Artwork&#x27;,
            function () { deleteArtwork(artwork); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var saveButton = createButton(&#x27;Save Changes&#x27;,
            function () {
                if (titleInput.val() === undefined || titleInput.val() === &quot;&quot;) {
                    titleInput.val(&quot;Untitled Artwork&quot;);
                }
                saveArtwork(artwork, {
                    artistInput: artistInput,   //Artwork artist
                    nameInput: titleInput,      //Artwork title
                    yearInput: yearInput,       //Artwork year
                    descInput: descInput,       //Artwork description
                    customInputs: customInputs, //Artwork custom info fields
                });
            }, {
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
                &#x27;float&#x27;: &#x27;right&#x27;
            });

        var thumbnailButton = createButton(&#x27;Capture Thumbnail&#x27;,
            function () {
                saveThumbnail(artwork, true);
            }, {
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;
            });
        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            buttonContainer.append(editArt).append(deleteArt).append(saveButton);
        } else {
            buttonContainer.append(thumbnailButton).append(deleteArt).append(saveButton);
        }
    }

    /**Save Thumbnail image 
     * @method saveThumbnail
     * @param {Object} component
     * @param {Boolean} isArtwork
     */
    function saveThumbnail(component, isArtwork) {
        var id = $(&#x27;#videoInPreview&#x27;).attr(&#x27;identifier&#x27;);
        var pop = Popcorn(&#x27;#videoInPreview&#x27;);
        var time = $(&#x27;#videoInPreview&#x27;)[0].currentTime;
        var dataurl = pop.capture({ type: &#x27;jpg&#x27; }); // modified popcorn.capture a bit to
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.uploadImage(dataurl, function (imageURL) {
            if (isArtwork) {
                TAG.Worktop.Database.changeArtwork(id, { Thumbnail: imageURL }, function () {
                    console.log(&quot;success?&quot;);
                    loadArtView(component.Identifier);
                }, unauth, conflict, error);
            
            } else { // here, it must be a video assoc media
                TAG.Worktop.Database.changeHotspot(id, { Thumbnail: imageURL }, function () {
                    console.log(&quot;success?&quot;);
                    loadAssocMediaView(component.Identifier);
                }, unauth, conflict, error);
            }
        }, unauth, error);
    }

    function unauth() {
        dialogOverlay.hide();
        var popup = TAG.Util.UI.popUpMessage(null, &quot;Thumbnail not saved.  You must log in to save changes.&quot;);
        $(&#x27;body&#x27;).append(popup);
        $(popup).show();
    }

    function conflict(jqXHR, ajaxCall) {
        ajaxCall.force();
    }

    function error() {
        dialogOverlay.hide();
        var popup = TAG.Util.UI.popUpMessage(null, &quot;Thumbnail not saved.  There was an error contacting the server.&quot;);
        $(&#x27;body&#x27;).append(popup);
        $(popup).show();
    }

    /**Create an artwork (import), possibly more than one
     * @method createArtwork
     */
    function createArtwork() {
        uploadFile(TAG.Authoring.FileUploadTypes.DeepZoom, function (urls, names, contentTypes, files) {
            var check, i, url, name, done=0, total=urls.length, durations=[];
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            function incrDone() {
                done++;
                if (done &gt;= total) {
                    loadArtView();
                } else {
                    durationHelper(done);
                }
            }

            if (files.length &gt; 0) {
                durationHelper(0);
            }

            function durationHelper(j) {
                if (contentTypes[j] === &#x27;Video&#x27;) {
                    files[j].properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        durations.push(VideoProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (err) {
                        console.log(err);
                    });
                } else {
                    durations.push(null);
                    updateDoq(j);
                }
            }

            function updateDoq(j) {
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[j]);
                } catch (error) {
                    done++;
                    console.log(&quot;error in uploading: &quot; + error.message);
                    return;
                }
                var ops = { Name: names[j] };
                if (durations[j]) {
                    ops.Duration = durations[j];
                }
                TAG.Worktop.Database.changeArtwork(newDoq.Identifier, ops, incrDone, TAG.Util.multiFnHandler(authError, incrDone), TAG.Util.multiFnHandler(conflict(newDoq, &quot;Update&quot;, incrDone)), error(incrDone));
            }

        }, true, [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.mp4&#x27;]);
    }

    /**Edit an artwork
     * @method editArtwork
     * @param {Object} artwork   artwork to edit
     */
    function editArtwork(artwork) {
        // Overlay doesn&#x27;t spin... not sure how to fix without redoing tour authoring to be more async
        loadingOverlay(&#x27;Loading Artwork...&#x27;);
        leftQueue.clear();
        rightQueue.clear();
        setTimeout(function () {
            TAG.Util.UI.slidePageLeft((new TAG.Layout.ArtworkEditor(artwork)).getRoot());
        }, 1);
    }

    /**Delete an artwork
     * @method deleteArtwork
     * @param {Object} artwork      artwork to delete
     */
    function deleteArtwork(artwork) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the artwork
            TAG.Worktop.Database.deleteDoq(artwork.Identifier, function () {
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                    return;
                }
                loadArtView();
            }, authError, authError);
        }, &quot;Are you sure you want to delete &quot; + artwork.Name + &quot;?&quot;, &quot;Delete&quot;, true, function () { $(confirmationBox).hide() });
        root.append(confirmationBox);
        $(confirmationBox).show();
    }

    /**Save an artwork
     * @method saveArtwork
     * @param {Object} artwork      artwork to save
     * @param {Object} inputs       keys for artwork info from input fields
     */
    function saveArtwork(artwork, inputs) {
        var name = inputs.nameInput.val();
        var artist = inputs.artistInput.val();
        var year = inputs.yearInput.val();
        var description = inputs.descInput.val();

        var infoFields = {};
        $.each(inputs.customInputs, function (key, val) {
            infoFields[key] = val.val();
        });

        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);
        
        TAG.Worktop.Database.changeArtwork(artwork, {
            Name: name,
            Artist: artist,
            Year: year,
            Description: description,
            InfoFields: JSON.stringify(infoFields),
        }, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                return;
            }
            loadArtView(artwork.Identifier);
        }, authError, conflict(artwork, &quot;Update&quot;, loadArtView), error(loadArtView)); 
    }

    // Feedback Functions:

    /**Loads Feedback view
     * @method loadFeedbackView
     * @param {Object} id   id of left label to start on
     */
    function loadFeedbackView(id) {
        prepareNextView(true, &quot;&quot;);
        prepareViewer(false);
        clearRight();

        var cancel = false;
        // Make an async call to get feedback
        TAG.Worktop.Database.getFeedback(function (result) {
            if (cancel) return;
            sortDate(result);

            $.each(result, function (i, val) {
                if (cancel) return false;
                // Add each label as a separate function to the queue so the UI doesn&#x27;t lock up
                leftQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.feedback.text]) {
                        return;
                    }
                    var label;
                    var text = $.datepicker.formatDate(&#x27;(m/dd/yy) &#x27;, new Date(val.Metadata.Date * 1000)) + val.Metadata.Feedback;
                    if (!prevSelectedLeftLabel &amp;&amp;
                        ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                        // Select the first one
                        leftLoading.before(selectLabel(label = createLeftLabel(text, null, function () {
                            loadFeedback(val);
                        }, val.Identifier, true)));

                        // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                        if (leftbar.scrollTop() === 0 &amp;&amp; label.offset().top - leftbar.height() &gt; 0) {
                            leftbar.animate({
                                scrollTop: (label.offset().top - leftbar.height())
                            }, 1000);
                        }

                        prevSelectedLeftLabel = label;
                        loadFeedback(val);
                    } else {
                        leftLoading.before(label = createLeftLabel(text, null, function () {
                            loadFeedback(val);
                        }, val.Identifier, true));
                    }
                    // Hide if it doesn&#x27;t match search criteria
                    if (!TAG.Util.searchString(text, searchbar.val())) {
                        label.hide();
                    }
                });
            });
            // Hide the loading label when we&#x27;re done
            leftQueue.add(function () {
                leftLoading.hide();
            });
        });
        cancelLastSetting = function () { cancel = true; };
    }

    /** Loads feedback to right side of screen
     * @method loadFeedback
     * @param {Object} feedback     feedback to load
     */
    function loadFeedback(feedback) {
        clearRight();
        prepareViewer(true, feedback.Metadata.Feedback);

        var sourceLabel = createLabel(&#x27;Loading...&#x27;);
        var dateLabel = createLabel($.datepicker.formatDate(&#x27;DD, MM d, yy &#x27;, new Date(feedback.Metadata.Date * 1000)));
        var source = createSetting(&#x27;Submitted From&#x27;, sourceLabel);
        var dateSetting = createSetting(&#x27;Date&#x27;, dateLabel);

        settingsContainer.append(source);
        var sourceType = feedback.Metadata.SourceType === &quot;Exhibition&quot; ? &quot;Collection&quot; : feedback.Metadata.SourceType;
        if (feedback.Metadata.SourceID) {
            getSourceName(feedback, function (sourceName) {
                sourceLabel.text(sourceName + &#x27; (&#x27; + sourceType + &#x27;)&#x27;);
                var sourceButton = createButton(sourceName + &#x27; (&#x27; + sourceType + &#x27;)&#x27;, function () {
                    followSource(feedback);
                });
                var sourceSetting = createSetting(&#x27;Submitted From&#x27;, sourceButton);
                source.remove();
                dateSetting.prepend(sourceSetting);
            }, function (sourceName) {
                sourceLabel.text(sourceName + &#x27; (&#x27; + sourceType + &#x27;, Deleted)&#x27;);
            }, function () {
                sourceLabel.text(&#x27;Deleted&#x27;);
            });
        } else {
            sourceLabel.text(sourceType + &quot; Page (No &quot; + sourceType + &quot; Selected)&quot;);
        }
        settingsContainer.append(dateSetting);

        var deleteButton = createButton(&#x27;Delete Feedback&#x27;, function () {
            deleteFeedback(feedback);
        },
        {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        buttonContainer.append(deleteButton);
    }

    /**Get source of feedback
     * @method getSourceName
     * @param {Object} feedback     feedback to get source of
     * @param {Function} onSuccess  function called if source found
     * @param {Function} onDeleted  function called if source has been deleted
     * @param {Function} onError    function called if there is an error 
     */
    function getSourceName(feedback, onSuccess, onDeleted, onError) {
        TAG.Worktop.Database.getDoq(feedback.Metadata.SourceID,
            function (doq) {
                if (doq.Metadata.Deleted) {
                    onDeleted(doq.Name);
                } else {
                    onSuccess(doq.Name);
                }
            }, function () {
                onError();
            });
    }

    /**Switch view to source of feedback
     * @method followSource
     * @param {Object} feedback     feedback to follow source of
     */
    function followSource(feedback) {
        switch (feedback.Metadata.SourceType) {
            case &quot;Exhibition&quot;:
            case &quot;Exhibitions&quot;:
                switchView(&quot;Exhibitions&quot;, feedback.Metadata.SourceID);
                break;
            case &quot;Tour&quot;:
            case &quot;Tours&quot;:
                switchView(&quot;Tours&quot;, feedback.Metadata.SourceID);
                break;
            case &quot;Art&quot;:
            case &quot;Artwork&quot;:
            case &quot;Artworks&quot;:
                switchView(&quot;Artworks&quot;, feedback.Metadata.SourceID);
                break;
        }
    }

    /**Delete a feedback
     * @method deleteFeedback
     * @param {Object} feedback     feedback to delete
     */
    function deleteFeedback(feedback) {
        prepareNextView(false);
        clearRight();

        // actually delete the feedback
        TAG.Worktop.Database.deleteDoq(feedback.Identifier, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.feedback.text]) {
                return;
            }
            loadFeedbackView();
        }, authError, conflict(feedback), error(loadFeedbackView));
    }

    //Left Bar Functions:

    /**Create a left label 
     * @method createLeftLabel
     * @param  {String} text            the text of the label
     * @param imagesrc                  the source for the image. If not specified no image added
     * @param {Function} onclick        the onclick function for the label
     * @param {Object} id               id to set if specified
     * @param {Function} onDoubleClick  function for double click
     * @param {Boolean} inArtMode 
     * @param extension                 to check if is video or static art
     * @return {Object} container       the container of the new label
     */
    function createLeftLabel(text, imagesrc, onclick, id, noexpand, onDoubleClick, inArtMode, extension) {
        var container = $(document.createElement(&#x27;div&#x27;));
        text = TAG.Util.htmlEntityDecode(text);
        container.attr(&#x27;class&#x27;, &#x27;leftLabel&#x27;);
        if (id) {
            container.attr(&#x27;id&#x27;, id);
        }

        if (inArtMode) {
            if(extension.match(/mp4/)) {
                container.data(&#x27;isVideoArtwork&#x27;, true);
            } else {
                container.data(&#x27;isStaticArtwork&#x27;, true);
            }
        }

        container.mousedown(function () {
            container.css({
                &#x27;background&#x27;: HIGHLIGHT
            });
        });
        container.mouseup(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.mouseleave(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.click(function () {
            if (prevSelectedLeftLabel == container)
                return;
            resetLabels(&#x27;.leftLabel&#x27;);
            selectLabel(container, !noexpand);
            if (onclick)
                onclick();
            prevSelectedLeftLabel = container;
        });
        if (onDoubleClick) {
            container.dblclick(onDoubleClick);
        }
        var width;
        if (imagesrc) {
            var image = $(document.createElement(&#x27;img&#x27;));
            image.attr(&#x27;src&#x27;, imagesrc);
            image.css({
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;20%&#x27;,
                &#x27;margin-right&#x27;: &#x27;5%&#x27;,
            });
            container.append(image);
            

            var progressCircCSS = {
                &#x27;position&#x27;: &#x27;absolute&#x27;,
                &#x27;left&#x27;: &#x27;5%&#x27;,
                &#x27;z-index&#x27;: &#x27;50&#x27;,
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;10%&#x27;,
                &#x27;top&#x27;: &#x27;20%&#x27;,
            };
            var circle = TAG.Util.showProgressCircle(container, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
            image.load(function () {
                TAG.Util.removeProgressCircle(circle);
            });
            width = &#x27;75%&#x27;;
        } else {
            width = &#x27;95%&#x27;;
        }

        var label = $(document.createElement(&#x27;div&#x27;));
        label.attr(&#x27;class&#x27;, &#x27;labelText&#x27;);
        label.css({&#x27;width&#x27;: width});

        if (!imagesrc) {
            label.css({
                &#x27;padding-top&#x27;: &#x27;0.4%&#x27;,
                &#x27;padding-left&#x27;: &#x27;1.3%&#x27;,
            });
        }
        label.text(text);

        container.append(label);

        return container;
    }

    /**Set up the left side for the next view
     * @method prepareNextView
     * @param {Boolean} showSearch      if true show search bar, otherwise hide
     * @param {String} newText          text for the &#x27;New&#x27; button
     * @param {Function} newBehavior    onclick function for the &#x27;New&#x27; button
     * @param {String} loadingText      Text to display while left bar loading
     */
    function prepareNextView(showSearch, newText, newBehavior, loadingText) {
        leftQueue.clear();
        leftLabelContainer.empty();
        leftLabelContainer.append(leftLoading);
        leftLoading.show();
        secondaryButton.css(&quot;display&quot;, &quot;none&quot;);
        newButton.text(newText);
        newButton.unbind(&#x27;click&#x27;).click(newBehavior);
        if (!newText) newButton.hide();
        else newButton.show();
        prevSelectedLeftLabel = null;
        if (cancelLastSetting) cancelLastSetting();

        if (loadingText) {
            leftLoading.children(&#x27;label&#x27;).text(loadingText);
        } else {
            leftLoading.children(&#x27;label&#x27;).text(&#x27;Loading...&#x27;);
        }

        if (showSearch) {
            searchContainer.show();
            searchContainer.css(&#x27;display&#x27;, &#x27;inline-block&#x27;);
            searchbar.val(&quot;&quot;);
        } else {
            searchContainer.hide();
        }
    }

    /**Clears the right side
     * @method clearRight
     */
    function clearRight() {
        settingsContainer.empty();
        buttonContainer.empty();
        rightQueue.clear();
    }

    /**Prepares the viewer on the right side
     * @method prepareViewer
     * @param {Boolean} showViewer    whether the preview window is shown 
     * @param {String} text           text to add to the viewer (in a textbox)
     * @param {Boolean} showButtons   whether the buttonContainer is shown
     */
    function prepareViewer(showViewer,text, showButtons) { 
        viewer.empty();
        viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
        if (showViewer) {
            viewer.show();
            buttonContainer.show();
            buttonContainer.css({
                &#x27;top&#x27;: $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + &#x27;px&#x27;,
                &#x27;margin-top&#x27;: &#x27;0.35%&#x27;,
            });
            settings.css({
                &#x27;height&#x27;: getSettingsHeight() + &#x27;px&#x27;,
            });
            if (text) {
                var textbox = $(document.createElement(&#x27;textarea&#x27;));
                if (typeof text == &#x27;string&#x27;)
                    text = text.replace(/&lt;br \/&gt;/g, &#x27;\n&#x27;).replace(/&lt;br&gt;/g, &#x27;\n&#x27;).replace(/&lt;br\/&gt;/g, &#x27;\n&#x27;);
                textbox.val(text);
                textbox.css({
                    &#x27;padding&#x27;: &#x27;.5%&#x27;,
                    &#x27;width&#x27;: &#x27;100%&#x27;,
                    &#x27;height&#x27;: &#x27;100%&#x27;,
                    &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
                    &#x27;margin&#x27;: &#x27;0px&#x27;,
                });
                textbox.attr(&#x27;readonly&#x27;, &#x27;true&#x27;);
                viewer.append(textbox);
                viewer.css(&#x27;background&#x27;, &#x27;transparent&#x27;);
            } else {
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
            }
        } else {
            viewer.hide();
            settings.css({
                &#x27;height&#x27;: ($(window).height() * CONTENT_HEIGHT / 100) -
                (BUTTON_HEIGHT * 1) + &#x27;px&#x27;,
            });
        }
        if (showButtons===false){
            buttonContainer.hide();
        }
    }

    //Helper methods for label interaction:

    /**Clicks an element determined by a jquery selector when it is added to the page
     * @method clickWhenReady
     * @param selector
     * @param maxtries
     * @param tries
     */
    function clickWhenReady(selector, maxtries, tries) {
        doWhenReady(selector, function (elem) { elem.click(); }, maxtries, tries);
    }

    /** Calls passed in function when the element determined by the selector
     *  is added to the page
     * @method doWhenReady
     * @param {Object} selector     class or id of object(s) on which fn is performed     
     * @param {Function} fn
     * @param maxtries
     * @param tries
     */
    function doWhenReady(selector, fn, maxtries, tries) {
        maxtries = maxtries || 100;
        tries = tries || 0;
        if (tries &gt; maxtries) return;
        if ($.contains(document.documentElement, $(selector)[0])) {
            fn($(selector));
        } else {
            rightQueue.add(function () {
                doWhenReady(selector, fn, maxtries, tries + 1);
            });
        }
    }

    /**Reset mouse interaction for labels
     * @method resetLabels
     * @param {Object} selector     class of labels to reset
     */
    function resetLabels(selector) {
        $(selector).css(&#x27;background&#x27;, &#x27;transparent&#x27;);
        $.each($(selector), function (i, current) {
            if ($(current).attr(&#x27;disabled&#x27;) === &#x27;disabled&#x27;)
                return;
            $(current).mousedown(function () {
                $(current).css({
                    &#x27;background&#x27;: HIGHLIGHT
                });
            });
            $(current).mouseup(function () {
                $(current).css({
                    &#x27;background&#x27;: &#x27;transparent&#x27;
                });
            });
            $(current).mouseleave(function () {
                $(current).css({
                    &#x27;background&#x27;: &#x27;transparent&#x27;
                });
            });
        });
    }

    /**Select a label by unbinding mouse events and highlighting
     * @method selectLabel
     * @param {Object} label    label to select
     * @param {Boolean} expand  if label expands when selected   
     * @return {Object} label   selected label   
     */
    function selectLabel(label, expand) {
        label.css(&#x27;background&#x27;, HIGHLIGHT);
        label.unbind(&#x27;mousedown&#x27;).unbind(&#x27;mouseleave&#x27;).unbind(&#x27;mouseup&#x27;);

        if (expand) {
            label.css(&#x27;height&#x27;, &#x27;&#x27;);
            label.children(&#x27;div&#x27;).css(&#x27;white-space&#x27;, &#x27;&#x27;);

            if (prevSelectedLeftLabel) {
                prevSelectedLeftLabel.children(&#x27;div&#x27;).css(&#x27;white-space&#x27;, &#x27;nowrap&#x27;);
            }
        }
        return label;
    }

    /**Disable a label, unbinding mouse events
     * @method disableLabel
     * @param {Object} label         label to disable
     * @return {Object} label        disabled label
     */
    function disableLabel(label) {
        label.css({
            &#x27;color&#x27;: &#x27;gray&#x27;,
        });
        label.unbind(&#x27;mousedown&#x27;).unbind(&#x27;mouseleave&#x27;).unbind(&#x27;mouseup&#x27;).unbind(&#x27;click&#x27;).attr(&#x27;disabled&#x27;, true);
        return label;
    }

   
    //Settings functions:

    /**Gets the height of the settings section since the viewer has to be positioned absolutely,
     *the entire right bar needs to be position absolutely. Settings has bottom: 0, so the height needs to be correct
     * to not have this be under the buttons container.  If any of the heights of the right components changes it should be
     * updated here.
     * @method getSettingsHeight
     * @return height       appropriate height for settings
     */
    function getSettingsHeight() {
        var height =
        // Start with the entire height of the right side
        ($(window).height() * CONTENT_HEIGHT / 100) -
        // Subtract:
        (
            // Height of the viewer
            $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO +
            // Height of the button container
            BUTTON_HEIGHT * 1 +
            // Height of the padding of the button container
            $(window).width() * RIGHT_WIDTH / 100 * 0.0285
        );
        return height;
    }

    /**Creates a setting to be inserted into the settings container
     * @method createSetting
     * @param {String} text     text for the setting
     * @param {Object} input    the input for the setting
     * @param width             if not falsey then assumed to be number represengint percent, must be less than 95
     * @return container        container of new setting
     */
    function createSetting(text, input, width) {
        var container = $(document.createElement(&#x27;div&#x27;));
        container.attr(&#x27;class&#x27;, &#x27;settingLine&#x27;);

        var label = $(document.createElement(&#x27;div&#x27;));
        label.css({
            &#x27;width&#x27;: width ? 45 - (width - 50) + &#x27;%&#x27; : &#x27;45%&#x27;,
        });
        label.text(text);
        label.attr(&#x27;class&#x27;, &#x27;labelText&#x27;);

        if (width) {
            width = width + &#x27;%&#x27;;
        } else {
            width = &#x27;50%&#x27;;
        }
        input.attr(&#x27;class&#x27;, &#x27;settingInput&#x27;);
        input.css({
            &#x27;width&#x27;: width,
        });

        var clear = $(document.createElement(&#x27;div&#x27;));
        clear.css(&#x27;clear&#x27;, &#x27;both&#x27;);

        container.append(label);
        container.append(input);
        container.append(clear);

        return container;
    }

    //Helper functions:

    /** Create a button 
     * @method createButton
     * @param {String} text         button text
     * @param {Function} onclick    onclick function for button
     * @param css                   additional css to apply to button if specified
     * @return {Object} button      new button created
     */
    function createButton(text, onclick, css) {
        var button = $(document.createElement(&#x27;button&#x27;)).text(text);
        button.attr(&#x27;type&#x27;, &#x27;button&#x27;);
        button.attr(&#x27;class&#x27;,&#x27;button&#x27;);
        if (css) {
            button.css(css);
        }
        button.click(onclick);
        return button;
    }

    /**Create a label
     * @method createLabel
     * @param {String} text         label text
     * @return {Object} label       new label created
     */
    function createLabel(text) {
        var label = $(document.createElement(&#x27;label&#x27;)).text(text || &quot;&quot;);
        return label;
    }

    /**Create a text input
     * @method createTextInput
     * @param {String} text         the default text for the input
     * @param {Boolean} defaultval  if true, reset to default text if empty and loses focus
     * @param maxlength             max length of the input in characters
     * @param hideOnClick
     * @return input                newly created input
     */
    function createTextInput(text, defaultval, maxlength, hideOnClick) {
        var input = $(document.createElement(&#x27;input&#x27;)).val(text);
        input.attr({
            &#x27;type&#x27;: &#x27;text&#x27;,
            &#x27;maxlength&#x27;: maxlength
        });
        return input;
    }

    /**Create a text area input 
     * @method createTextAreaInput
     * @param {String} text     default text for area
     * @param defaultval
     * @param hideOnClick
     * @return {Object} input    newly creted text input
     */
    function createTextAreaInput(text, defaultval, hideOnClick) {
        if (typeof text === &#x27;string&#x27;)
            text = text.replace(/&lt;br \/&gt;/g, &#x27;\n&#x27;).replace(/&lt;br&gt;/g, &#x27;\n&#x27;).replace(/&lt;br\/&gt;/g, &#x27;\n&#x27;);
        var input = $(document.createElement(&#x27;textarea&#x27;)).val(text);
        input.autoSize();
        doWhenReady(input, function (elem) {
            var realHeight = input[0].scrollHeight;
            $(input).css(&#x27;height&#x27;, realHeight + &#x27;px&#x27;);
        });
        return input;
    }

    /**Create a color input which modifies the background color
     * of all elements matching the jquery selector &#x27;selector&#x27;.
     * @method creatBGColorInput 
     * @param color 
     * @param selector                      jQuery selector for elements to be changed
     * @param {Function} getTransValue      returns a valid transparency value  
     * @return {Object} container           returns container holding new input
     */
    function createBGColorInput(color, selector, getTransValue) {
        if (color.indexOf(&#x27;#&#x27;) !== -1) {
            color = color.substring(1, color.length);
        }
        var container = $(document.createElement(&#x27;input&#x27;));
        container.attr(&#x27;type&#x27;, &#x27;text&#x27;);
        var picker = new jscolor.color(container[0], {});
        var hex = TAG.Util.UI.colorToHex(color);
        container.val(color);
        picker.fromString(color);
        picker.onImmediateChange = function () {
            updateBGColor(selector, container.val(), getTransValue());
        };
        return container;
    }

    /**Set the bg color of elements maching jquery selector &#x27;selector&#x27;
     * @method updateBGColor 
     * @param selector          jQuery selector of elements to be changed
     * @param hex               hex value of color
     * @param trans             transparency of color
     */
    function updateBGColor(selector, hex, trans) {
        $(selector).css(&#x27;background-color&#x27;, TAG.Util.UI.hexToRGB(hex) + trans / 100.0 + &#x27;)&#x27;);

    }

    /**Prevent a container from being clicked on by added a div on top of it
     * @method preventClickthrough
     * @param {Object} container     container to prevent click through of
     */
    function preventClickthrough(container) {
        var cover = document.createElement(&#x27;div&#x27;);
        $(cover).css({
            &#x27;height&#x27;: &#x27;100%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;float&#x27;: &#x27;left&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;background-color&#x27;: &#x27;white&#x27;,
            &#x27;opacity&#x27;: &#x27;0&#x27;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;right&#x27;: &#x27;0px&#x27;,
            &#x27;z-index&#x27;: &#x27;499&#x27;,
        });
        $(cover).bind(&#x27;click&#x27;, function () { return false; });
        $(container).append(cover);
    }

    /**Sort a list with propery Name alphabetically, case insensitive
     * @method sortAZ
     * @param {Object} list
     * @return 
     */
    function sortAZ(list) {
        if (list.sort) {
            list.sort(function (a, b) {
                var aLower = a.Name.toLowerCase();
                var bLower = b.Name.toLowerCase();
                return (aLower &lt; bLower) ? -1 : 1;
            });
        }
    }

    /**Sort a list with date metadata by date with most recent date first
     * @method sortDate
     * @param {Object} list 
     * @return 
     */
    function sortDate(list) {
        if (list.sort) {
            list.sort(function (a, b) {
                var aint = parseInt(a.Metadata.Date, 10);
                var bint = parseInt(b.Metadata.Date, 10);
                if (aint &lt; bint) {
                    return 1;
                } else if (aint &gt; bint) {
                    return -1;
                } else {
                    return 0;
                }
            });
        }
    }

    /**Perform a search 
     * @method search
     * @param val           value to search for
     * @param selector      jQuery selector of elements to search
     * @param childType     selector&#x27;s type
     */
    function search(val, selector, childType) {
        $.each($(selector), function (i, child) {
            if ($(child).attr(&#x27;id&#x27;) === &#x27;leftLoading&#x27;)
                return;
            if (TAG.Util.searchString($(child).children(childType).text(), val)) {
                $(child).show();
            } else {
                $(child).hide();
            }
        });
    }

    /**Search data
     * @param val       value to search for
     * @param selector  jQuery selector for elements to be searched
     */
    function searchData(val, selector) {
        $.each($(selector), function (i, element) {
            var data = $(element).data();
            var show = false;
            $.each(data, function (k, v) {
                if (TAG.Util.searchString(v, val)) {
                    show = true;
                }
            });
            if (show) {
                $(element).show();
            } else {
                $(element).hide();
            }
        });
    }

    /**Update text on change
     * @method onChangeUpdateText
     * @param {Object} input    input to update
     * @param selector          jQuery selector of element to update
     * @param maxLength         maximum text length in characters
     * @return {Object}         updated input
     */
    function onChangeUpdateText(input, selector, maxlength) {
        input.keyup(function () {
            if (input.val().length &gt; maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, &#x27;&lt;br /&gt;&#x27;));
        });
        input.keydown(function () {
            if (input.val().length &gt; maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, &#x27;&lt;br /&gt;&#x27;));
        });
        input.change(function () {
            if (input.val().length &gt; maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, &#x27;&lt;br /&gt;&#x27;));
        });
        return input;
    }

    /**Update a text input that takes in a number
     * @method onChangeUpdateNum
     * @param {Object} input            input to update
     * @param min                       minimum value of inputted number
     * @param max                       maximum value of inputted number
     * @param {Function} doOnChange     performed if input value is number between min and max   
     */
    function onChangeUpdateNum(input, min, max, doOnChange) {
        input.keyup(function () {
            var replace = input.val().replace(/[^0-9]/g, &#x27;&#x27;);
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + &#x27;&#x27;) {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
        input.keydown(function () {
            var replace = input.val().replace(/[^0-9]/g, &#x27;&#x27;);
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + &#x27;&#x27;) {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
        input.change(function () {
            var replace = input.val().replace(/[^0-9]/g, &#x27;&#x27;);
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + &#x27;&#x27;) {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
    }


    /**from JavaScript: The Good Parts
     * @method is_array
     * @param value         value to check
     * @return {Boolean}    if value is an array
     */
    function is_array(value) {
        return Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;;
    }

    /** Upload a file then calls the callback with the url and name of the file.
     * @method uploadFIle
     * @param type                  See TAG.Authoring.FileUploader for &#x27;type&#x27; values
     * @param {Function} callback   
     * @param multiple              for batch upload
     * @param filter    
     */
    function uploadFile(type, callback, multiple, filter) {
        var names = [], locals = [], contentTypes = [], fileArray, i;
        TAG.Authoring.FileUploader( // remember, this is a multi-file upload
            root,
            type,
            // local callback - get filename
            function (files, localURLs) {
                fileArray = files;
                for (i = 0; i &lt; files.length; i++) {
                    names.push(files[i].displayName);
                    if (files[i].contentType.match(/image/)) {
                        contentTypes.push(&#x27;Image&#x27;);
                    } else if (files[i].contentType.match(/video/)) {
                        contentTypes.push(&#x27;Video&#x27;);
                    } else if (files[i].contentType.match(/audio/)) {
                        contentTypes.push(&#x27;Audio&#x27;);
                    }
                }
            },
            // remote callback - save correct name
            function (urls) {
                if (!is_array(urls)) { // check to see whether a single file was returned
                    urls = [urls];
                    names = [names];
                }
                for (i = 0; i &lt; urls.length; i++) {
                    console.log(&quot;urls[&quot; + i + &quot;] = &quot; + urls[i] + &quot;, names[&quot; + i + &quot;] = &quot; + names[i]);
                }
                callback(urls, names, contentTypes, fileArray);
            },
            filter || [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;],
            false,
            function () {
                root.append(TAG.Util.UI.popUpMessage(null, &quot;There was an error uploading the file.  Please try again later.&quot;));
            },
            !!multiple // batch upload disabled
            );
    }

    /**Create an overlay over the whole settings view with a spinning circle and centered text. This overlay is intended to be used 
     * only when the page is &#x27;done&#x27;.  The overlay doesn&#x27;t support being removed from the page, so only call this when the page will 
     * be changed!
     * @method loadingOverlay
     * @param {String} text     Text defaults to &#x27;Loading...&#x27; if not specified. 
     */
    function loadingOverlay(text) {
        text = text || &quot;Loading...&quot;;
        var overlay = $(document.createElement(&#x27;div&#x27;));
        overlay.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;0px&#x27;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;height&#x27;: &#x27;100%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.5)&#x27;,
            &#x27;z-index&#x27;: &#x27;1000&#x27;,
        });
        root.append(overlay);

        var circle = $(document.createElement(&#x27;img&#x27;));
        circle.attr(&#x27;src&#x27;, &#x27;images/icons/progress-circle.gif&#x27;);
        circle.css({
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;10%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;45%&#x27;,
            &#x27;top&#x27;: ($(window).height() - $(window).width() * 0.1) / 2 + &#x27;px&#x27;,
        });
        overlay.append(circle);

        var widthFinder = $(document.createElement(&#x27;div&#x27;));
        widthFinder.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;visibility&#x27;: &#x27;hidden&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;font-size&#x27;: &#x27;200%&#x27;,
        });
        widthFinder.text(text);
        root.append(widthFinder);

        var label = $(document.createElement(&#x27;label&#x27;));
        label.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: ($(window).width() - widthFinder.width()) / 2 + &#x27;px&#x27;,
            &#x27;top&#x27;: ($(window).height() - $(window).width() * 0.1) / 2 + $(window).width() * 0.1 + &#x27;px&#x27;,
            &#x27;font-size&#x27;: &#x27;200%&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
        });
        widthFinder.remove();
        label.text(text);
        overlay.append(label);
    }
    
    /** Authentication error function
     * @method authError
     */
    function authError() {
        var popup = TAG.Util.UI.popUpMessage(function () {
            TAG.Auth.clearToken();
            rightQueue.clear();
            leftQueue.clear();
            TAG.Layout.StartPage(null, function (page) {
                TAG.Util.UI.slidePageRight(page);
            });
        }, &quot;Could not authenticate, returning to the splash page.&quot;, null, true);
        root.append(popup);
        $(popup).show();
    }

    /**Error function
     * @method error
     * @param {Function} fn     function called if specified
     */
    function error(fn) {
        return function () {
            var popup = TAG.Util.UI.popUpMessage(null, &quot;An unknown error occured.&quot;, null, true);
            root.append(popup);
            $(popup).show();
            fn &amp;&amp; fn();
        }
    }

    /**Conflict function
    * @method conflict
    * @param doq            doq for which there is a conflict
    * @param {String} text      
    * @param fail
    */
    function conflict(doq, text, fail) {
        return function (jqXHR, ajaxCall) {
            var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                ajaxCall.force();
                // TODO: Text for change/delete
            }, &quot;Your version of &quot; + doq.Name + &quot; is not up to date.  Are you sure you want to change &quot; + doq.Name + &quot;?&quot;, text, true, fail);
            root.append(confirmationBox);
            $(confirmationBox).show();
        }
    }

    return that;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
