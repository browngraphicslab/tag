<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>LADS/js/LADS/tourauthoring/LADS.TourAuthoring.InkAuthoring.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../LADS/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LADS.Layout.Artmode.html">LADS.Layout.Artmode</a></li>
            
                <li><a href="../classes/LADS.Layout.InternetFailurePage.js.html">LADS.Layout.InternetFailurePage.js</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: LADS/js/LADS/tourauthoring/LADS.TourAuthoring.InkAuthoring.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿LADS.Util.makeNamespace(&quot;LADS.TourAuthoring.InkAuthoring&quot;);

// Enum defining ink modes
LADS.TourAuthoring.InkMode = {
    shapes: 0, //shape manipulation
    draw: 1,
    erase: 2,
    text: 5,
};

LADS.TourAuthoring.InkCallers = {
    inkes: 1,
    componentcontrols: 2
};

/**
 * Back-end for ink authoring and editing. Instances are created in ComponentControls and InkES. In
 * ComponentControls, we need the ability to author and edit inks. In InkES, we need them to follow
 * artworks.
 * Uses the RaphaelJS library for svg manipulation.
 * @param canvId        the id of the div to which we&#x27;ll assign the Raphael canvas.
 * @param html_elt      in the case that the div above is not in the dom yet, send in a variable for its html element.
 * @param calling_file  either &#x27;inkes&#x27; or not; slightly different functionality is needed in different instances.
 * @param spec          if the calling file is ComponentControls, we make use of the undoManager etc, so just pass
 *                      in the spec variable from ComponentControls.
 */

LADS.TourAuthoring.InkAuthoring = function (canvId, html_elt, calling_file, spec) {
    &quot;use strict&quot;;

    // set up the Raphael paper/canvas
    var that = {};
    var canvid = canvId;
    that.canvid = canvId;
    html_elt = (html_elt) ? html_elt : $(&quot;#&quot; + canvid)[0];
    var domelement = $(html_elt);
    var textElt;
    var dataHolder = spec.dataHolder;

    var paper = new Raphael(html_elt, &quot;100%&quot;, &quot;100%&quot;);
    $(&quot;#&quot; + canvid + &quot; svg&quot;).css(&quot;position&quot;, &quot;absolute&quot;);
    
    // brush variables
    var penColor = &quot;#000000&quot;;
    var penOpacity = 1.0;
    var penWidth = 7;
    var eraserWidth = 5;
    var ml = []; //path M/L values (see svg path format)
    var xy = []; //path coordinates; each entry has an x and y property
    var pa = []; //path attributes
    var pathObjects = [];
    var currpaths = &quot;&quot;; //this will be the string representing all of our paths; to get the paths individually, split at &#x27;M&#x27;
    


    // ellipse/rectangle variables
    var shapeStrokeColor = &quot;#ffffff&quot;;
    var shapeStrokeOpacity = 0.7;
    var shapeStrokeWidth = 5;
    var shapeFillColor = &quot;#000000&quot;;
    var shapeFillOpacity = 0;

    // block/isolate variables
    var marqueeFillColor = &quot;#000000&quot;;
    var marqueeFillOpacity = 0.8;
    var trans_mode = &#x27;isolate&#x27;;
    var transCoords = [];
    var transLetters = [];
    var trans_currpath = &quot;&quot;;
    var bounding_shapes = &quot;&quot;;

    // text variables
    var fontFamily = &quot;&#x27;Times New Roman&#x27;, serif&quot;;
    var fontColor = &quot;#ffffff&quot;;
    var fontSize = &#x27;12px&#x27;;
    var fontOpacity = 1.0;
    var textboxid = &quot;textbox&quot;;
    var outerdivid = &quot;outerdiv&quot;;
    var lastText = &quot;&quot;;
    var svgText;

    // misc variables
    var inktrack = null;
    calling_file = (calling_file === &#x27;inkes&#x27;) ? &#x27;inkes&#x27; : &#x27;componentcontrols&#x27;;
    var marquees = []; // old marquees
    var click = false; // has the mouse been clicked?
    var datastring = &quot;&quot;;
    var mode = LADS.TourAuthoring.InkMode.draw;
    var enabled = true; //attached ink tracks by default
    var initKeyframe = {};
    var artName = &quot;&quot;;
    var EID = &quot;&quot;; // rin experience id (name of the ink track)
    var oldScale = 1;
    var firstTimeThrough = 2;
    
    // set up the coordinates for adjustViewBox
    var viewerElt;
    if (calling_file === &#x27;inkes&#x27;)
        viewerElt = ($(&quot;#rinplayer&quot;).length) ? $(&quot;#rinplayer&quot;) : $(&quot;#rinPlayer&quot;);
    else
        viewerElt = $(&quot;#rinContainer&quot;);
    var origPaperX = 0; // original coordinates of the paper (match with rinContainer)
    var origPaperY = 0;
    var origPaperW = viewerElt.width();
    var origPaperH = viewerElt.height();
    var origpx = 0; // original coordinates of the artwork
    var origpy = 0;
    var origpw = 0;
    var origph = 0;
    var lastpx = 0; // most recent coordinates of the artwork
    var lastpy = 0;
    var lastpw = 0;
    var lastph = 0;
    var lastcx = 0; // most recent coordinates of the &quot;virtual canvas&quot; which helps us place inks correctly
    var lastcy = 0; // the virtual canvas is where the Raphael canvas would be if it were moving with the artwork
    var lastcw = origPaperW;
    var lastch = origPaperH;
    var oldOpac = 0; // keeps track of whether an ink is on screen or not

    // componentControls-specific variables for creating an ink undo manager, getting keyframes
    var inkUndoManager;
    var playbackControls;
    var undoManager;
    var timeline;
    var timeManager;
    var viewer;
    var dataHolder;
    if (calling_file !== &#x27;inkes&#x27;) {
        playbackControls = spec.playbackControls;
        undoManager = spec.undoManager;
        timeline = spec.timeline;
        timeManager = spec.timeManager;
        viewer = spec.viewer;
        // set up the ink undo manager using existing undo/redo buttons
        inkUndoManager = new LADS.TourAuthoring.UndoManager();
        inkUndoManager.setInitialized(true);
        playbackControls.undoButton.off(&quot;click&quot;);
        playbackControls.redoButton.off(&quot;click&quot;);
        playbackControls.undoButton.on(&#x27;click&#x27;, function () {
            inkUndoManager.undo();
        });
        playbackControls.redoButton.on(&#x27;click&#x27;, function () {
            inkUndoManager.redo();
        });
    }
    
    
    // methods //

    /**
     * Sets ink params to defaults
     */
    function resetParams() {
        // brush variables
        penColor = &quot;#000000&quot;;
        penOpacity = 1.0;
        penWidth = 7;
        eraserWidth = 5;

        // ellipse/rectangle variables
        shapeStrokeColor = &quot;#ffffff&quot;;
        shapeStrokeOpacity = 0.7;
        shapeStrokeWidth = 5;
        shapeFillColor = &quot;#000000&quot;;
        shapeFillOpacity = 0;

        // block/isolate variables
        marqueeFillColor = &quot;#000000&quot;;
        marqueeFillOpacity = 0.8;
        trans_mode = &#x27;isolate&#x27;;

        // text variables
        fontFamily = &quot;&#x27;Times New Roman&#x27;, serif&quot;;
        fontColor = &quot;#ffffff&quot;;
        fontSize = &#x27;12px&#x27;;
        fontOpacity = 1.0;
    }
    that.resetParams = resetParams;

    /**
     * Helper function to parse and multiply dimensions.
     * @param rel_coord    the relative coordinate we want to convert to absolute coordinates
     * @param canv_dim     the relevant dimension of the canvas used for scaling
     * @return    the absolute coordinate
     */
    function abs_dims(rel_coord, canv_dim) {
        return parseFloat(rel_coord) * parseFloat(canv_dim);
    }
    that.abs_dims = abs_dims;

    /**
     * Takes an ellipse or rectangle and adds styling, drag events, drag handles to it.
     * @param elt     the svg element
     * @param others  styling to apply to elt
     */
    function add_attributes(elt, fillColor, fillOpacity, strokeColor, strokeOpacity, strokeWidth) {
        var origmousex;
        var origmousey;
        var origposition = { x: 0, y: 0, w: 0, h: 0 };
        var c1origposition = { x: 0, y: 0, w: 0, h: 0 };
        var c2origposition = { x: 0, y: 0, w: 0, h: 0 };
        var dcorigposition = { x: 0, y: 0, w: 0, h: 0 };
        var eltbbox, c1bbox, c2bbox, dcbbox;
        var beenMoved;

        // if attributes are not passed in, use global variables
        if (fillColor === undefined)
            fillColor = shapeFillColor;
        if (fillOpacity === undefined)
            fillOpacity = shapeFillOpacity;
        if (strokeColor === undefined)
            strokeColor = shapeStrokeColor;
        if (strokeOpacity === undefined)
            strokeOpacity = shapeStrokeOpacity;
        if (strokeWidth === undefined)
            strokeWidth = shapeStrokeWidth;

        elt.attr({ // add color attributes
            &quot;stroke-width&quot;: strokeWidth,
            &quot;stroke&quot;: strokeColor,
            &quot;stroke-opacity&quot;: strokeOpacity,
            &quot;fill&quot;: fillColor,
            &quot;fill-opacity&quot;: fillOpacity,
            &quot;stroke-dasharray&quot;: &quot;-&quot;,
        });

        var C1, C2; // drag handles
        var DC; // deletion circle
        var rds = LADS.TourAuthoring.Constants.inkDragHandleRadius;

        if (elt.data(&quot;type&quot;) == &quot;ellipse&quot;) {
            var rx = elt.data(&quot;curr_rx&quot;);
            var ry = elt.data(&quot;curr_ry&quot;);
            var cx = elt.data(&quot;currx&quot;) + rx;
            var cy = elt.data(&quot;curry&quot;) + ry;
            var x0 = rx / Math.sqrt(2.0); // fix where the top left drag handle should be in proportion to the radius
            var y0 = ry * Math.sqrt(1 - x0 * x0 / (rx * rx)); // (if ellipse is a circle, handle will be on the line between center and top left corner of bounding box)
            C1 = paper.ellipse(cx - x0 - strokeWidth/2, cy+strokeWidth / 2 - y0, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#ffffff&quot;, &quot;fill&quot;: &quot;#296B2F&quot;, &quot;fill-opacity&quot;: 0.9 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
            C2 = paper.ellipse(cx + x0 + strokeWidth / 2, cy + y0 + strokeWidth / 2, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#296B2F&quot;, &quot;fill&quot;: &quot;#ffffff&quot;, &quot;fill-opacity&quot;: 0.9 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
            DC = paper.ellipse(cx + x0 + strokeWidth / 2, cy + strokeWidth / 2 - y0, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#ffffff&quot;, &quot;fill&quot;: &quot;#880000&quot;, &quot;fill-opacity&quot;: 0.9 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
        }
        else if (elt.data(&quot;type&quot;) == &quot;rect&quot;) {
            var x = elt.data(&quot;currx&quot;);
            var y = elt.data(&quot;curry&quot;);
            var w = elt.data(&quot;currw&quot;);
            var h = elt.data(&quot;currh&quot;);
            C1 = paper.ellipse(x, y, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#ffffff&quot;, &quot;fill&quot;: &quot;#296B2F&quot;, &quot;fill-opacity&quot;: 0.9 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
            C2 = paper.ellipse(x + w, y + h, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#296B2F&quot;, &quot;fill&quot;: &quot;#ffffff&quot;, &quot;fill-opacity&quot;: 0.9 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
            DC = paper.ellipse(x + w, y, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#ffffff&quot;, &quot;fill&quot;: &quot;#880000&quot;, &quot;fill-opacity&quot;: 0.9 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
        }
        C1.data(&quot;curr_cx&quot;, C1.attr(&quot;cx&quot;));
        C1.data(&quot;curr_cy&quot;, C1.attr(&quot;cy&quot;));
        C2.data(&quot;curr_cx&quot;, C2.attr(&quot;cx&quot;));
        C2.data(&quot;curr_cy&quot;, C2.attr(&quot;cy&quot;));
        DC.data(&quot;curr_cx&quot;, DC.attr(&quot;cx&quot;));
        DC.data(&quot;curr_cy&quot;, DC.attr(&quot;cy&quot;));

        //log in the undo manager; show and hide elements
        var command = LADS.TourAuthoring.Command({
            execute: function () {
                elt.show();
                C1.show();
                C2.show();
                DC.show();
                elt.data(&quot;visible&quot;, &quot;yes&quot;);
            },
            unexecute: function () {
                elt.hide();
                C1.hide();
                C2.hide();
                DC.hide();
                elt.data(&quot;visible&quot;, &quot;no&quot;);
            }
        });
        command.execute();
        inkUndoManager.logCommand(command);

        // define drag functionality for the panning handle (upper-left)
        C1.drag(function (dx, dy, mousex, mousey) { // move
            beenMoved = true;
            elt.toFront();
            C1.toFront();
            C2.toFront();
            DC.toFront();
            var halfWid = (origposition.w + strokeWidth) / 2;
            var halfHei = (origposition.h + strokeWidth) / 2;

            var circleRadius = C1.attr(&quot;rx&quot;);
            //Hard stops for textbox location in ink canvas
            if (c2origposition.x + strokeWidth + circleRadius + dx &lt;= halfWid) {
                dx = halfWid - c2origposition.x - circleRadius;
            }
            if (c2origposition.y + circleRadius +strokeWidth + dy &lt;= halfHei) {
                dy = halfWid - c2origposition.y - circleRadius;
            }
            if (c1origposition.x + circleRadius + dx + halfWid &gt;= canvwidth) {
                dx = canvwidth - halfWid - c1origposition.x - circleRadius;
            }
            if (c1origposition.y + circleRadius + dy + halfHei &gt;= canvheight) {
                dy = canvheight - c1origposition.y - circleRadius - halfHei;
            }

            var c1currx = parseInt(C1.data(&quot;curr_cx&quot;), 10);//x position at the start of drag
            var c1curry = parseInt(C1.data(&quot;curr_cy&quot;), 10);
            var xpos = c1currx + dx; // to get new x position, just add dx
            var ypos = c1curry + dy;
            C1.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            var c2currx = parseInt(C2.data(&quot;curr_cx&quot;), 10);// x position at the start of drag
            var c2curry = parseInt(C2.data(&quot;curr_cy&quot;), 10);
            xpos = c2currx + dx; // to get new x position, just add dx
            ypos = c2curry + dy;
            C2.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            var dccurrx = parseInt(DC.data(&quot;curr_cx&quot;), 10);
            var dccurry = parseInt(DC.data(&quot;curr_cy&quot;), 10);
            xpos = dccurrx + dx;
            ypos = dccurry + dy;
            DC.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            var eltcurrx, eltcurry;
            if (elt.data(&quot;type&quot;) === &quot;ellipse&quot;) {
                eltcurrx = parseInt(elt.data(&quot;currx&quot;),10) + elt.attr(&quot;rx&quot;);// x position at the start of drag
                eltcurry = parseInt(elt.data(&quot;curry&quot;),10) + elt.attr(&quot;ry&quot;);
            }
            else if (elt.data(&quot;type&quot;) === &quot;rect&quot;) {
                eltcurrx = parseInt(elt.data(&quot;currx&quot;),10);
                eltcurry = parseInt(elt.data(&quot;curry&quot;),10);
            }
            xpos = eltcurrx + dx; // to get new x position, just add dx
            ypos = eltcurry + dy;
            elt.attr({
                x: xpos,
                y: ypos,
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });
        },
        function (x, y) { // start; record original positions
            beenMoved = false;
            eltbbox = elt.getBBox();
            origposition.x = eltbbox.x;
            origposition.y = eltbbox.y;
            origposition.w = eltbbox.width;
            origposition.h = eltbbox.height;

            c1bbox = C1.getBBox();
            c1origposition.x = c1bbox.x;
            c1origposition.y = c1bbox.y;
            c1origposition.w = c1bbox.width;
            c1origposition.h = c1bbox.height;

            c2bbox = C2.getBBox();
            c2origposition.x = c2bbox.x;
            c2origposition.y = c2bbox.y;
            c2origposition.w = c2bbox.width;
            c2origposition.h = c2bbox.height;

            dcbbox = DC.getBBox();
            dcorigposition.x = dcbbox.x;
            dcorigposition.y = dcbbox.y;
            dcorigposition.w = dcbbox.width;
            dcorigposition.h = dcbbox.height;
        },
        function (x, y) { // stop; log in undomanager and set data of element
            if (!beenMoved) {
                return;
            }
            var c1bboxx = C1.getBBox().x;
            var c1bboxy = C1.getBBox().y;
            var c1bboxw = C1.getBBox().width;
            var c1bboxh = C1.getBBox().height;
            this.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0); //reset data using bounding box coords
            this.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);

            var c2bboxx = C2.getBBox().x;
            var c2bboxy = C2.getBBox().y;
            var c2bboxw = C2.getBBox().width;
            var c2bboxh = C2.getBBox().height;
            C2.data(&quot;curr_cx&quot;, c2bboxx + c2bboxw / 2.0); //reset data using bounding box coords
            C2.data(&quot;curr_cy&quot;, c2bboxy + c2bboxh / 2.0);

            var dcbboxx = DC.getBBox().x;
            var dcbboxy = DC.getBBox().y;
            var dcbboxw = DC.getBBox().width;
            var dcbboxh = DC.getBBox().height;
            DC.data(&quot;curr_cx&quot;, dcbboxx + dcbboxw / 2.0); //reset data using bounding box coords
            DC.data(&quot;curr_cy&quot;, dcbboxy + dcbboxh / 2.0);

            var bboxx = elt.getBBox().x;
            var bboxy = elt.getBBox().y;
            var bboxw = elt.getBBox().width;
            var bboxh = elt.getBBox().height;

            if (elt.data(&quot;type&quot;) == &quot;ellipse&quot;) {
                elt.data(&quot;currx&quot;, elt.attr(&quot;cx&quot;) - elt.attr(&quot;rx&quot;));
                elt.data(&quot;curry&quot;, elt.attr(&quot;cy&quot;) - elt.attr(&quot;ry&quot;));
                elt.data(&quot;curr_rx&quot;, elt.attr(&quot;rx&quot;));
                elt.data(&quot;curr_ry&quot;, elt.attr(&quot;ry&quot;));
            }
            else if (elt.data(&quot;type&quot;) == &quot;rect&quot;) {
                elt.data(&quot;currx&quot;, elt.attr(&quot;x&quot;));
                elt.data(&quot;curry&quot;, elt.attr(&quot;y&quot;));
            }

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var o2x = c2origposition.x;
            var o2y = c2origposition.y;
            var o2w = c2origposition.w;
            var o2h = c2origposition.h;

            var odcx = dcorigposition.x;
            var odcy = dcorigposition.y;
            var odcw = dcorigposition.w;
            var odch = dcorigposition.h;

            var command = LADS.TourAuthoring.Command({
                execute: function () {
                    //console.log(&quot;bbox in execute: {&quot; + bboxx + &quot;,&quot; + bboxy + &quot;,&quot; + bboxw + &quot;,&quot; + bboxh + &quot;}&quot;);
                    elt.data(&quot;currx&quot;, bboxx);
                    elt.data(&quot;curry&quot;, bboxy);
                    elt.data(&quot;currw&quot;, bboxw);
                    elt.data(&quot;currh&quot;, bboxh);
                    elt.data(&quot;curr_rx&quot;, bboxw / 2.0);
                    elt.data(&quot;curr_ry&quot;, bboxh / 2.0);
                    elt.attr({
                        cx: bboxx + bboxw / 2.0,
                        cy: bboxy + bboxh / 2.0,
                        rx: bboxw / 2.0,
                        ry: bboxh / 2.0,
                        x: bboxx,
                        y: bboxy,
                        width: bboxw,
                        height: bboxh,
                    });

                    C1.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0);
                    C1.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                    C2.data(&quot;curr_cx&quot;, c2bboxx + c2bboxw / 2.0);
                    C2.data(&quot;curr_cy&quot;, c2bboxy + c2bboxh / 2.0);
                    C2.attr({
                        cx: c2bboxx + c2bboxw / 2.0,
                        cy: c2bboxy + c2bboxh / 2.0,
                        rx: c2bboxw / 2.0,
                        ry: c2bboxh / 2.0,
                    });
                    DC.data(&quot;curr_cx&quot;, dcbboxx + dcbboxw / 2.0);
                    DC.data(&quot;curr_cy&quot;, dcbboxy + dcbboxh / 2.0);
                    DC.attr({
                        cx: dcbboxx + dcbboxw / 2.0,
                        cy: dcbboxy + dcbboxh / 2.0,
                        rx: dcbboxw / 2.0,
                        ry: dcbboxh / 2.0,
                    });
                },
                unexecute: function () {
                    //console.log(&quot;origposition in unexecute: {&quot; + ox + &quot;,&quot; + oy + &quot;,&quot; + ow + &quot;,&quot; + oh + &quot;}&quot;);
                    elt.data(&quot;currx&quot;, ox);
                    elt.data(&quot;curry&quot;, oy);
                    elt.data(&quot;currw&quot;, ow);
                    elt.data(&quot;currh&quot;, oh);
                    elt.data(&quot;curr_rx&quot;, ow / 2.0);
                    elt.data(&quot;curr_ry&quot;, oh / 2.0);
                    elt.attr({
                        cx: ox + ow / 2.0,
                        cy: oy + oh / 2.0,
                        rx: ow / 2.0,
                        ry: oh / 2.0,
                        x: ox,
                        y: oy,
                        width: ow,
                        height: oh,
                    });

                    C1.data(&quot;curr_cx&quot;, o1x + o1w / 2.0);
                    C1.data(&quot;curr_cy&quot;, o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });

                    C2.data(&quot;curr_cx&quot;, o2x + o2w / 2.0);
                    C2.data(&quot;curr_cy&quot;, o2y + o2h / 2.0);
                    C2.attr({
                        cx: o2x + o2w / 2.0,
                        cy: o2y + o2h / 2.0,
                    });

                    DC.data(&quot;curr_cx&quot;, odcx + odcw / 2.0);
                    DC.data(&quot;curr_cy&quot;, odcy + odch / 2.0);
                    DC.attr({
                        cx: odcx + odcw / 2.0,
                        cy: odcy + odch / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });

        // define drag functionality for the resizing handle (lower-right);
        // when we resize, keep the panning handle where it is, have the resizing handle follow the mouse,
        // set the shape to be whatever it needs to be to satisfy those constraints
        C2.drag(function (dx, dy, mousex, mousey) {
            beenMoved = true;
            elt.toFront();
            C1.toFront();
            C2.toFront();
            DC.toFront();

            var currx = parseInt(C2.data(&quot;curr_cx&quot;),10);//x position at the start of drag
            var curry = parseInt(C2.data(&quot;curr_cy&quot;),10);
            var xpos = currx + dx; //to get new x position, just add dx
            var ypos = curry + dy;
            var x0 = C1.attr(&quot;cx&quot;);
            var y0 = C1.attr(&quot;cy&quot;);
            var handlerad = LADS.TourAuthoring.Constants.inkDragHandleRadius;

            if (xpos - x0 &gt; 2 * handlerad) {
                C2.attr({ cx: xpos });
                DC.attr({ cx: xpos });
            }
            if (ypos - y0 &gt; 2 * handlerad) {
                C2.attr({ cy: ypos });
            }

            var x1 = this.attr(&quot;cx&quot;);
            var y1 = this.attr(&quot;cy&quot;);

            var oldrx = elt.attr(&quot;rx&quot;);
            var CX = x0 + (x1 - x0) / 2.0;
            var CY = y0 + (y1 - y0) / 2.0;
            var RADx = (x1 - x0) / 2.0 * Math.sqrt(2);
            elt.attr({
                cx: CX,
                cy: CY,
                rx: RADx,
                ry: RADx * Math.sqrt((-(y1 - CY) * (y1 - CY)) / ((x1 - CX) * (x1 - CX) - (RADx) * (RADx))),
                width: x1 - x0,
                height: y1 - y0,
            });
        },
        function (x, y) { //start
            beenMoved = false;
            var bbox = elt.getBBox();
            origposition.x = bbox.x;
            origposition.y = bbox.y;
            origposition.w = bbox.width;
            origposition.h = bbox.height;

            bbox = C1.getBBox();
            c1origposition.x = bbox.x;
            c1origposition.y = bbox.y;
            c1origposition.w = bbox.width;
            c1origposition.h = bbox.height;

            bbox = C2.getBBox();
            c2origposition.x = bbox.x;
            c2origposition.y = bbox.y;
            c2origposition.w = bbox.width;
            c2origposition.h = bbox.height;

            bbox = DC.getBBox();
            dcorigposition.x = bbox.x;
            dcorigposition.y = bbox.y;
            dcorigposition.w = bbox.width;
            dcorigposition.h = bbox.height;
        },
        function (x, y) { //stop
            if (!beenMoved) {
                return;
            }
            var c2bboxx = C2.getBBox().x;
            var c2bboxy = C2.getBBox().y;
            var c2bboxw = C2.getBBox().width;
            var c2bboxh = C2.getBBox().height;
            C2.data(&quot;curr_cx&quot;, c2bboxx + c2bboxw / 2.0); //reset data using bounding box coords
            C2.data(&quot;curr_cy&quot;, c2bboxy + c2bboxh / 2.0);
            if (elt.data(&quot;type&quot;) === &quot;ellipse&quot;) {
                elt.data(&quot;currx&quot;, elt.attr(&quot;cx&quot;) - elt.attr(&quot;rx&quot;));
                elt.data(&quot;curry&quot;, elt.attr(&quot;cy&quot;) - elt.attr(&quot;ry&quot;));
                elt.data(&quot;curr_rx&quot;, elt.attr(&quot;rx&quot;));
                elt.data(&quot;curr_ry&quot;, elt.attr(&quot;ry&quot;));
            }
            else if (elt.data(&quot;type&quot;) === &quot;rect&quot;) {
                elt.data(&quot;currx&quot;, elt.attr(&quot;x&quot;));
                elt.data(&quot;curry&quot;, elt.attr(&quot;y&quot;));
                elt.data(&quot;currw&quot;, elt.attr(&quot;width&quot;));
                elt.data(&quot;currh&quot;, elt.attr(&quot;height&quot;));
            }

            var bboxx = elt.getBBox().x;
            var bboxy = elt.getBBox().y;
            var bboxw = elt.getBBox().width;
            var bboxh = elt.getBBox().height;

            var c1bboxx = C1.getBBox().x;
            var c1bboxy = C1.getBBox().y;
            var c1bboxw = C1.getBBox().width;
            var c1bboxh = C1.getBBox().height;

            var dcbboxx = DC.getBBox().x;
            var dcbboxy = DC.getBBox().y;
            var dcbboxw = DC.getBBox().width;
            var dcbboxh = DC.getBBox().height;

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var o2x = c2origposition.x;
            var o2y = c2origposition.y;
            var o2w = c2origposition.w;
            var o2h = c2origposition.h;

            var odcx = dcorigposition.x;
            var odcy = dcorigposition.y;
            var odcw = dcorigposition.w;
            var odch = dcorigposition.h;

            // log command
            var command = LADS.TourAuthoring.Command({
                execute: function () {
                    //console.log(&quot;bbox in execute: {&quot; + bboxx + &quot;,&quot; + bboxy + &quot;,&quot; + bboxw + &quot;,&quot; + bboxh + &quot;}&quot;);
                    elt.data(&quot;currx&quot;, bboxx);
                    elt.data(&quot;curry&quot;, bboxy);
                    elt.data(&quot;currw&quot;, bboxw);
                    elt.data(&quot;currh&quot;, bboxh);
                    elt.data(&quot;curr_rx&quot;, bboxw / 2.0);
                    elt.data(&quot;curr_ry&quot;, bboxh / 2.0);
                    elt.attr({
                        cx: bboxx + bboxw / 2.0,
                        cy: bboxy + bboxh / 2.0,
                        rx: bboxw / 2.0,
                        ry: bboxh / 2.0,
                        x: bboxx,
                        y: bboxy,
                        width: bboxw,
                        height: bboxh,
                    });

                    C1.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0);
                    C1.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                    C2.data(&quot;curr_cx&quot;, c2bboxx + c2bboxw / 2.0);
                    C2.data(&quot;curr_cy&quot;, c2bboxy + c2bboxh / 2.0);
                    C2.attr({
                        cx: c2bboxx + c2bboxw / 2.0,
                        cy: c2bboxy + c2bboxh / 2.0,
                        rx: c2bboxw / 2.0,
                        ry: c2bboxh / 2.0,
                    });
                    DC.data(&quot;curr_cx&quot;, dcbboxx + dcbboxw / 2.0);
                    DC.data(&quot;curr_cy&quot;, dcbboxy + dcbboxh / 2.0);
                    DC.attr({
                        cx: dcbboxx + dcbboxw / 2.0,
                        cy: dcbboxy + dcbboxh / 2.0,
                        rx: dcbboxw / 2.0,
                        ry: dcbboxh / 2.0,
                    });
                },
                unexecute: function () {
                    //console.log(&quot;origposition in unexecute: {&quot; + ox + &quot;,&quot; + oy + &quot;,&quot; + ow + &quot;,&quot; + oh + &quot;}&quot;);
                    elt.data(&quot;currx&quot;, ox);
                    elt.data(&quot;curry&quot;, oy);
                    elt.data(&quot;currw&quot;, ow);
                    elt.data(&quot;currh&quot;, oh);
                    elt.data(&quot;curr_rx&quot;, ow / 2.0);
                    elt.data(&quot;curr_ry&quot;, oh / 2.0);
                    elt.attr({
                        cx: ox + ow / 2.0,
                        cy: oy + oh / 2.0,
                        rx: ow / 2.0,
                        ry: oh / 2.0,
                        x: ox,
                        y: oy,
                        width: ow,
                        height: oh,
                    });

                    C1.data(&quot;curr_cx&quot;, o1x + o1w / 2.0);
                    C1.data(&quot;curr_cy&quot;, o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });

                    C2.data(&quot;curr_cx&quot;, o2x + o2w / 2.0);
                    C2.data(&quot;curr_cy&quot;, o2y + o2h / 2.0);
                    C2.attr({
                        cx: o2x + o2w / 2.0,
                        cy: o2y + o2h / 2.0,
                    });

                    DC.data(&quot;curr_cx&quot;, odcx + odcw / 2.0);
                    DC.data(&quot;curr_cy&quot;, odcy + odch / 2.0);
                    DC.attr({
                        cx: odcx + odcw / 2.0,
                        cy: odcy + odch / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });

        //define drag functionality for the shape itself (panning)
        elt.drag(function (dx, dy, mousex, mousey) { // move
            beenMoved = true;
            this.toFront();
            C1.toFront();
            C2.toFront();
            DC.toFront();
            var halfWid = (origposition.w + strokeWidth) / 2;
            var halfHei = (origposition.h + strokeWidth) / 2;
            var circleRadius = C1.attr(&quot;rx&quot;);
            if (c2origposition.x + strokeWidth + circleRadius + dx &lt;= halfWid) {
                dx = halfWid - c2origposition.x - circleRadius;
            }
            if (c2origposition.y + circleRadius + strokeWidth + dy &lt;= halfHei) {
                dy = halfWid - c2origposition.y - circleRadius;
            }
            if (c1origposition.x + circleRadius + dx + halfWid &gt;= canvwidth) {
                dx = canvwidth - halfWid - c1origposition.x - circleRadius;
            }
            if (c1origposition.y + circleRadius + dy + halfHei &gt;= canvheight) {
                dy = canvheight - c1origposition.y - circleRadius - halfHei;
            }

            var c1currx = parseInt(C1.data(&quot;curr_cx&quot;),10);
            var c1curry = parseInt(C1.data(&quot;curr_cy&quot;),10);
            var xpos = c1currx + dx;
            var ypos = c1curry + dy;
            C1.attr({
                cx: xpos,
                cy: ypos,
            });

            var c2currx = parseInt(C2.data(&quot;curr_cx&quot;),10);
            var c2curry = parseInt(C2.data(&quot;curr_cy&quot;),10);
            xpos = c2currx + dx;
            ypos = c2curry + dy;
            C2.attr({
                cx: xpos,
                cy: ypos,
            });

            var dccurrx = parseInt(DC.data(&quot;curr_cx&quot;), 10);
            var dccurry = parseInt(DC.data(&quot;curr_cy&quot;), 10);
            xpos = dccurrx + dx;
            ypos = dccurry + dy;
            DC.attr({
                cx: xpos,
                cy: ypos,
            });

            var eltcurrx, eltcurry;
            if (elt.data(&quot;type&quot;) == &quot;ellipse&quot;) {
                eltcurrx = parseInt(this.data(&quot;currx&quot;),10) + this.attr(&quot;rx&quot;);
                eltcurry = parseInt(this.data(&quot;curry&quot;),10) + this.attr(&quot;ry&quot;);
            }
            else if (elt.data(&quot;type&quot;) == &quot;rect&quot;) {
                eltcurrx = parseInt(this.data(&quot;currx&quot;),10);
                eltcurry = parseInt(this.data(&quot;curry&quot;),10);
            }
            xpos = eltcurrx + dx;
            ypos = eltcurry + dy;
            this.attr({
                x: xpos,
                y: ypos,
                cx: xpos,
                cy: ypos,
            });
        },
        function (x, y) { // start
            beenMoved = false;
            var bbox = elt.getBBox();
            origposition.x = bbox.x;
            origposition.y = bbox.y;
            origposition.w = bbox.width;
            origposition.h = bbox.height;

            bbox = C1.getBBox();
            c1origposition.x = bbox.x;
            c1origposition.y = bbox.y;
            c1origposition.w = bbox.width;
            c1origposition.h = bbox.height;

            bbox = C2.getBBox();
            c2origposition.x = bbox.x;
            c2origposition.y = bbox.y;
            c2origposition.w = bbox.width;
            c2origposition.h = bbox.height;

            bbox = DC.getBBox();
            dcorigposition.x = bbox.x;
            dcorigposition.y = bbox.y;
            dcorigposition.w = bbox.width;
            dcorigposition.h = bbox.height;
        },
        function (x, y) { //stop
            if (!beenMoved) {
                return;
            }
            var c1bboxx = C1.getBBox().x;
            var c1bboxy = C1.getBBox().y;
            var c1bboxw = C1.getBBox().width;
            var c1bboxh = C1.getBBox().height;
            C1.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0); //reset data using bounding box coords
            C1.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);

            var c2bboxx = C2.getBBox().x;
            var c2bboxy = C2.getBBox().y;
            var c2bboxw = C2.getBBox().width;
            var c2bboxh = C2.getBBox().height;
            C2.data(&quot;curr_cx&quot;, c2bboxx + c2bboxw / 2.0); //reset data using bounding box coords
            C2.data(&quot;curr_cy&quot;, c2bboxy + c2bboxh / 2.0);

            if (elt.data(&quot;type&quot;) == &quot;ellipse&quot;) {
                elt.data(&quot;currx&quot;, elt.attr(&quot;cx&quot;) - elt.attr(&quot;rx&quot;));
                elt.data(&quot;curry&quot;, elt.attr(&quot;cy&quot;) - elt.attr(&quot;ry&quot;));
                elt.data(&quot;curr_rx&quot;, elt.attr(&quot;rx&quot;));
                elt.data(&quot;curr_ry&quot;, elt.attr(&quot;ry&quot;));
            }
            else if (elt.data(&quot;type&quot;) == &quot;rect&quot;) {
                elt.data(&quot;currx&quot;, elt.attr(&quot;x&quot;));
                elt.data(&quot;curry&quot;, elt.attr(&quot;y&quot;));
            }

            var bboxx = elt.getBBox().x;
            var bboxy = elt.getBBox().y;
            var bboxw = elt.getBBox().width;
            var bboxh = elt.getBBox().height;

            var dcbboxx = DC.getBBox().x;
            var dcbboxy = DC.getBBox().y;
            var dcbboxw = DC.getBBox().width;
            var dcbboxh = DC.getBBox().height;

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var o2x = c2origposition.x;
            var o2y = c2origposition.y;
            var o2w = c2origposition.w;
            var o2h = c2origposition.h;

            var odcx = dcorigposition.x;
            var odcy = dcorigposition.y;
            var odcw = dcorigposition.w;
            var odch = dcorigposition.h;

            // log command
            var command = LADS.TourAuthoring.Command({
                execute: function () {
                    //console.log(&quot;bbox in execute: {&quot; + bboxx + &quot;,&quot; + bboxy + &quot;,&quot; + bboxw + &quot;,&quot; + bboxh + &quot;}&quot;);
                    elt.data(&quot;currx&quot;, bboxx);
                    elt.data(&quot;curry&quot;, bboxy);
                    elt.data(&quot;currw&quot;, bboxw);
                    elt.data(&quot;currh&quot;, bboxh);
                    elt.data(&quot;curr_rx&quot;, bboxw / 2.0);
                    elt.data(&quot;curr_ry&quot;, bboxh / 2.0);
                    elt.attr({
                        cx: bboxx + bboxw / 2.0,
                        cy: bboxy + bboxh / 2.0,
                        rx: bboxw / 2.0,
                        ry: bboxh / 2.0,
                        x: bboxx,
                        y: bboxy,
                        width: bboxw,
                        height: bboxh,
                    });

                    C1.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0);
                    C1.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                    C2.data(&quot;curr_cx&quot;, c2bboxx + c2bboxw / 2.0);
                    C2.data(&quot;curr_cy&quot;, c2bboxy + c2bboxh / 2.0);
                    C2.attr({
                        cx: c2bboxx + c2bboxw / 2.0,
                        cy: c2bboxy + c2bboxh / 2.0,
                        rx: c2bboxw / 2.0,
                        ry: c2bboxh / 2.0,
                    });
                    DC.data(&quot;curr_cx&quot;, dcbboxx + dcbboxw / 2.0);
                    DC.data(&quot;curr_cy&quot;, dcbboxy + dcbboxh / 2.0);
                    DC.attr({
                        cx: dcbboxx + dcbboxw / 2.0,
                        cy: dcbboxy + dcbboxh / 2.0,
                        rx: dcbboxw / 2.0,
                        ry: dcbboxh / 2.0,
                    });
                },
                unexecute: function () {
                    //console.log(&quot;origposition in unexecute: {&quot; + ox + &quot;,&quot; + oy + &quot;,&quot; + ow + &quot;,&quot; + oh + &quot;}&quot;);
                    elt.data(&quot;currx&quot;, ox);
                    elt.data(&quot;curry&quot;, oy);
                    elt.data(&quot;currw&quot;, ow);
                    elt.data(&quot;currh&quot;, oh);
                    elt.data(&quot;curr_rx&quot;, ow / 2.0);
                    elt.data(&quot;curr_ry&quot;, oh / 2.0);

                    elt.attr({
                        cx: ox + ow / 2.0,
                        cy: oy + oh / 2.0,
                        rx: ow / 2.0,
                        ry: oh / 2.0,
                        x: ox,
                        y: oy,
                        width: ow,
                        height: oh,
                    });

                    C1.data(&quot;curr_cx&quot;, o1x + o1w / 2.0);
                    C1.data(&quot;curr_cy&quot;, o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });

                    C2.data(&quot;curr_cx&quot;, o2x + o2w / 2.0);
                    C2.data(&quot;curr_cy&quot;, o2y + o2h / 2.0);
                    C2.attr({
                        cx: o2x + o2w / 2.0,
                        cy: o2y + o2h / 2.0,
                    });

                    DC.data(&quot;curr_cx&quot;, odcx + odcw / 2.0);
                    DC.data(&quot;curr_cy&quot;, odcy + odch / 2.0);
                    DC.attr({
                        cx: odcx + odcw / 2.0,
                        cy: odcy + odch / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });

        //shape deletion functionality
        DC.mousedown(function () {
            var dccommand = LADS.TourAuthoring.Command({
                execute: function () {
                    elt.hide();
                    C1.hide();
                    C2.hide();
                    DC.hide();
                    elt.data(&quot;visible&quot;, &quot;no&quot;);
                },
                unexecute: function () {
                    elt.show();
                    C1.show();
                    C2.show();
                    DC.show();
                    elt.data(&quot;visible&quot;, &quot;yes&quot;);
                }
            });
            dccommand.execute();
            inkUndoManager.logCommand(dccommand);
        });
    }
    that.add_attributes = add_attributes;
    ///

    function getInkUndoManager() {
        return inkUndoManager;
    }
    that.getInkUndoManager = getInkUndoManager;

    ///

    /**
     * Add an ellipse to the Raphael canvas. Called by the &quot;Add Ellipse&quot; button in isolate/block ink mode
     * @param cx, cy    the coordinates of the center of the ellipse
     * @param rx, ry    the radii of the ellipse
     */
    function add_ellipse(cx, cy, rx, ry) {
        var ellipse;
        set_mode(LADS.TourAuthoring.InkMode.shapes);
        //console.log(&quot;setting cx and cy for the ellipse&quot;);
        if (cx === undefined)
            cx = 100 + Math.random() * 10;
        if (cy === undefined)
            cy = 100 + Math.random() * 10;
        if (rx === undefined)
            rx = 50;
        if (ry === undefined)
            ry = 50;
        ellipse = paper.ellipse(cx, cy, rx, ry); // draw to the canvas
        ellipse.data(&quot;currx&quot;, ellipse.getBBox().x); // add data to be used by add_attributes
        ellipse.data(&quot;curry&quot;, ellipse.getBBox().y);
        ellipse.data(&quot;curr_rx&quot;, rx);
        ellipse.data(&quot;curr_ry&quot;, ry);
        ellipse.data(&quot;type&quot;, &quot;ellipse&quot;);
        add_attributes(ellipse);
    }
    that.add_ellipse = add_ellipse;

    /**
     * DEPRECATED
     * Used to give style and drag functionality to old marquees (such as is currently in the Final
     * Garibaldi Demo). Once all old marquees have been deleted from tours, this method can be tossed.
     */
    function add_marq_attributes(marq, marqFillColor, marqFillOpacity) {
        /**
            * analogous to add_attributes(...), but for marquees. The difference is that a marquee
            * is a collection of five rectangles, and the center rectangle is the only one that gets
            * the drag handler, while the others have the color attributes.
            */
        var elt = marq.rc;
        var gl;
        var resize = 0; //if 1, we are in zoom mode rather than pan mode
        var noglow = 0; //if 1, glowing is disabled
        var origmousex;
        var origmousey;
        var w = domelement.width();
        var h = domelement.height();
        //console.log(&quot;w=&quot; + w + &quot;, h=&quot; + h);
        if (marqFillColor === undefined)
            marqFillColor = marqueeFillColor;////////FIX &quot;#&quot; + document.getElementById(&quot;marq_color&quot;).value;
        if (marqFillOpacity === undefined)
            marqFillOpacity = marqueeFillOpacity;/////FIX document.getElementById(&quot;marq_opacity&quot;).value;

        elt.mouseover(function () {
            if (!noglow &amp;&amp; (mode == 3)) {
                gl = elt.glow({ &quot;width&quot;: 10, &quot;color&quot;: &quot;#33ff00&quot;, &quot;opacity&quot;: 0.8 });
            }
        });
        elt.mouseout(function () {
            if (mode == 3)
                gl.remove();
        });
        elt.attr({
            &quot;stroke-width&quot;: 0,
            &quot;stroke&quot;: &quot;#222222&quot;,
            &quot;fill&quot;: &quot;#ffffff&quot;,
            &quot;fill-opacity&quot;: 0
        });
        elt.data(&quot;surr-fill&quot;, marqFillColor);
        elt.data(&quot;surr-opac&quot;, marqFillOpacity);
        var mset = paper.set();
        mset.push(marq.rn, marq.re, marq.rs, marq.rw);
        mset.attr({
            &quot;stroke-width&quot;: 0,
            &quot;stroke&quot;: &quot;#222222&quot;,
            &quot;fill&quot;: marqFillColor,
            &quot;fill-opacity&quot;: marqFillOpacity
        });

        //drag(move, start, stop,...)
        elt.drag(function (dx, dy, mousex, mousey) {
            //onmove
            if (mode == 3) {
                this.toFront();
                var bbox = this.getBBox();
                if (!resize) {
                    //drag an marquee -- need to update all relevant rectangles
                    var currx = parseInt(this.data(&quot;currx&quot;),10);//x position at the start of drag
                    var curry = parseInt(this.data(&quot;curry&quot;),10);
                    var xpos = currx + dx; //to get new x position, just add dx
                    var ypos = curry + dy;
                    this.attr({
                        x: xpos,
                        y: ypos
                    });
                    marq.rn.attr({
                        height: ypos
                    });
                    marq.re.attr({
                        x: xpos + bbox.width,
                        y: ypos,
                        width: w - (xpos + bbox.width),
                        height: bbox.height
                    });
                    marq.rs.attr({
                        y: ypos + bbox.height,
                        height: h - (ypos + bbox.height)
                    });
                    marq.rw.attr({
                        y: ypos,
                        width: xpos,
                        height: bbox.height
                    });

                }
                else {
                    //resize a marquee -- need to update all relevant rectangles
                    this.attr({
                        width: bbox.width + mousex - origmousex,
                        height: bbox.height + mousey - origmousey
                    });
                    marq.rs.attr({
                        y: bbox.y + bbox.height + mousey - origmousey,
                        height: h - (bbox.y + bbox.height + mousey - origmousey)
                    });
                    marq.re.attr({
                        x: bbox.x + bbox.width + mousex - origmousex,
                        width: w - (bbox.x + bbox.width + mousex - origmousex),
                        height: bbox.height + mousey - origmousey
                    });
                    marq.rw.attr({
                        height: bbox.height + mousey - origmousey
                    });
                }
                //console.log(&quot;this.attr.x = &quot; + this.attr(&quot;x&quot;) + &quot;, y = &quot; + this.attr(&quot;y&quot;));
                //console.log(update_datastring());
                origmousex = mousex;
                origmousey = mousey;
            }
        }, function (x, y) {
            //onstart
            if (mode == 3) {
                origmousex = x;
                origmousey = y;
                var bbox = this.getBBox();
                //console.log(&quot;diff = &quot; + (x - bbox.x));
                var offset_x = parseFloat(domelement.css(&quot;left&quot;));
                var offset_y = parseFloat(domelement.css(&quot;top&quot;));
                if ((arguments[2].offsetX &gt; (bbox.x + bbox.width * 0.5)) &amp;&amp; (arguments[2].offsetY &gt; (bbox.y + bbox.height * 0.5))) {
                    resize = 1;
                }
                gl.remove();
                noglow = 1;
                this.animate({ opacity: 0.25 }, 500, &quot;&lt;&gt;&quot;);
            }
        }, function () {
            //onstop
            if (mode == 3) {
                this.data(&quot;currx&quot;, this.getBBox().x); //reset data using bounding box coords
                this.data(&quot;curry&quot;, this.getBBox().y);
                marq.re.data(&quot;currx&quot;, this.getBBox().x + this.getBBox().width);
                marq.rs.data(&quot;curry&quot;, this.getBBox().y + this.getBBox().height);
                resize = 0;
                this.animate({ opacity: 1 }, 500, &quot;&lt;&gt;&quot;);
                noglow = 0;
            }
        });
    }
    that.add_marq_attributes = add_marq_attributes;

    /**
     * Add a rectangle to the Raphael canvas. Called by the &quot;Add Rectangle&quot; button in isolate/block ink mode
     * @param x, y    the coordinates of the top left corner of the rectangle
     */
    function add_rectangle(x, y) {
        var rect;
        set_mode(LADS.TourAuthoring.InkMode.shapes);
        if (x === undefined)
            x = 200 + Math.random() * 10;
        if (y === undefined)
            y = 200 + Math.random() * 10;
        rect = paper.rect(x, y, 100, 100); // draw to the Raphael canvas
        rect.data(&quot;currx&quot;, x); // set data to be used by add_attributes
        rect.data(&quot;curry&quot;, y);
        rect.data(&quot;currw&quot;, 100);
        rect.data(&quot;currh&quot;, 100);
        rect.data(&quot;type&quot;, &quot;rect&quot;);
        add_attributes(rect);
    }
    that.add_rectangle = add_rectangle;

    
    function getSVGText(){
        return svgText;
    }
    that.getSVGText = getSVGText;

    /** ((DAN Z))
     * Add a text box (a textarea html element) for creating text inks.
     * @param x, y     coordinates of the text box (absolute)
     * @param str      any text that should be loaded into the text box (i.e. for editing inks)
     */
    function add_text_box(x, y, w, h, str, textmag, size) {
        x = x || 75;
        y = y || 75;
        str = str || &quot;Your text here&quot;;

        svgText = paper.text(x, y, str);
        svgText.data({
            type: &quot;text&quot;,
            str: str,
        });
        svgText.attr({
            &#x27;alignment-baseline&#x27;: &#x27;before-edge&#x27;,
            &quot;text-anchor&quot;: &quot;start&quot;,
        });
        set_mode(LADS.TourAuthoring.InkMode.text);

        //// style the textbox
        //textbox.attr(&#x27;wrap&#x27;, &#x27;off&#x27;); //force people to do their own line breaks
        svgText.attr({
            &#x27;font-family&#x27;: fontFamily,
            &#x27;font-size&#x27;: fontSize,
            &#x27;fill&#x27;: fontColor,
        });
        svgText.attr(&quot;text&quot;, str);
        svgText.data({
            &#x27;font&#x27;: fontFamily,
            &#x27;fontsize&#x27;: fontSize,
            &#x27;color&#x27;: fontColor,
        });
        if (textmag) {
            var newFontSize;
            if (size) {
                newFontSize = size;
            } else {
                newFontSize = rel_dims(svgText.data(&quot;fontsize&quot;), domelement.height()) * domelement.height();
            }
            svgText.attr({
                &#x27;font-size&#x27;: newFontSize,
            });
            svgText.data({
                &#x27;fontsize&#x27;: newFontSize,
            });
        }
        setTextAttributes(svgText);

        //// set up undo/redo commands for typing
        //textbox.on(&quot;keyup&quot;, function (evt) { //use onpropertychange
        //    var code = evt.keyCode;
        //    if (code != 37 &amp;&amp; code != 38 &amp;&amp; code != 39 &amp;&amp; code != 40) { // exclude arrow keys
        //        var currText = $(&quot;#&quot; + textboxid).attr(&#x27;value&#x27;);
        //        var oldText = lastText;
        //        var command = LADS.TourAuthoring.Command({
        //            execute: function () {
        //                $(&quot;#&quot; + textboxid).attr(&#x27;value&#x27;, currText);
        //            },
        //            unexecute: function () {
        //                $(&quot;#&quot; + textboxid).attr(&#x27;value&#x27;, oldText);
        //            }
        //        });
        //        inkUndoManager.logCommand(command);
        //        lastText = $(&quot;#&quot; + textboxid).attr(&quot;value&quot;);
        //    }
        //});

        //setTextAttributes($(&quot;#&quot; + textboxid)); // set up drag functionality and drag handlers

        //textbox.scrollTop(0);
        //textbox.scrollLeft(0);
    }
    that.add_text_box = add_text_box;

    /** ((BEN L))
     * Pans and resizes all inks to move with the artwork. Uses the initial keyframe of the artwork (converted here to absolute coordinates) and the
     * inputted dimensions to compute deltas and scale factors. Once we have these, first pan to (0,0), then scale, then pan to pos+deltas.
     * @param dims   the current dimensions of our artwork in absolute coordinates
     */
    function adjustViewBox (dims, no_opac_check) {
        var new_px = dims.x,
            new_py = dims.y,
            new_pw = dims.width,
            new_ph = dims.height,
            real_kfw, real_kfh, real_kfx, real_kfy;
        // convert weird deeepzoom keyframe coordinates to absolute coordinates
        real_kfw = origPaperW / initKeyframe.w; // deepzoom keyframe width is what we multiply the absolute width of art by to get width of viewer
        real_kfh = real_kfw * (new_ph / new_pw); // deepzoom keyframe height is kind of confusing, so use width * (1 / aspect_ratio of art)
        real_kfx = -initKeyframe.x * real_kfw; // deepzoom keyframe x times absolute width of art is what we must translate art by to reach the left of viewer
        real_kfy = -initKeyframe.y * real_kfw; // (WEIRD -- seems to place too high if use -kfy * real_kfh)
        
        // if the new position is not trivially different from the old position, pan and zoom
        if (nontrivial({ x: new_px, y: new_py, w: new_pw, h: new_ph }, { x: lastpx, y: lastpy, w: lastpw, h: lastph })) {
            //var eid_elt = $(&quot;[ES_ID=&#x27;&quot; + EID + &quot;&#x27;]&quot;);
            var lambda_w = origPaperW / real_kfw;
            var lambda_h = origPaperH / real_kfh;
            var nvw = new_pw * lambda_w; // nv*: dimensions of the new virtual canvas (where the ink canvas would be if we were panning and zooming it with the artwork)
            var nvh = new_ph * lambda_h;
            var nvx = (nvw / origPaperW) * (origPaperX - real_kfx) + new_px;
            var nvy = (nvh / origPaperH) * (origPaperY - real_kfy) + new_py;

            var SW = nvw / lastcw; // scale factor in x direction
            // var SH = nvh / lastch; // scale factor in y direction (in case we ever have non-aspect-ratio-preserving scaling)

            oldScale = new_pw / origpw;
            // oldScaleH = new_ph / origph; // in case we ever have non-aspect-ratio-preserving scaling

            if (!transCoords.length || trans_mode === &#x27;block&#x27;) { // for all ink types except isolates (can&#x27;t just resize the window for them)
                var newwid = origPaperW / oldScale;
                var newhei = origPaperH / oldScale;
                paper.setViewBox(-nvx / oldScale, -nvy / oldScale, newwid, newhei); // see raphael documentation
            }
            else {
                var cw = domelement.width();
                var ch = domelement.height();
                magX = cw;
                magY = ch;
                panObjects(-lastcx / origPaperW, -lastcy / origPaperH, { cw: cw, ch: ch }, 0); // no need to draw updated ink yet
                resizeObjects(SW, SW); // still no need, since we still have to pan
                panObjects(nvx / origPaperW, nvy / origPaperH, { cw: cw, ch: ch }, 1);
            }

            // reset coordinates
            lastcx = nvx;
            lastcy = nvy;
            lastcw = nvw;
            lastch = nvh;
            lastpx = new_px;
            lastpy = new_py;
            lastpw = new_pw;
            lastph = new_ph;
        }
    }
    that.adjustViewBox = adjustViewBox;

    /** ((BEN L))
     * Pans and resizes the ink canvas to move with the artwork. Uses the initial keyframe of the artwork (converted here to absolute coordinates) and the
     * inputted dimensions to compute deltas and scale factors. Once we have these, first pan to (0,0), then scale, then pan to pos+deltas.
     * @param dims   the current dimensions of our artwork in absolute coordinates
     */
    function adjustViewBoxDiv(dims, no_opac_check) {
        var new_px = dims.x,
            new_py = dims.y,
            new_pw = dims.width,
            new_ph = dims.height,
            real_kfw, real_kfh, real_kfx, real_kfy;
        try {
            // convert weird deeepzoom keyframe coordinates to absolute coordinates
            real_kfw = origPaperW / initKeyframe.w; // deepzoom keyframe width is what we multiply the absolute width of art by to get width of viewer
            real_kfh = real_kfw * (new_ph / new_pw); // deepzoom keyframe height is kind of confusing, so use width * (1 / aspect_ratio of art)
            real_kfx = -initKeyframe.x * real_kfw; // deepzoom keyframe x times absolute width of art is what we must translate art by to reach the left of viewer
            real_kfy = -initKeyframe.y * real_kfw; // (WEIRD -- seems to place too high if use -kfy * real_kfh)
        }
        catch (err) {
            console.log(&quot;ERROR in adjustViewBox: &quot; + err);
            real_kfx = origpx;
            real_kfy = origpy;
            real_kfw = origpw;
            real_kfh = origph;
        }

        // oldOpac tracks when the ink is actually on screen (the opacity of the ink track is 0 when the playhead is not in a display)
        if (oldOpac === 0) {
            self.origpx = new_px;
            self.origpy = new_py;
            self.origpw = new_pw;
            self.origph = new_ph;
        }

        // if the new position is not trivially different from the old position, pan and zoom
        if (nontrivial({ x: new_px, y: new_py, w: new_pw, h: new_ph }, { x: lastpx, y: lastpy, w: lastpw, h: lastph })) {
            var eid_elt = $(&quot;[ES_ID=&#x27;&quot; + EID + &quot;&#x27;]&quot;);
            var lambda_w = origPaperW / real_kfw;
            var lambda_h = origPaperH / real_kfh;
            var nvw = new_pw * lambda_w; // new dimensions of the virtual canvas
            var nvh = new_ph * lambda_h;
            var nvx = (nvw / origPaperW) * (origPaperX - real_kfx) + new_px;
            var nvy = (nvh / origPaperH) * (origPaperY - real_kfy) + new_py;

            var SW = nvw / lastcw; // scale factor in x direction
            var SH = nvh / lastch; // scale factor in y direction (in case we ever have non-aspect-ratio-preserving scaling)

            var cw = domelement.width();
            var ch = domelement.height();

            // translate to (0,0), scale by (SW,SH), translate to (nvx,nvy)
            // in panning, we divide by the width of the paper because all coordinates are in [0,1]
            panObjects(-lastcx / origPaperW, -lastcy / origPaperH, { cw: cw, ch: ch }, 0); // no need to draw updated ink yet
            resizeObjects(SW, SH); // still no need, since we still have to pan
            panObjects(nvx / origPaperW, nvy / origPaperH, { cw: cw, ch: ch }, 1);//no_opac_check || parseFloat(eid_elt[0].style.opacity));
            //if (true || parseFloat(eid_elt[0].style.opacity)) { // only draw if the ink is on screen or if we&#x27;re on the initial load
            //    panObjects(nvx / origPaperW, nvy / origPaperH);
            //    console.log(&quot;DRAWING&quot;);
            //}
            //else {
            //    panObjects(nvx / origPaperW, nvy / origPaperH, &#x27;do not draw&#x27;);
            //    console.log(&quot;NOT DRAWING&quot;);
            //}

            // reset coordinates
            lastcx = nvx;
            lastcy = nvy;
            lastcw = nvw;
            lastch = nvh;
            lastpx = new_px;
            lastpy = new_py;
            lastpw = new_pw;
            lastph = new_ph;

            var new_opac;
            try {
                new_opac = parseInt(no_opac_check || eid_elt[0].style.opacity,10);
            }
            catch (err) {
                console.log(&quot;error in adjustViewBox: &quot; + err);
            }
            oldOpac = new_opac;
        }
    }
    that.adjustViewBoxDiv = adjustViewBoxDiv;

    /**
     * Convert a string representing a block transparency to one representing an isolate transparency.
     * Block/isolate is determined by the fill property of the svg element. If we draw the path counterclockwise (rather than clockwise)
     * and also draw a path around the whole canvas, the in-between space will be filled and we will get an isolate transparency. This
     * method reverses the given path and adds the aforementioned outer path.
     * @param pth    the path to reverse
     * @return    reversed path (with outer path)
     */
    function block_to_isol(pth) {
        var new_pth = &quot;&quot;;
        var segs = [&quot;&quot;];
        var parsed_pth = Raphael.parsePathString(pth);
        var num_array = [];
        var ctr = 0;
        var cw = viewerElt.width();
        var ch = viewerElt.height();
        var j;

        // iterate through in reverse order
        for (var i = parsed_pth.length - 2; i &gt;= 0; i--) {
            if (parsed_pth[i][0] == &quot;z&quot;) {
                new_pth += &quot;M&quot; + num_array[0] + &quot;,&quot; + num_array[1];
                for (j = 2; j &lt; num_array.length; j++) {
                    new_pth += ((j % 6 == 2) ? (&quot;C&quot; + num_array[j]) : (num_array[j]));
                    new_pth += ((j % 6 != 1) ? (&quot;,&quot;) : &quot;&quot;);
                }
                new_pth += &quot;z&quot;;
                num_array.length = 0;
                num_array = []; // every time we hit a close-path command (&#x27;z&#x27;), restart num_array for new path
            }
            else if (parsed_pth[i][0] == &quot;M&quot;) {
                num_array.push(parsed_pth[i][1]);
                num_array.push(parsed_pth[i][2]);
            }
            else {
                num_array.push(parsed_pth[i][5]);
                num_array.push(parsed_pth[i][6]);
                num_array.push(parsed_pth[i][3]);
                num_array.push(parsed_pth[i][4]);
                num_array.push(parsed_pth[i][1]);
                num_array.push(parsed_pth[i][2]);
            }
        }

        // manually add the last path, since there is no &#x27;z&#x27; at the start of our pathstring
        new_pth += &quot;M&quot; + num_array[0] + &quot;,&quot; + num_array[1];
        for (j = 2; j &lt; num_array.length; j++) {
            new_pth += ((j % 6 == 2) ? (&quot;C&quot; + num_array[j]) : (num_array[j]));
            new_pth += ((j % 6 != 1) ? (&quot;,&quot;) : &quot;&quot;);
        }
        new_pth += &quot;z&quot;;
        new_pth += &quot;M-5,-5L&quot; + (cw + 5) + &quot;,-5L&quot; + (cw + 5) + &quot;,&quot; + (ch + 5) + &quot;L-5,&quot; + (ch + 5) + &quot;L-5,-5z&quot;; // outer path
        return new_pth;
    }
    that.block_to_isol = block_to_isol;

    /**
     * Construct the path that models the overlap between new_path and existing_path in the appropriate
     * transparency mode. For example, if the paths are intersecting circles, const_path_alg returns the
     * outline of the two; if one path is completely inside the other, the inner one is returned in isolate
     * mode and the outer is returned in block mode. Both input paths are closed (have a trailing &#x27;z&#x27;).
     * @param new_path        one path
     * @param existing_path   another path (in the scheme of things, we are building this path up by adding new_paths)
     */
    function const_path_alg(new_path, existing_path) {
        // array of points in the order they are added, format: {point: {x: __, y: __}, type: &#x27;endpoint&#x27;/&#x27;intpoint&#x27;, path: 0/1}  (0 if on new_path, 1 if on existing_path)
        var order_added = [];
        var i, j, pth_seg, next_seg, pth_seg_len;

        var first_point_added = 0;
        if (existing_path === &quot;&quot;) // if the existing path is empty, new path should replace it
            return new_path;

        // get array of vertices for the new path
        var parsed_new_path = Raphael.parsePathString(new_path);
        for (i = 0; i &lt; parsed_new_path.length; i++) {
            if (parsed_new_path[i][0] == &quot;z&quot;) {
                parsed_new_path.splice(i, 1); // don&#x27;t want the trailing &#x27;z&#x27;s
                i--;
            }
        }

        // get array of vertices for the old path
        var parsed_old_path = Raphael.parsePathString(existing_path);
        var old_nz = 0;
        for (i = 0; i &lt; parsed_old_path.length; i++) {
            if (parsed_old_path[i][0] == &quot;z&quot;) {
                parsed_old_path.splice(i, 1); // don&#x27;t want the trailing &#x27;z&#x27;s
                i--;
                old_nz++;
            }
        }

        // get array of startpoints for the new path, including bezier coordinates out of the point (ax1, ay1) and into the next point (ax2, ay2)
        var new_path_startpoints = [];
        for (i = 0; i &lt; parsed_new_path.length - 1; i++) {
            pth_seg = parsed_new_path[i];
            next_seg = parsed_new_path[(i + 1) % parsed_new_path.length];
            pth_seg_len = pth_seg.length;
            new_path_startpoints.push({ x: pth_seg[pth_seg_len - 2], y: pth_seg[pth_seg_len - 1], ax1: next_seg[1], ay1: next_seg[2], ax2: next_seg[3], ay2: next_seg[4] });
        }

        // get array of endpoints for the oldpath, including bezier coordinates as above
        var old_path_endpoints = [];
        for (i = 0; i &lt; parsed_old_path.length - 1; i++) {
            pth_seg = parsed_old_path[(i + 1) % parsed_old_path.length];
            var ind2 = ((i + 2) % parsed_old_path.length !== 0) ? ((i + 2) % parsed_old_path.length) : 1;
            next_seg = parsed_old_path[ind2];
            pth_seg_len = pth_seg.length;
            old_path_endpoints.push({ x: pth_seg[pth_seg_len - 2], y: pth_seg[pth_seg_len - 1], ax1: next_seg[1], ay1: next_seg[2], ax2: next_seg[3], ay2: next_seg[4] });
        }

        // see if any of our endpoints are the same or are colinear; if they are, perturb one by a slight amount
        var perturbed = 0;
        for (i = 0; i &lt; new_path_startpoints.length; i++) {
            for (j = 0; j &lt; old_path_endpoints.length; j++) {
                if (same_point(new_path_startpoints[i], old_path_endpoints[j])) {
                    new_path_startpoints[i].x += 1;
                    new_path_startpoints[i].y += 1;
                    new_path_startpoints[i].ax1 += 1;
                    new_path_startpoints[i].ay1 += 1;
                    new_path_startpoints[i].ax2 += 1;
                    new_path_startpoints[i].ay2 += 1;
                    perturbed = 1;
                    break;
                }
            }
        }

        // if we perturbed any points above, we need to reset the string in new_path and reparse to get parsed_new_path
        if (perturbed) {
            new_path = &quot;M&quot; + new_path_startpoints[0].x + &quot;,&quot; + new_path_startpoints[0].y;
            var nps;
            for (i = 1; i &lt; new_path_startpoints.length; i++) {
                nps = new_path_startpoints[i];
                var prev = new_path_startpoints[i - 1];
                new_path += &quot;C&quot; + prev.ax1 + &quot;,&quot; + prev.ay1 + &quot;,&quot; + prev.ax2 + &quot;,&quot; + prev.ay2 + &quot;,&quot; + nps.x + &quot;,&quot; + nps.y;
            }
            new_path += &quot;C&quot; + nps.ax1 + &quot;,&quot; + nps.ay1 + &quot;,&quot; + nps.ax2 + &quot;,&quot; + nps.ay2 + &quot;,&quot; + new_path_startpoints[0].x + &quot;,&quot; + new_path_startpoints[0].y;
            new_path += &quot;z&quot;;
            parsed_new_path = Raphael.parsePathString(new_path);
            for (i = 0; i &lt; parsed_new_path.length; i++) {
                if (parsed_new_path[i][0] == &quot;z&quot;) {
                    parsed_new_path.splice(i, 1);
                    i--;
                }
            }
        }

        // get the array of intersection points of the two paths
        var ints = Raphael.pathIntersection(new_path, existing_path);
        var seg_ints = [[], [], [], []]; // for intersections along each segment of the new path (4 segments)
        for (i = 0; i &lt; ints.length; i++)
            seg_ints[ints[i].segment1 - 1].push(ints[i]); // segments are 1-indexed

        // sort each segment&#x27;s intersections in order of increasing t-value (i.e. distance along the segment)
        function sortHelperT1(a, b) { return a.t1 - b.t1; }
        for (i = 0; i &lt; seg_ints.length; i++)
            seg_ints[i].sort(sortHelperT1); // sort by t-value (t1 is the t-value of the int on the new path)


        var old_seg_ints = []; // for intersections along each segment of the old path
        for (i = 0; i &lt; parsed_old_path.length - old_nz; i++)
            old_seg_ints.push([]);

        for (i = 0; i &lt; ints.length; i++)
            old_seg_ints[ints[i].segment2 - 1].push(ints[i]);

        // sort each segment&#x27;s intersections in order of increasing t2-value (maybe unnecessary)
        function sortHelperT2(a, b) { return a.t2 - b.t2; }
        for (i = 0; i &lt; old_seg_ints.length; i++) {
            old_seg_ints[i].sort(sortHelperT2);
        }

        var outer_path = &quot;&quot;;

        if (ints.length === 0) //if no intersections, the paths are disjoint and one may be contained in the other
        {
            if (point_inside(new_path, old_path_endpoints[0].x, old_path_endpoints[0].y))
                return ((trans_mode === &#x27;isolate&#x27;) ? existing_path : new_path); // existing_path is inside new_path
            if (point_inside(existing_path, new_path_startpoints[0].x, new_path_startpoints[1].y))
                return ((trans_mode === &#x27;isolate&#x27;) ? new_path : existing_path); // new_path is inside existing_path
            return new_path + existing_path; // paths are disjoint and neither is inside the other
        }

        // iterate through the segments of new_path
        // for each segment, add the start point if it is outside existing_path, add each intersection point, and after adding intersection points, check to see if we should add any endpoints of existing_path
        for (i = 0; i &lt; seg_ints.length; i++) {
            // add start point if outside existing_path
            if (!point_inside(existing_path, new_path_startpoints[i].x, new_path_startpoints[i].y) &amp;&amp; !repeat_pt(new_path_startpoints[i], order_added)) {
                if (i === 0)
                    first_point_added = 1;
                order_added.push({ point: new_path_startpoints[i], type: &quot;endpoint&quot;, path: 0 }); // add point to order_added if it should be in the final path
            }
            var curr_ints = seg_ints[i]; // array of intersection points on the current segment of new_path
            for (j = 0; j &lt; curr_ints.length; j++) {
                if (!repeat_pt(curr_ints[j], order_added)) {
                    // need to find which curve the previously added point is from in order to get the right bezier coordinates
                    order_added.push({ point: curr_ints[j], type: &quot;intpoint&quot;, path: ((order_added.length) ? (order_added[order_added.length - 1].type) : 0) });
                }
                var old_seg_num = curr_ints[j].segment2 - 1; // index of int point in old_seg_ints
                var k = old_seg_num;
                var index = k;

                // iterate through old path endpoints, adding them if they are outside new_path, stopping when we hit a repeat or a point inside new_path
                while (!point_inside(new_path, old_path_endpoints[index].x, old_path_endpoints[index].y) &amp;&amp; !repeat_pt(old_path_endpoints, order_added)) {
                    var pt1 = old_path_endpoints[index];
                    var test1 = 1;
                    var test2 = 1;
                    if (index == old_seg_num) { // still on segment of existing_path that the original intersection point was on
                        // check here if there is another intersection point farther along the current segment in the existing path (so we shouldn&#x27;t add the next endpoint of existing_path)
                        for (var l = 0; l &lt; old_seg_ints[index].length; l++) {
                            if (old_seg_ints[index][l].t2 &gt; curr_ints[j].t2) {
                                test1 = 0;
                                break;
                            }
                        }
                    }
                    else {
                        // otherwise, we just want to make sure that there are no intersection points along the segment whose endpoint is pt1
                        if (old_seg_ints[index].length &gt; 0)
                            test2 = 0;
                    }
                    if (!test1 || !test2 || repeat_pt(pt1, order_added))
                        break;

                    // if we&#x27;re here, we should add the endpoint pt1 to order_added (with path: 1, since it&#x27;s on the old path)
                    order_added.push({ point: old_path_endpoints[index], type: &quot;endpoint&quot;, path: 1 });
                    k++;
                    index = k % (old_seg_ints.length); // wrap around to first point if necessary
                }
            }
        }
        if (!point_inside(existing_path, new_path_startpoints[0].x, new_path_startpoints[0].y)) {
            order_added.push({ point: new_path_startpoints[0], type: &quot;endpoint&quot;, path: 0 }); // if first startpoint is outside existing_path, add it again to close the path
        }
        if (!same_point(order_added[order_added.length - 1].point, order_added[0].point)) {
            order_added.push(order_added[0]); // close path if need be
        }

        // build up outer_path using order_added
        var final_list = [];
        var pt;
        for (i = 0; i &lt; order_added.length - 1; i++) {
            pt = order_added[i];
            var next = order_added[(i + 1) % order_added.length];
            var ob = out_bez(pt, next);
            var ib = next_in_bez(pt, next);
            final_list.push({ ax1: ob.x, ay1: ob.y, ax2: ib.x, ay2: ib.y, x: next.point.x, y: next.point.y }); // push each point along with outgoing bezier coordinates (and incoming for the next point)
        }

        // take points in final_list and build the path string
        outer_path = &quot;M&quot; + final_list[final_list.length - 1].x + &quot;,&quot; + final_list[final_list.length - 1].y;
        for (i = 0; i &lt; final_list.length; i++) {
            pt = final_list[i];
            outer_path += &quot;C&quot; + pt.ax1 + &quot;,&quot; + pt.ay1 + &quot;,&quot; + pt.ax2 + &quot;,&quot; + pt.ay2 + &quot;,&quot; + pt.x + &quot;,&quot; + pt.y;
        }
        outer_path += &quot;z&quot;;
        return outer_path;
    }
    that.const_path_alg = const_path_alg;

    /**
     * Uses the arrays ml, xy, and pa to draw paths with the correct properties.
     * First clears the canvas of existing paths, then draws new ones.
     */
    function drawPaths() {
        var cw = viewerElt.width();
        var ch = viewerElt.height();
        var paths = &quot;&quot;;
        var cpaths = &quot;&quot;;
        var i;
        var len = pathObjects.length;
        for (i = 0; i &lt; len; i++) { //removes paths from canvas
            pathObjects[i].remove();
        }
        pathObjects.length = 0;
        for (i = 0; i &lt; ml.length; i++) { //construct the paths
            if (ml[i] === &#x27;M&#x27;) {
                paths += &quot;PATH::[pathstring]&quot;; // the paths to be drawn now
                cpaths += &quot;PATH::[pathstring]&quot;; // the paths we will save for our datastring (in relative coordinates)
            }
            paths += ml[i] + (cw * xy[i][0]) + &#x27;,&#x27; + (ch * xy[i][1]); // absolute coords
            cpaths += ml[i] + (xy[i][0]) + &#x27;,&#x27; + (xy[i][1]); // relative coords
            if (ml[i + 1] != &#x27;L&#x27;) {
                // if we&#x27;re here, we&#x27;ve reached the end of a path, so add style information to the path strings
                paths += &quot;[stroke]&quot; + pa[i].color + &quot;[strokeo]&quot; + pa[i].opacity + &quot;[strokew]&quot; + (ch * pa[i].width) + &quot;[]|&quot;;
                cpaths += &quot;[stroke]&quot; + pa[i].color + &quot;[strokeo]&quot; + pa[i].opacity + &quot;[strokew]&quot; + pa[i].width + &quot;[]|&quot;;
            }
        }
        var path = [];
        if (paths.length &gt; 0) {
            path = paths.split(&#x27;PATH::&#x27;);
        }
        for (i = 1; i &lt; path.length; i++) {
            var pstring = get_attr(path[i], &quot;pathstring&quot;, &quot;s&quot;);
            var strokec = get_attr(path[i], &quot;stroke&quot;, &quot;s&quot;);
            var strokeo = get_attr(path[i], &quot;strokeo&quot;, &quot;f&quot;);
            var strokew = get_attr(path[i], &quot;strokew&quot;, &quot;f&quot;);
            var drawing = paper.path(pstring); // draw the path to the canvas
            drawing.data(&quot;type&quot;, &quot;path&quot;);
            drawing.attr({
                &quot;stroke-width&quot;: strokew,
                &quot;stroke-opacity&quot;: strokeo,
                &quot;stroke&quot;: strokec,
                &quot;stroke-linejoin&quot;: &quot;round&quot;,
                &quot;stroke-linecap&quot;: &quot;round&quot;
            });
            pathObjects.push(drawing);
        }
        currpaths = cpaths; // currpaths is used in update_datastring as the string representing all paths on the canvas
        //update_datastring();
    }
    that.drawPaths = drawPaths;

    /**
     * A helper function to draw transparencies. Takes the arrays transLetters (representing the
     * svg path commands in the transparency string) and transCoords (corresponding locations on the
     * canvas in relative coordinates) and draws the appropriate type of transparency to the canvas.
     * If the type is &#x27;isolate,&#x27; calls block_to_isol, which reverses the path and adds an outer path
     * around the canvas to fill the in-between space.
     */
    function drawTrans() {
        remove_all(); // be careful that this method isn&#x27;t called unless the type of the ink is &#x27;trans&#x27;!
        var cw = domelement.width();
        var ch = domelement.height();
        var path = &quot;&quot;;
        var ind = 0;
        // iterate through the transLetters array and create our svg path accordingly
        for (var i = 0; i &lt; transLetters.length; i++) {
            if (transLetters[i] == &quot;M&quot; || transLetters[i] == &quot;L&quot;) { // if M or L, add next two coords to the path
                path += transLetters[i] + (transCoords[ind] * cw) + &quot;,&quot; + (transCoords[ind + 1] * ch);
                ind += 2;
            }
            else if (transLetters[i] == &quot;C&quot;) {
                path += &quot;C&quot; + (transCoords[ind] * cw);
                for (var k = 1; k &lt; 6; k++) { // if C, add next six coords to the path (coords represent bezier curve)
                    path += &quot;,&quot; + ((k % 2) ? (transCoords[ind + k] * ch) : (transCoords[ind + k] * cw));
                }
                ind += 6;
            }
            else if (transLetters[i] == &quot;z&quot;) // if z, close the path
                path += &quot;z&quot;;
            else
                console.log(&quot;ELSE: &quot; + transLetters[i]);
        }
        var final_path = path;
        if (trans_mode == &#x27;isolate&#x27;) // if the mode is &#x27;isolate,&#x27; reverse the path and add an outer path
            final_path = block_to_isol(path);
        var trans = paper.path(final_path).attr({ &quot;fill&quot;: marqueeFillColor, &quot;fill-opacity&quot;: marqueeFillOpacity, &quot;stroke-width&quot;: 0 }).data(&quot;type&quot;, &quot;trans&quot;);
        trans_currpath = &quot;TRANS::[path]&quot; + path + &quot;[color]&quot; + marqueeFillColor + &quot;[opac]&quot; + marqueeFillOpacity + &quot;[mode]&quot; + trans_mode + &quot;[]&quot;;
        update_datastring();
    }
    that.drawTrans = drawTrans;

    /**
     * Called if we drag on the ink canvas in eraser mode. Finds endpoints in the current paths close
     * to the drag event location and splices them out of the path array.
     * @param location   the locaton of the drag event
     */
    function erase(location) {
        var cw = domelement.width();
        var ch = domelement.height();
        var range = eraserWidth;
        for (var i = 0; i &lt; xy.length; i++) { // for each coordinate, test for proximity to location
            if (location[0] - range &lt;= (cw * xy[i][0]) &amp;&amp; (cw * xy[i][0]) &lt;= location[0] + range) {
                if (location[1] - range &lt;= (ch * xy[i][1]) &amp;&amp; (ch * xy[i][1]) &lt;= location[1] + range) {
                    if (ml[i + 1] === &#x27;L&#x27;) { // if we splice in the middle of a path, split into two paths
                        ml[i + 1] = &#x27;M&#x27;;
                    }
                    ml.splice(i, 1);
                    xy.splice(i, 1);
                    pa.splice(i, 1);
                }
            }
        }
        var check = false;
        for (var j = 0; j &lt; ml.length; j++) {
            if (ml[j] === &quot;L&quot;) {
                check = true;
                break;
            }
        }
        if (!check) {
            xy.length = 0;
            ml.length = 0;
            pa.length = 0;
        }
        drawPaths(); // after we&#x27;re done splicing, redraw the paths
    }
    that.erase = erase;

    /**
     * Takes in a datastring and parses for a certain attribute by splitting at &quot;[&quot; and &quot;]&quot; (these surround
     * attribute names).
     * NOTE if errors are coming from this function, could be that the datastring is empty...
     * @param str        the datastring
     * @param attr       the attribute we&#x27;ll parse for
     * @param parsetype  &#x27;i&#x27; (int), &#x27;s&#x27; (string), or &#x27;f&#x27; (float)
     * @return  the value of the attribute in the correct format
     */
    function get_attr(str, attr, parsetype) {
        if(parsetype === &quot;f&quot;)
            return parseFloat(str.split(&quot;[&quot; + attr + &quot;]&quot;)[1].split(&quot;[&quot;)[0]);
        if (parsetype === &quot;s&quot;)
            return str.split(&quot;[&quot; + attr + &quot;]&quot;)[1].split(&quot;[&quot;)[0];
        else
            return parseInt(str.split(&quot;[&quot; + attr + &quot;]&quot;)[1].split(&quot;[&quot;)[0],10);
    }
    that.get_attr = get_attr;

    function set_attr(attr, newval) {
        var arrs = datastring.split(&quot;[&quot; + attr + &quot;]&quot;);
        var arr2 = arrs[1].split(&quot;]&quot;);
        arr2.splice(0, 1);
        arr2[0] = &quot;[color]&quot;+arr2[0];
        var str2 = arr2.join(&quot;]&quot;);
        datastring = arrs[0] + &quot;[fontsize]&quot; + newval + str2;
    }
    that.set_attr = set_attr;
    
    /**
     * Returns the isolate/block bounding shapes.
     */
    function getBoundingShapes() {
        return bounding_shapes;
    }
    that.getBoundingShapes = getBoundingShapes;

    /**
     * Returns the current datastring.
     */
    function getDatastring() {
        return datastring;
    }
    that.getDatastring = getDatastring;

    /**
     * Uses path data representing ellipses and rectangles to get the path representing the ultimate block
     * or isolate shape.
     * @param paths     array of path strings representing ellipses/rects
     */
    function get_outer_path(paths) {
        var cw = domelement.width();
        var ch = domelement.height();
        var cumulative_path = &quot;&quot;;
        for (var i = 0; i &lt; paths.length; i++) {
            paths[i] = transform_pathstring_marq(paths[i], cw, ch); // transform each to absolute coords
            paths[i] = (paths[i][paths[i].length - 1] === &quot;z&quot;) ? paths[i] : (paths[i] + &quot;z&quot;); // make sure each is closed
        }
        while (paths.length) {
            // take the first path, loop through the list, calling const_path_alg on any that intersect, then add to cumulative_path
            var outer_path = paths[0];
            paths.splice(0, 1);
            if (paths.length) {
                var parsed = Raphael.parsePathString(outer_path); // parses outer_path as a list of objects containing path data
                for (var j = 0; j &lt; paths.length; j++) {
                    var jparsed = Raphael.parsePathString(paths[j]);
                    // the next line checks if paths[j] and outerpath intersect, or if one is completely inside the other
                    if (Raphael.pathIntersection(outer_path, paths[j]).length || point_inside(outer_path, jparsed[0][1], jparsed[0][2]) || point_inside(paths[j], parsed[0][1], parsed[0][2])) {
                        outer_path = const_path_alg(paths[j], outer_path);
                        paths.splice(j, 1);
                        j = -1; //if we have an intersection, another, previously non-intersecting path might now intersect, so reset j (we spliced out the current j, so no repeats)
                    }
                }
            }
            cumulative_path += outer_path;
        }
        // finally, load the resulting cumulative path onto the canvas
        load_trans_from_path(cumulative_path);
    }
    that.get_outer_path = get_outer_path;

    /**
     * Helper function to get artwork&#x27;s relative coordinates within the viewer.
     * @return    an object containing relative coordinates x, y, w, h
     */
    function getArtRelativePos(proxy, cw, ch) {
        return { x: proxy.x / cw, y: proxy.y / ch, w: proxy.w / cw, h: proxy.h / ch };
    }
    that.getArtRelativePos = getArtRelativePos;

    /**
     * Helper function to get the svg element created by Raphael.
     */
    function getSVGElement() {
        return domelement.find(&quot;svg&quot;)[0];
    }
    that.getSVGElement = getSVGElement;

    /**
     * Searches the current datastring for ellipses and rectangles, stores their information in bounding_shapes.
     * Also stores their coordinates and types in an array shapes and calls shapes_to_paths on shapes
     * to transform them to path format.
     */
    function get_trans_shape_data () {
        var datastr = update_datastring();
        var shapes = [];
        var cw = domelement.width();
        var ch = domelement.height();
        if (datastr === &quot;&quot;) {
            //console.log(&quot;no elements to attach&quot;);
            return;
        }
        var shapes2 = datastr.split(&quot;|&quot;);
        for (var i = 0; i &lt; shapes2.length; i++) {
            var shape2 = shapes2[i];
            var type = shape2.split(&quot;::&quot;)[0];
            type = type.toLowerCase();
            switch (type) {
                case &quot;lrect&quot;:
                case &quot;mrect&quot;:
                case &quot;rect&quot;:
                    // rectangle format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                    var x = abs_dims(get_attr(shape2, &quot;x&quot;, &quot;f&quot;), cw);
                    var y = abs_dims(get_attr(shape2, &quot;y&quot;, &quot;f&quot;), ch);
                    var w = abs_dims(get_attr(shape2, &quot;w&quot;, &quot;f&quot;), cw);
                    var h = abs_dims(get_attr(shape2, &quot;h&quot;, &quot;f&quot;), ch);
                    var R = { &quot;X&quot;: x, &quot;Y&quot;: y, &quot;w&quot;: w, &quot;h&quot;: h, &quot;type&quot;: &quot;rect&quot; };
                    bounding_shapes += &quot;BOUNDRECT::[x]&quot; + (x / cw) + &quot;[y]&quot; + (y / ch) + &quot;[w]&quot; + (w / cw) + &quot;[h]&quot; + (h / ch) + &quot;[fillc]#000000[fillo]0[strokec]&quot; + get_attr(shape2, &quot;strokec&quot;, &#x27;s&#x27;) + &quot;[strokeo]&quot; + get_attr(shape2, &quot;strokeo&quot;, &#x27;f&#x27;) + &quot;[strokew]&quot; + get_attr(shape2, &quot;strokew&quot;, &#x27;f&#x27;) + &quot;[]|&quot;;
                    shapes.push(R);
                    break;
                case &quot;lellipse&quot;:
                case &quot;mellipse&quot;:
                case &quot;ellipse&quot;:
                    // ellipse format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                    var cx = abs_dims(get_attr(shape2, &quot;cx&quot;, &quot;f&quot;), cw); // center x
                    var cy = abs_dims(get_attr(shape2, &quot;cy&quot;, &quot;f&quot;), ch); // center y
                    var rx = abs_dims(get_attr(shape2, &quot;rx&quot;, &quot;f&quot;), cw); // x-radius
                    var ry = abs_dims(get_attr(shape2, &quot;ry&quot;, &quot;f&quot;), ch); // y-radius
                    var E = { &quot;cx&quot;: cx, &quot;cy&quot;: cy, &quot;rx&quot;: rx, &quot;ry&quot;: ry, &quot;type&quot;: &quot;ellipse&quot; };
                    bounding_shapes += &quot;BOUNDELLIPSE::[cx]&quot; + (cx / cw) + &quot;[cy]&quot; + (cy / ch) + &quot;[rx]&quot; + (rx / cw) + &quot;[ry]&quot; + (ry / ch) + &quot;[fillc]#000000[fillo]0[strokec]&quot; + get_attr(shape2, &quot;strokec&quot;, &#x27;s&#x27;) + &quot;[strokeo]&quot; + get_attr(shape2, &quot;strokeo&quot;, &#x27;f&#x27;) + &quot;[strokew]&quot; + get_attr(shape2, &quot;strokew&quot;, &#x27;f&#x27;) + &quot;[]|&quot;;
                    shapes.push(E);
                    break;
            }
        }
        shapes_to_paths(shapes);
    }
    that.get_trans_shape_data = get_trans_shape_data;

    /**
     * Returns true if the text box containing an ink being edited/authored is empty
     */
    function isTextboxEmpty() {
        return ($(&#x27;#&#x27; + textboxid).attr(&quot;value&quot;) === &quot;&quot;);
    }
    that.isTextboxEmpty = isTextboxEmpty;

    /**
     * Helper function to check if there is actually a valid ink to attach/save during ink authoring/editing. For texts, need to use isTextboxEmpty.
     * @param datastring    the datastring to check
     * @return    whether or not there are no inks on the canvas (i.e. the datastring does not represent anything useful)
     */
    function isDatastringEmpty(datastring) {
        //console.log(&quot;is data string empty :&quot; + datastring);
        if (!pathstring &amp;&amp; datastring === &quot;&quot;) // MODIFIED
            return true;
        var type = datastring.split(&quot;::&quot;)[0].toLowerCase();
        var empty = false;
        switch (type) {
            case &#x27;trans&#x27;:
                if (datastring.split(&quot;[path]&quot;)[1].split(&quot;[&quot;)[0] === &quot;&quot;)
                    empty = true;
                break;
            case &#x27;bezier&#x27;: // TO DO -- in case we go back to old paths, add currpaths or something
            case &#x27;path&#x27;:
                if (!pathstring &amp;&amp; datastring.split(&quot;[pathstring]&quot;)[1].split(&quot;[&quot;)[0] === &quot;&quot;) // MODIFIED
                    empty = true;
                break;
            case &#x27;text&#x27;:
                if (datastring.split(&quot;[str]&quot;)[1].split(&quot;[&quot;)[0] === &quot;&quot;)
                    empty = true;
                break;
            default:
                break;
        }
        return empty;
    }
    that.isDatastringEmpty = isDatastringEmpty;

    /**
     * Display warning message if ink cannot be loaded
     * @param displayString     String describing error (to be displayed)
     */
    function creationError(displayString) {
        timeline.hideEditorOverlay();
        var messageBox = LADS.Util.UI.popUpMessage(null, displayString, null);
        $(messageBox).css(&#x27;z-index&#x27;, LADS.TourAuthoring.Constants.aboveRinZIndex + 1000);
        $(&#x27;body&#x27;).append(messageBox);
        $(messageBox).fadeIn(500);
    }

    /**
     * Checks if currently inside display
     * @returns             true if in display, false otherwise
     */
    function checkInDisplay(track) {
        var currTime = timeManager.getCurrentTime();
        //for (var i = 0; i &lt; displays.length ; i++) {
        //    var disp = displays[i];
        //    if (disp.getStart() &lt;= currTime &amp;&amp; currTime &lt;= disp.getEnd()) {
        //        inDisplay = true;
        //        break;
        //    }
        //}
        var nearestDisplay = track.getStorageContainer().displays.nearestNeighbors(currTime, 1)[0];
        if (nearestDisplay) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Helper function to do some preprocessing on text inks before linking them.
     * @return    true if we should proceed to linking, false if there are warning messages
     */
    function link_text() {
        if (!dataHolder) {
            dataHolder = timeline.dataHolder;
        }
        var track = dataHolder.getSelectedTrack();
        if (!track || (track.getType() !== LADS.TourAuthoring.TrackType.artwork &amp;&amp; track.getType() !== LADS.TourAuthoring.TrackType.image)) {
            creationError(&quot;There is no artwork or image track selected. Please select a valid track or create an unlinked ink.&quot;);
            return false;
        }

        // First, check if the text is a valid (non-empty) ink by checking the value of the textbox. If invalid, show a warning message.
        if (isTextboxEmpty()) {
            creationError(&quot;Unable to attach an empty ink. Please add to ink component before attaching.&quot;);
            return false;
        }
        // next, check to make sure the playhead is in a display; if not, show a warning message
        var inDisplay = checkInDisplay(track);//.getDisplays());
        // also check if the selected track is an artwork or an image
        if (!inDisplay) {
            creationError(&quot;Please move the playhead within the currently selected track&#x27;s display.&quot;);
            return false; // if a warning popped up, return false
        }
        var keyframe = viewer.captureKeyframe(track.getTitle());
        if (!keyframe) {
            creationError(&quot;The track selected must be fully on screen in order to attach an ink. Please seek to a location where the track is visible.&quot;);
            return false;
        }


        save_text();
        return link();
    }
    that.link_text = link_text;

    /**
     * Helper function to do some preprocessing on text inks before creating them unattached.
     * @return     true if no warnings and we should create, false otherwise
     */
    function link_text_unattached() {
        // First, check if the text is a valid (non-empty) ink by checking the value of the textbox. If invalid, show a warning message.
        if (isTextboxEmpty()) {
            creationError(&quot;Unable to attach an empty ink. Please add to ink component before attaching.&quot;);
            return false;
        }
        if (!linkUnattached()) return false;
        return true;
    }
    that.link_text_unattached = link_text_unattached;

    /**
     * Helper function to do some preprocessing on transparencies before linking them.
     * @return     true if no warnings, false otherwise (see link_text for description of warnings)
     */
    function link_trans() {
        if (!dataHolder) {
            dataHolder = timeline.dataHolder;
        }
        var track = dataHolder.getSelectedTrack();
        
        if (!track || (track.getType() !== LADS.TourAuthoring.TrackType.artwork &amp;&amp; track.getType() !== LADS.TourAuthoring.TrackType.image)) {
            creationError(&quot;There is no artwork or image track selected. Please select a valid track or create an unlinked ink.&quot;);
            return false;
        }

        var inDisplay = checkInDisplay(track);
        
        if (!inDisplay) {
            creationError(&quot;Please move the playhead within the currently selected track&#x27;s display.&quot;);
            return false; // if a warning popped up, return false
        }
        
        var keyframe = viewer.captureKeyframe(track.getTitle());
        if (!keyframe) {
            creationError(&quot;The track selected must be fully on screen in order to attach an ink. Please seek to a location where the track is visible.&quot;);
            return false;
        }

        get_trans_shape_data();
        return link();
    }
    that.link_trans = link_trans;

    /**
     * Helper function to do some preprocessing on transparencies before creating them unattached.
     * @return     true if no warnings, false otherwise
     */
    function link_trans_unattached() {
        if (isDatastringEmpty(update_datastring())) {
            creationError(&quot;Unable to attach an empty ink. Please add to ink component before attaching.&quot;);
            return false;
        }
        get_trans_shape_data();
        linkUnattached();
        return true;
    }
    that.link_trans_unattached = link_trans_unattached;

    /**
     * Function to link an ink to an artwork. Called for all types of inks (possibly after preprocessing, in
     * the cases of texts and transparencies).
     * return     true if linking was successful, false if warnings
     */
    function link() {
        if (!dataHolder) {
            dataHolder = timeline.dataHolder;
        }
        var track = dataHolder.getSelectedTrack();

        if (!track || (track.getType() !== LADS.TourAuthoring.TrackType.artwork &amp;&amp; track.getType() !== LADS.TourAuthoring.TrackType.image)) {
            creationError(&quot;There is no artwork or image track selected. Please select a valid track or create an unlinked ink.&quot;);
            return false;
        }
        if (isDatastringEmpty(update_datastring())) { // make sure the datastring is nonempty before we attach
            creationError(&quot;Unable to attach an empty ink. Please add to ink component before attaching.&quot;);
            return false;
        }
        var inDisplay = checkInDisplay(track);
        // make sure the track selection is valid, it is an artwork or an image, and the playhead is in a track display
        if (!inDisplay) {
            creationError(&quot;Please move the playhead within the currently selected track&#x27;s display.&quot;);
            return false; // if a warning popped up, return false
        }

        // prepare to set track data
        artName = track.getTitle();
        var cw = domelement.width();
        var ch = domelement.height();
        magX = cw;
        magY = ch;
        var proxy_div = $(&quot;[data-proxy=&#x27;&quot; + escape(artName) + &quot;&#x27;]&quot;);
        var proxy = {
            x: proxy_div.data(&quot;x&quot;),
            y: proxy_div.data(&quot;y&quot;),
            w: proxy_div.data(&quot;w&quot;),
            h: proxy_div.data(&quot;h&quot;)
        };

        var datastr = update_datastring();

        var keyframe = viewer.captureKeyframe(artName);
        if (!keyframe) {
            creationError(&quot;The track selected must be fully on screen in order to attach an ink. Please seek to a location where the track is visible.&quot;);
            return false;
        }

        var kfvx, kfvy, kfvw, kfvh,
            linkType = track.getType();
        // get initial keyframe for the artwork/image we&#x27;re attaching to
        if (linkType === LADS.TourAuthoring.TrackType.artwork) {
            kfvx = keyframe.state.viewport.region.center.x;
            kfvy = keyframe.state.viewport.region.center.y;
            kfvw = keyframe.state.viewport.region.span.x;
            kfvh = keyframe.state.viewport.region.span.y;
        }
        else if (linkType === LADS.TourAuthoring.TrackType.image) {
            kfvw = 1.0 / keyframe.state.viewport.region.span.x;//$(&quot;#&quot; + canvid).width() / (keyframe.state.viewport.region.span.x * cw);
            var rw = keyframe.state.viewport.region.span.x * domelement.width();
            kfvh = keyframe.state.viewport.region.span.y; /////bogus entry, not used
            kfvx = -keyframe.state.viewport.region.center.x * kfvw;// /
            kfvy = -(domelement.height() / rw) * keyframe.state.viewport.region.center.y;// / (.5*(keyframe.state.viewport.region.span.x
        }
        // set track data
        var inkType = datastr.split(&quot;::&quot;)[0].toLowerCase();
        inktrack = timeline.addInkTrack(track, &quot;Ink &quot; + decodeURI(track.getTitle()), inkType);
        inktrack.setInkLink(track);

        if (inkType === &quot;trans&quot;)
            datastr += bounding_shapes; // if we&#x27;re attaching a transparency, also include the bounding ellipse/rects in the datastring so we can edit later
        inktrack.setInkPath(datastr);
        inktrack.setInkProps({}); // not used
        inktrack.setInkInitKeyframe({ &quot;x&quot;: kfvx, &quot;y&quot;: kfvy, &quot;w&quot;: kfvw, &quot;h&quot;: kfvh });
        inktrack.setInkEnabled(true); // set linked
        inktrack.setInkType(inkType);
        inktrack.setInkRelativeArtPos(getArtRelativePos(proxy, cw, ch));

        inktrack.addInkTypeToTitle(inkType);

        enabled = true;
        domelement.remove();

        var inkDisplayTime = timeManager.getCurrentTime();
        var parentDisplay = track.getStorageContainer().displays.nearestNeighbors(inkDisplayTime, 1)[0].display;
        var boundingEdge = parentDisplay.getEnd();
        var inkDisplay = inktrack.addDisplay(timeManager.getCurrentPx(), Math.min(5, boundingEdge - inkDisplayTime)); //add a display at the playhead location

        // set parent-child association between displays
        parentDisplay.addChildDisplay(inkDisplay);
        inkDisplay.setParentDisplay(parentDisplay);

        // add linking association between tracks
        track.addAttachedInkTrack(inktrack);
        inktrack.setInkLink(track);

        // add command to undo both track creation and display at once
        undoManager.combineLast(2);

        if (dataHolder._trackArray.length &gt; 0) {
            dataHolder._trackArray[0].track.leftAndRight({ translation: { x: 0 } }, false);
        }

        return true;
    }
    that.link = link;

    /**
     * Function to create an unattached ink. Called for all types of inks (possibly after preprocessing, in
     * the cases of texts and transparencies).
     * return     true if creation was successful, false if warnings
     */
    function linkUnattached() {
        var inkEmptyOverlay = $(LADS.Util.UI.blockInteractionOverlay());
        var inkEmptyDialog = $(document.createElement(&quot;div&quot;));

        function okTapInkAttach(evt) {
            inkEmptyOverlay.fadeOut(200);
        }
        if (isDatastringEmpty(update_datastring())) {
            inkEmptyDialog.attr(&quot;id&quot;, &quot;inkEmptyDialog&quot;);
            inkEmptyDialog.css({
                display: &#x27;none&#x27;,
                position: &#x27;fixed&#x27;,
                top: &#x27;40%&#x27;,
                left: &#x27;30%&#x27;,
                width: &#x27;auto&#x27;,
                &#x27;background-color&#x27;: &#x27;black&#x27;,
                &#x27;border&#x27;: &#x27;3px double white&#x27;,
                &#x27;z-index&#x27;: LADS.TourAuthoring.aboveRinZIndex + 5,
                &#x27;text-align&#x27;: &#x27;center&#x27;,
                &#x27;padding&#x27;: &#x27;1.5% 1.5% 2% 2%&#x27;,
            });

            inkEmptyOverlay.append(inkEmptyDialog);
            $(&quot;body&quot;).append(inkEmptyOverlay);
            inkEmptyOverlay.fadeIn(100);

            var text = $(document.createElement(&quot;div&quot;));
            text.text(&quot;Unable to attach an empty ink. Please add to ink component before attaching.&quot;);
            text.css(&#x27;font-size&#x27;, &#x27;1.25em&#x27;, &quot;text-align&quot;, &#x27;left&#x27;);
            inkEmptyDialog.append(text);

            var buttonDiv = $(document.createElement(&quot;div&quot;));
            buttonDiv.css(&#x27;text-align&#x27;, &#x27;center&#x27;);

            var ok = $(document.createElement(&quot;button&quot;));
            ok.text(&quot;OK&quot;);
            ok.css({
                width: &#x27;auto&#x27;,
                &#x27;background-color&#x27;: &#x27;black&#x27;,
                &#x27;border&#x27;: &#x27;1px solid white&#x27;,
                &#x27;margin-top&#x27;: &#x27;25px&#x27;,
                //&#x27;margin-right&#x27;:&#x27;2%&#x27;
            });
            buttonDiv.append(ok);
            inkEmptyDialog.append(buttonDiv);
            inkEmptyDialog.show();

            LADS.Util.makeManipulatable(ok[0], {
                onTapped: okTapInkAttach
            }, false);
            return false;
        }

        // add track and set track data
        inktrack = timeline.addInkTrack(null, &quot;Unattached Ink&quot;, 1);
        inktrack.setInkLink(null);
        var datastr = update_datastring();
        var inkType = datastr.split(&quot;::&quot;)[0].toLowerCase();
        if (inkType == &quot;trans&quot;)
            datastr += bounding_shapes;
        inktrack.setInkPath(datastr);
        inktrack.setInkEnabled(false); // unattached
        inktrack.setInkSize(fontSize);
        inktrack.setInkInitKeyframe({}); // initial keyframe doesn&#x27;t matter, since not linked
        inktrack.setInkRelativeArtPos({}); // initial art position doesn&#x27;t matter, since not linked

        inktrack.addInkTypeToTitle(inkType);


        enabled = false;
        domelement.remove();
        inktrack.addDisplay(Math.min(timeManager.timeToPx(timeManager.getDuration().end - 0.5), timeManager.getCurrentPx()), Math.min(5, Math.max(0.5, timeManager.getDuration().end - timeManager.getCurrentTime()))); // add a display at the playhead location
        undoManager.combineLast(2);
        if (timeline.getTracks().length &gt; 0) {
            timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
        }
        return true;
    }
    that.linkUnattached = linkUnattached;

    function getTextElt() {
        return textElt;
    }
    that.getTextElt = getTextElt;

    var magX = domelement.width(), magY = domelement.height();

    function getTextMagnification() {
        return magY;
    }
    that.getTextMagnification= getTextMagnification;

    /**
     * Loads an ink onto the ink canvas using its datastring (e.g. from track data).
     * @param   the datastring to be loaded (see update_datastring for datastring format)
     */
    function loadInk(datastr) {
        var shapes = datastr.split(&quot;|&quot;);
        var i;
        var cw = domelement.width();
        var ch = domelement.height();
        magX = cw;
        magY = ch;
        pathstring = &quot;&quot;;
        var shapes_len = shapes.length;
        for (i = 0; i &lt; shapes_len; i++) {
            var shape = shapes[i];
            var x, y, w, h, fillc, fillo, strokec, strokeo, strokew;
            if (shape &amp;&amp; (shape !== &quot;&quot;)) {
                var type = shape.split(&quot;::&quot;)[0];
                switch (type.toLowerCase()) {
                    case &quot;text&quot;:
                        // format: [str]&lt;text&gt;[font]&lt;font&gt;[fontsize]&lt;fontsize&gt;[color]&lt;font color&gt;[x]&lt;x&gt;[y]&lt;y&gt;[]
                        var size = get_attr(shape, &quot;fontsize&quot;, &quot;f&quot;) * ch;
                        fontSize = size;
                        x = get_attr(shape, &quot;x&quot;, &quot;f&quot;) * cw;
                        y = get_attr(shape, &quot;y&quot;, &quot;f&quot;) * ch;
                        //var w, h;
                        try {
                            w = get_attr(shape, &#x27;w&#x27;, &#x27;f&#x27;);
                            h = get_attr(shape, &#x27;h&#x27;, &#x27;f&#x27;);
                        } catch (err) {
                            w = null;
                            h = null;
                        }
                        var text_color = get_attr(shape, &quot;color&quot;, &quot;s&quot;);
                        var text_font = get_attr(shape, &quot;font&quot;, &quot;s&quot;);
                        var text_text = get_attr(shape, &quot;str&quot;, &quot;s&quot;);
                        var text = paper.text(x, y, text_text);
                        text.attr({
                            &quot;font-family&quot;: text_font,
                            &quot;font-size&quot;: size + &quot;px&quot;,
                            &quot;fill&quot;: text_color,
                            &quot;text-anchor&quot;: &quot;start&quot;,
                        });
                        text.data({
                            &quot;x&quot;: x,
                            &quot;y&quot;: y,
                            &#x27;w&#x27;: w,
                            &#x27;h&#x27;: h,
                            &quot;fontsize&quot;: size,
                            &quot;color&quot;: text_color,
                            &quot;font&quot;: text_font,
                            &quot;type&quot;: &quot;text&quot;,
                            &quot;str&quot;: text_text,
                        });
                        textElt = text;
                        break;
                    case &quot;path&quot;:
                        // format: [pathstring]M284,193L284,193[stroke]000000[strokeo]1[strokew]10[]
                        if (!currpaths)
                            currpaths = &quot;&quot;;
                        currpaths += shape + &quot;|&quot;;
                        update_ml_xy_pa(shape + &quot;|&quot;);
                        break;
                    case &quot;bezier&quot;: // bezier paths
                        
                        pathstring += get_attr(shape,&quot;pathstring&quot;,&#x27;s&#x27;);
                        pa.push({ color: get_attr(shape, &quot;stroke&quot;, &#x27;s&#x27;), opacity: get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;), width: get_attr(shape, &quot;strokew&quot;,&quot;f&quot;) });
                        break;
                    case &quot;trans&quot;:
                        // format: [path]&lt;path&gt;[color]&lt;color&gt;[opac]&lt;opac&gt;[mode]&lt;block or isolate&gt;[]
                        if (!trans_currpath)
                            trans_currpath = &quot;&quot;;
                        trans_currpath += shape + &quot;|&quot;;
                        var pathstringt = get_attr(shape, &quot;path&quot;, &#x27;s&#x27;); // MODIFIED
                        marqueeFillColor = get_attr(shape, &quot;color&quot;, &#x27;s&#x27;);
                        marqueeFillOpacity = get_attr(shape, &quot;opac&quot;, &quot;f&quot;);
                        trans_mode = get_attr(shape, &quot;mode&quot;, &#x27;s&#x27;);
                        transCoords = pathstringt.match(/[0-9.\-]+/g);
                        transLetters = pathstringt.match(/[CMLz]/g);
                        drawTrans();
                        break;
                    case &quot;rect&quot;:
                        // format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        x = abs_dims(get_attr(shape, &quot;x&quot;, &quot;f&quot;), cw);
                        y = abs_dims(get_attr(shape, &quot;y&quot;, &quot;f&quot;), ch);
                        w = abs_dims(get_attr(shape, &quot;w&quot;, &quot;f&quot;), cw);
                        h = abs_dims(get_attr(shape, &quot;h&quot;, &quot;f&quot;), ch);
                        fillc = get_attr(shape, &quot;fillc&quot;, &quot;s&quot;);
                        fillo = get_attr(shape, &quot;fillo&quot;, &quot;f&quot;);
                        strokec = get_attr(shape, &quot;strokec&quot;, &quot;s&quot;);
                        strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        strokew = get_attr(shape, &quot;strokew&quot;, &quot;f&quot;);
                        var R = paper.rect(x, y, w, h);
                        R.data(&quot;currx&quot;, x);
                        R.data(&quot;curry&quot;, y);
                        R.data(&quot;currw&quot;, w);
                        R.data(&quot;currh&quot;, h);
                        R.data(&quot;type&quot;, &quot;rect&quot;);
                        R.data(&quot;visible&quot;, &quot;yes&quot;);
                        add_attributes(R, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case &quot;ellipse&quot;:
                        // format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var cx = abs_dims(get_attr(shape, &quot;cx&quot;, &quot;f&quot;), cw);
                        var cy = abs_dims(get_attr(shape, &quot;cy&quot;, &quot;f&quot;), ch);
                        var rx = abs_dims(get_attr(shape, &quot;rx&quot;, &quot;f&quot;), cw);
                        var ry = abs_dims(get_attr(shape, &quot;ry&quot;, &quot;f&quot;), ch);
                        fillc = get_attr(shape, &quot;fillc&quot;, &quot;s&quot;);
                        fillo = get_attr(shape, &quot;fillo&quot;, &quot;f&quot;);
                        strokec = get_attr(shape, &quot;strokec&quot;, &quot;s&quot;);
                        strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        strokew = get_attr(shape, &quot;strokew&quot;, &quot;f&quot;);
                        var E = paper.ellipse(cx, cy, rx, ry);
                        E.data(&quot;currx&quot;, E.getBBox().x);
                        E.data(&quot;curry&quot;, E.getBBox().y);
                        E.data(&quot;curr_rx&quot;, rx);
                        E.data(&quot;curr_ry&quot;, ry);
                        E.data(&quot;type&quot;, &quot;ellipse&quot;);
                        E.data(&quot;visible&quot;, &quot;yes&quot;);
                        add_attributes(E, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case &quot;marquee&quot;: // DEPRECATED
                        // format: [x]206[y]207[w]102[h]93[surrfillc]#222222[surrfillo].8[]
                        var topx = abs_dims(get_attr(shape, &quot;x&quot;, &quot;f&quot;), cw);
                        var topy = abs_dims(get_attr(shape, &quot;y&quot;, &quot;f&quot;), ch);
                        w = abs_dims(get_attr(shape, &quot;w&quot;, &quot;f&quot;), cw);
                        h = abs_dims(get_attr(shape, &quot;h&quot;, &quot;f&quot;), ch);
                        var surrfillc = get_attr(shape, &quot;surrfillc&quot;, &quot;s&quot;);
                        var surrfillo = get_attr(shape, &quot;surrfillo&quot;, &quot;f&quot;);
                        var botx = topx + w;
                        var boty = topy + h;
                        var rn = paper.rect(0, 0, cw, topy);
                        rn.data(&quot;currx&quot;, 0);
                        rn.data(&quot;curry&quot;, 0);
                        var re = paper.rect(botx, topy, cw - botx, boty - topy);
                        re.data(&quot;currx&quot;, botx);
                        re.data(&quot;curry&quot;, topy);
                        var rs = paper.rect(0, boty, cw, ch - boty);
                        rs.data(&quot;currx&quot;, 0);
                        rs.data(&quot;curry&quot;, boty);
                        var rw = paper.rect(0, topy, topx, boty - topy);
                        rw.data(&quot;currx&quot;, 0);
                        rw.data(&quot;curry&quot;, topy);
                        var rc = paper.rect(topx, topy, botx - topx, boty - topy);
                        rc.data(&quot;currx&quot;, topx);
                        rc.data(&quot;curry&quot;, topy);
                        rc.data(&quot;type&quot;, &quot;marquee&quot;);
                        //var m = new marquee(rn, re, rs, rw, rc);
                        //add_marq_attributes(m, surrfillc, surrfillo);
                        //marquees.push(m);
                        break;
                }
            }
        }
        drawPaths();
        if (pathstring) {
            drawBezierPath();
        }

        // force adjustViewBox to run so viewbox is always set 
        //lastpx = origpx + 10000;
        if (enabled) {
            paper.setViewBox(0, 0, cw, ch);
            //adjustViewBox({ x: origpx, y: origpy, width: origpw, height: origph });
        }
    }
    that.loadInk = loadInk;

    /**
     * Draws a transparency to the canvas and adds the correct styling. Also sets trans_currpath, which keeps track of current transparency path.
     * @param pth    the path representing the transparency to be loaded in
     */
    function load_trans_from_path(pth) {
        var cw = domelement.width();
        var ch = domelement.height();
        var trans = paper.path(pth).attr({ &quot;fill-opacity&quot;: marqueeFillOpacity, &quot;fill&quot;: marqueeFillColor, &quot;stroke-opacity&quot;: 0, &quot;stroke&quot;: &quot;#888888&quot;, &quot;stroke-width&quot;: 0 });
        trans.data(&quot;type&quot;, &quot;trans&quot;);
        trans_currpath = &quot;TRANS::[path]&quot; + transform_pathstring_marq(pth, 1.0 / cw, 1.0 / ch) + &quot;[color]&quot; + marqueeFillColor + &quot;[opac]&quot; + marqueeFillOpacity + &quot;[mode]&quot; + trans_mode + &quot;[]|&quot;;
        update_datastring();
    }
    that.load_trans_from_path = load_trans_from_path;

    /**
     * Loads a transparency&#x27;s bounding shapes -- type boundrect and boundellipse -- for editing transparencies
     * @param datastr    the datastring containing the transparency path and its bounding shapes
     */
    function load_transparency_bounding_shapes(datastr) {
        var shapes = datastr.split(&quot;|&quot;);
        var i;
        var cw = domelement.width();
        var ch = domelement.height();
        for (i = 0; i &lt; shapes.length; i++) {
            var shape = shapes[i];
            var fillc, fillo, strokec, strokeo, strokew;
            if (shape &amp;&amp; (shape !== &quot;&quot;)) {
                var type = shape.split(&quot;::&quot;)[0];
                type = type.toLowerCase();
                switch (type) {
                    case &quot;boundrect&quot;:
                        //format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var x = abs_dims(get_attr(shape, &quot;x&quot;, &quot;f&quot;), cw);
                        var y = abs_dims(get_attr(shape, &quot;y&quot;, &quot;f&quot;), ch);
                        var w = abs_dims(get_attr(shape, &quot;w&quot;, &quot;f&quot;), cw);
                        var h = abs_dims(get_attr(shape, &quot;h&quot;, &quot;f&quot;), ch);
                        fillc = get_attr(shape, &quot;fillc&quot;, &quot;s&quot;);
                        fillo = get_attr(shape, &quot;fillo&quot;, &quot;f&quot;);
                        strokec = get_attr(shape, &quot;strokec&quot;, &quot;s&quot;);
                        strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        strokew = get_attr(shape, &quot;strokew&quot;, &quot;f&quot;);
                        var R = paper.rect(x, y, w, h);
                        R.data(&quot;currx&quot;, x);
                        R.data(&quot;curry&quot;, y);
                        R.data(&quot;currw&quot;, w);
                        R.data(&quot;currh&quot;, h);
                        R.data(&quot;type&quot;, &quot;rect&quot;);
                        R.data(&quot;visible&quot;, &quot;yes&quot;);
                        add_attributes(R, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case &quot;boundellipse&quot;:
                        //format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var cx = abs_dims(get_attr(shape, &quot;cx&quot;, &quot;f&quot;), cw);
                        var cy = abs_dims(get_attr(shape, &quot;cy&quot;, &quot;f&quot;), ch);
                        var rx = abs_dims(get_attr(shape, &quot;rx&quot;, &quot;f&quot;), cw);
                        var ry = abs_dims(get_attr(shape, &quot;ry&quot;, &quot;f&quot;), ch);
                        fillc = get_attr(shape, &quot;fillc&quot;, &quot;s&quot;);
                        fillo = get_attr(shape, &quot;fillo&quot;, &quot;f&quot;);
                        strokec = get_attr(shape, &quot;strokec&quot;, &quot;s&quot;);
                        strokeo = get_attr(shape, &quot;strokeo&quot;, &quot;f&quot;);
                        strokew = get_attr(shape, &quot;strokew&quot;, &quot;f&quot;);
                        var E = paper.ellipse(cx, cy, rx, ry);
                        E.data(&quot;currx&quot;, E.getBBox().x);
                        E.data(&quot;curry&quot;, E.getBBox().y);
                        E.data(&quot;curr_rx&quot;, rx);
                        E.data(&quot;curr_ry&quot;, ry);
                        E.data(&quot;type&quot;, &quot;ellipse&quot;);
                        E.data(&quot;visible&quot;, &quot;yes&quot;);
                        add_attributes(E, fillc, fillo, strokec, strokeo, strokew);
                        break;
                }
            }
        }
    }
    that.load_transparency_bounding_shapes = load_transparency_bounding_shapes;

    /**
     * DEPRECATED -- constructor for old marquees
     */
    //function marquee(rectN, rectE, rectS, rectW, rectC) {
    //    this.rn = rectN;
    //    this.re = rectE;
    //    this.rs = rectS;
    //    this.rw = rectW;
    //    this.rc = rectC;
    //}
    //that.marquee = marquee;

    /**
     * Using the point pt, computes the incoming bezier anchor coordinates for the next point (next) in the path.
     * This is done by using the points&#x27; types (if pt and next are both endpoints, pt.point.ax2, .ay2 give the relevant information, etc).
     * @param pt      starting point object (contains point coordinates, type of point, and which path it&#x27;s on)
     * @param next    next point object
     * @return    the incoming bezier anchor coordinates to next
     */
    function next_in_bez(pt, next) {
        var bez, t, dots;
        if (pt.type == &quot;endpoint&quot;) {
            if (next.type == &quot;endpoint&quot;) {
                return { x: pt.point.ax2, y: pt.point.ay2 };
            }
            else { // pt is an endpoint and next is an intersection point
                bez = (pt.path === 0) ? (next.point.bez1) : (next.point.bez2);
                t = (pt.path === 0) ? (next.point.t1) : (next.point.t2);
                dots = Raphael.findDotsAtSegment(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], bez[6], bez[7], t);
                return { x: dots.m.x, y: dots.m.y };
            }
        }
        else { // pt is an intersection point
            if (next.type === &quot;endpoint&quot;) {
                bez = (next.path === 0) ? (pt.point.bez1) : (pt.point.bez2);
                return { x: bez[4], y: bez[5] };
            }
            else {//both pt and next are intersection points
                bez = (next.path === 0) ? (next.point.bez1) : (next.point.bez2);
                t = (next.path === 0) ? (next.point.t1) : (next.point.t2);
                dots = Raphael.findDotsAtSegment(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], bez[6], bez[7], t);
                return { x: dots.n.x, y: dots.n.y };
            }
        }
    }
    that.next_in_bez = next_in_bez;

    /**
     * Helper function to determine whether p1 and p2 are effectively the same point. Returns true if so.
     */
    function nontrivial(p1, p2) {
        return ((Math.abs(p1.x - p2.x) &gt; 0.00000001) || (Math.abs(p1.y - p2.y) &gt; 0.00000001) || (Math.abs(p1.w - p2.w) &gt; 0.00000001) || (Math.abs(p1.h - p2.h) &gt; 0.00000001));
    }
    that.nontrivial = nontrivial;

    /**
     * Using the point next, computes the outgoing bezier anchor coordinates for the point pt on the path.
     * @param pt      starting point object (contains point coordinates, type of point, and which path it&#x27;s on)
     * @param next    next point object
     * @return    the outgoing bezier anchor coordinates from pt
     */
    function out_bez(pt, next) {
        if (pt.type === &quot;endpoint&quot;) {
            return { x: pt.point.ax1, y: pt.point.ay1 };
        }
        else { // pt is an intersection point
            var bez = (next.path === 0) ? (pt.point.bez1) : (pt.point.bez2);
            var t = (next.path === 0) ? (pt.point.t1) : (pt.point.t2);
            var dots = Raphael.findDotsAtSegment(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], bez[6], bez[7], t);
            return { x: dots.n.x, y: dots.n.y };
        }
    }
    that.out_bez = out_bez;

    var inkPannedX;
    var inkPannedY;
    /**
     * Pans all objects in the canvas by dx, dy.
     * @param dx, dy    the deltas
     * @param draw      should we take time to draw the objects?
     */
    function panObjects(dx, dy, canv_dims, draw) {
        var cw = canv_dims.cw;
        var ch = canv_dims.ch;
        var i;
        paper.forEach(function (elt) { // first take care of panning rects, ellipses, and texts by changing their attributes
            var type = elt.data(&quot;type&quot;);
            if ((type != &quot;path&quot;) &amp;&amp; (type != &quot;bezier&quot;) &amp;&amp; (type != &quot;text&quot;) &amp;&amp; (type != &quot;trans&quot;)) {
                elt.attr({
                    &#x27;x&#x27;: parseFloat(elt.attr(&quot;x&quot;)) + dx * cw,
                    &#x27;y&#x27;: parseFloat(elt.attr(&quot;y&quot;)) + dy * ch,
                    &#x27;cx&#x27;: parseFloat(elt.attr(&quot;cx&quot;)) + dx * cw,
                    &#x27;cy&#x27;: parseFloat(elt.attr(&quot;cy&quot;)) + dy * ch,
                });
                if (type == &quot;ellipse&quot;) {
                    elt.data(&quot;currx&quot;, parseFloat(elt.attr(&quot;cx&quot;)) - parseFloat(elt.attr(&quot;rx&quot;)));
                    elt.data(&quot;curry&quot;, parseFloat(elt.attr(&quot;cy&quot;)) - parseFloat(elt.attr(&quot;ry&quot;)));
                    elt.data(&quot;curr_rx&quot;, elt.attr(&quot;rx&quot;));
                    elt.data(&quot;curr_ry&quot;, elt.attr(&quot;ry&quot;));
                }
                else {
                    elt.data(&quot;currx&quot;, elt.attr(&quot;x&quot;));
                    elt.data(&quot;curry&quot;, elt.attr(&quot;y&quot;));
                }
            }
            else if (type == &quot;text&quot;) {
                elt.attr({
                    &#x27;x&#x27;: parseFloat(elt.attr(&quot;x&quot;)) + dx * cw,
                    &#x27;y&#x27;: parseFloat(elt.attr(&quot;y&quot;)) + dy * ch,
                });
                elt.data(&#x27;x&#x27;, parseFloat(elt.data(&quot;x&quot;)) + dx * cw);
                elt.data(&#x27;y&#x27;, parseFloat(elt.data(&quot;y&quot;)) + dy * ch);
                inkPannedX = elt.attr(&#x27;x&#x27;);
                inkPannedY = elt.attr(&#x27;y&#x27;);
            }
        });

        // pan paths by modifying xy
        var xylen = xy.length;
        for (i = 0; i &lt; xylen; i++) {
            xy[i][0] = xy[i][0] + dx;
            xy[i][1] = xy[i][1] + dy;
        }

        var coords, letters;
        coords = extractCoords(pathstring);
        letters = extractLetters(pathstring);
        for (i = 0; i &lt; coords.length; i += 2) {
            coords[i] += dx;
            coords[i + 1] += dy;
        }
        pathstring = mergeToPath(letters, coords);

        // pan transparencies by modifying transCoords
        var tclen = transCoords.length;
        for (i = 0; i &lt; tclen; i++) {
            transCoords[i] += ((i % 2) ? dy : dx);
        }

        // if type is drawing, call drawPaths if necessary
        if (xylen &amp;&amp; draw)
            drawPaths();

        // if type is transparency, call drawTrans if ncecessary
        if (tclen &amp;&amp; draw)
            drawTrans();

        if (pathstring &amp;&amp; draw)
            drawBezierPath();

        // if the type of our ink is a text, redraw (if necessary) by just removing all and loading the datastring back in
        if (!xylen &amp;&amp; !tclen &amp;&amp; draw) {
            var dstring = update_datastring();
            remove_all();
            datastring = dstring;
            loadInk(datastring);
        }
    }
    that.panObjects = panObjects;

    function getPannedPos() {
        // used to return positional data for generating text in correct place
        var pannedPos = { x: inkPannedX, y: inkPannedY };
        return pannedPos;
    }
    that.getPannedPos = getPannedPos;

    /**
     * Pans all objects in the canvas by dx, dy.
     * @param dx, dy    the deltas
     * @param draw      should we take time to draw the objects?
     */
    function testPan(dx, dy, draw) {
        if (!draw) {
            paper.forEach(function (elt) {
                elt.transform(&quot;t-&quot; + elt.data(&quot;bboxcenterx&quot;) + &quot;,-&quot; + elt.data(&quot;bboxcentery&quot;) + &quot;...&quot;);
            });
        }
        else {
            paper.forEach(function (elt) {
                elt.transform(&quot;t&quot; + (dx+elt.data(&quot;bboxcenterx&quot;)) + &quot;,&quot; + (dy+elt.data(&quot;bboxcentery&quot;)) + &quot;...&quot;);
            });
        }
    }
    that.testPan = testPan;

    function testScale(scale_x, scale_y, draw) {
        paper.forEach(function (elt) {
            var bbox = elt.getBBox();
            elt.transform(&quot;s&quot; + scale_x + &quot;...&quot;);
            elt.transform(&quot;t&quot; + (-elt.getBBox().x) + &quot;,&quot; + (-elt.getBBox().y)+&quot;...&quot;);
            elt.transform(&quot;t&quot; + (bbox.x*scale_x) + &quot;,&quot; + (bbox.y*scale_y)+&quot;...&quot;);
        });
    }
    that.testScale = testScale;

    /**
     * Sometimes points on the boundary of a shape do not register as being inside the shape, so check a few surrounding
     * points as well. If enough of them (2) are inside, call the point inside. This isn&#x27;t bulletproof, but it should
     * work most of the time.
     * @param pth     the path whose boundary concerns us
     * @param x, y    coordinates of the point to test
     * @return    1 if enough points are inside, 0 otherwise
     */
    function point_inside(pth, x, y) {
        var test1 = Raphael.isPointInsidePath(pth, x, y);
        var test2 = Raphael.isPointInsidePath(pth, x - 1, y - 1);
        var test3 = Raphael.isPointInsidePath(pth, x + 1, y - 1);
        var test4 = Raphael.isPointInsidePath(pth, x - 1, y + 1);
        var test5 = Raphael.isPointInsidePath(pth, x + 1, y + 1);
        if (test1 || (test2 + test3 + test4 + test5 &gt;= 2))
            return 1;
        return 0;
    }
    that.point_inside = point_inside;

    /**
     * Helper function to convert to relative coordinates.
     * @param abs_coord   the absolute coordinate
     * @param canv_dim    the relevant canvas dimension to scale by
     */
    function rel_dims(abs_coord, canv_dim) {
        return parseFloat(abs_coord) / parseFloat(canv_dim);
    }
    that.rel_dims = rel_dims;

    /**
     * Returns 1 if any points in order_added match pt.
     */
    function repeat_pt(pt, order_added) {
        for (var i = 0; i &lt; order_added.length - 1; i++) {
            if (same_point(order_added[i].point, pt)) {
                return 1;
            }
        }
        return 0;
    }
    that.repeat_pt = repeat_pt;

    /**
     * Removes all Raphael elements from the canvas and clears arrays
     */
    function remove_all() {
        paper.clear();
        ml.length = 0;
        xy.length = 0;
        pa.length = 0;
        pathObjects.length = 0;
        marquees.length = 0;
        currpaths = &quot;&quot;;
        datastring = &#x27;&#x27;;
    }
    that.remove_all = remove_all;

    /**
     * Resizes all elements in the ink canvas.
     * @param scale_x, scale_y   the scale factors to resize by
     * @param draw               should we take the time to draw the result?
     */
    function resizeObjects(scale_x, scale_y, draw) {
        paper.forEach(function (elt) { // resize ellipses, rects, and texts by scaling attributes
            var type = elt.data(&quot;type&quot;);
            if ((type !== &quot;path&quot;) &amp;&amp; (type !== &quot;bezier&quot;) &amp;&amp; (type !== &quot;text&quot;) &amp;&amp; (type !== &quot;trans&quot;) &amp;&amp; (type !== &quot;grabHandle&quot;)) {
                elt.attr({
                    &#x27;x&#x27;: parseFloat(elt.attr(&quot;x&quot;)) * scale_x,
                    &#x27;y&#x27;: parseFloat(elt.attr(&quot;y&quot;)) * scale_y,
                    &#x27;cx&#x27;: parseFloat(elt.attr(&quot;cx&quot;)) * scale_x,
                    &#x27;cy&#x27;: parseFloat(elt.attr(&quot;cy&quot;)) * scale_y,
                    &#x27;rx&#x27;: parseFloat(elt.attr(&quot;rx&quot;)) * scale_x,
                    &#x27;ry&#x27;: parseFloat(elt.attr(&quot;ry&quot;)) * scale_y,
                    &#x27;width&#x27;: parseFloat(elt.attr(&quot;width&quot;)) * scale_x,
                    &#x27;height&#x27;: parseFloat(elt.attr(&quot;height&quot;)) * scale_y,
                });
                if (type === &quot;ellipse&quot;) {
                    elt.data(&quot;currx&quot;, parseFloat(elt.attr(&quot;cx&quot;)) - parseFloat(elt.attr(&quot;rx&quot;)));
                    elt.data(&quot;curry&quot;, parseFloat(elt.attr(&quot;cy&quot;)) - parseFloat(elt.attr(&quot;ry&quot;)));
                    elt.data(&quot;curr_rx&quot;, parseFloat(elt.attr(&quot;rx&quot;)));
                    elt.data(&quot;curr_ry&quot;, parseFloat(elt.attr(&quot;ry&quot;)));
                }
                else {
                    elt.data(&quot;currx&quot;, elt.attr(&quot;x&quot;));
                    elt.data(&quot;curry&quot;, elt.attr(&quot;y&quot;));
                }
            }
            else if (type === &quot;text&quot;) {
                elt.attr({
                    &#x27;font-size&#x27;: parseFloat(elt.attr(&quot;font-size&quot;)) * scale_y,
                    &#x27;x&#x27;: elt.attr(&quot;x&quot;) * scale_x,
                    &#x27;y&#x27;: elt.attr(&quot;y&quot;) * scale_y,
                });
                elt.data({
                    &#x27;fontsize&#x27;: elt.data(&quot;fontsize&quot;) * scale_y,
                    &#x27;x&#x27;: elt.data(&quot;x&quot;) * scale_x,
                    &#x27;y&#x27;: elt.data(&quot;y&quot;) * scale_y,
                });
            }
        });

        // resize paths by scaling elements of xy
        var xylen = xy.length;
        var i;
        for (i = 0; i &lt; xylen; i++) {
            xy[i][0] = xy[i][0] * scale_x;
            xy[i][1] = xy[i][1] * scale_y;
            pa[i].width = pa[i].width * scale_x;
        }

        var coords, letters;
        coords = extractCoords(pathstring);
        letters = extractLetters(pathstring);
        for (i = 0; i &lt; coords.length; i += 2) {
            coords[i] *= scale_x;
            coords[i + 1] *= scale_y;
        }
        for (i = 0; i &lt; pa.length; i++) {
            pa[i].width = pa[i].width * scale_x;
        }
        pathstring = mergeToPath(letters, coords);

        // resize transparencies by scaling elements of transCoords
        var tclen = transCoords.length;
        for (i = 0; i &lt; tclen; i++) {
            transCoords[i] *= ((i % 2) ? scale_y : scale_x);
        }

        // call drawPaths or drawTrans to update paths and transparencies, respectively, if need be
        if (xylen &amp;&amp; draw)
            drawPaths();
        if (tclen &amp;&amp; draw)
            drawTrans();
        if (pathstring &amp;&amp; draw)
            drawBezierPath();

        // update texts if need by by calling remove_all and then loading in the datastring
        if (!xylen &amp;&amp; !tclen &amp;&amp; draw) {
            var dstring = update_datastring();
            remove_all();
            datastring = dstring;
            loadInk(datastring);
        }
    }
    that.resizeObjects = resizeObjects;

    /**
     * Set the variables related to adjustViewBox (original artwork location) using the art proxy,
     * which keeps track of its dimensions
     */
    function retrieveOrigDims() {
        var proxy = $(&quot;[data-proxy=&#x27;&quot; + escape(artName) + &quot;&#x27;]&quot;);
        var kfx = initKeyframe.x;
        var kfy = initKeyframe.y;
        var kfw = initKeyframe.w;
        var real_kfw = origPaperW / kfw;
        var real_kfh = real_kfw * (proxy.data(&quot;h&quot;) / proxy.data(&quot;w&quot;));
        var real_kfx = -kfx * real_kfw;
        var real_kfy = -kfy * real_kfh;
        origpx = real_kfx;
        origpy = real_kfy;
        origpw = real_kfw;
        origph = real_kfh;
        lastpx = origpx;
        lastpy = origpy;
        lastpw = origpw;
        lastph = origph;
    }
    that.retrieveOrigDims = retrieveOrigDims;

    /**
-     * Checks whether two points are effectively the same
     * @param pt1, pt2   the points in question
     * @param err        how close the points have to be to be considered the same
     * @return    whether or not the points are the same (true/false)
     */
    function same_point(pt1, pt2, err) {
        if (err === undefined)
            err = 0.00001;
        return (Math.abs(pt1.x - pt2.x) &lt; err &amp;&amp; Math.abs(pt1.y - pt2.y) &lt; err);
    }
    that.same_point = same_point;

    /**
     * Helper function to convert a textbox to a Raphael text element. //========== should be deprecated
     */
    function save_text() {
        var x = svgText.left;// + parseFloat(textboxelmt.css(&quot;padding-left&quot;)); // a bit hacky -- we should figure out exactly how to compute text positioning
        var y = svgText.top;//tbe_pos.top;// + parseFloat(textboxelmt.css(&quot;padding-top&quot;)); // parseFloat(fontSize) * ((num_lines + 1) / 2.0) +
        var elt = paper.text(x, y, str); // draw the text on the canvas
        elt.attr(&quot;text-anchor&quot;, &quot;start&quot;);
        var initX = elt.attr(&quot;x&quot;);
        var initY = elt.attr(&quot;y&quot;);
        var eltbbox=elt.getBBox();
        elt.data({
            x: initX + parseFloat(textboxelmt.css(&quot;padding-left&quot;)),//eltbbox.width / 2 + 
            y: initY + eltbbox.height + parseFloat(textboxelmt.css(&quot;padding-top&quot;)),
            font: fontFamily,
            fontsize: fontSize,
            color: fontColor,
            str: str,
            type: &quot;text&quot;,
        });
        update_datastring();
    }
    that.save_text = save_text;

    /**
     * Setter for the artname of a linked ink&#x27;s associated artwork
     */
    function setArtName(name) {
        artName = name;
    }
    that.setArtName = setArtName;

    /**
     * Set the svg element to handle all pointer events so we can draw on it
     * (and also to prevent manipulation of artwork during ink creation)
     */
    function set_editable() {
        var svgelt = getSVGElement();
        //svgelt.style.zIndex = -1;
        svgelt.style.background = &quot;rgba(0, 0, 0, 0)&quot;;
        svgelt.style.pointerEvents = &quot;all&quot;;
    }
    that.set_editable = set_editable;

    /**
     * Setter (sets experience id of ink)
     */
    function setEID(inEID) {
        EID = inEID;
    }
    that.setEID = setEID;

    /**
     * Sets the initial artwork keyframe
     */
    function setInitKeyframeData(kf) {
        initKeyframe = kf;
    }
    that.setInitKeyframeData = setInitKeyframeData;

    /**
     * Sets the ink mode
     */
    function set_mode(i) {
        i = parseInt(i,10);
        mode = i;
    }
    that.set_mode = set_mode;

    /**
     * Sets the internal reference to the old opacity of the ink track
     */
    function setOldOpac(val) {
        oldOpac = val;
    }
    that.setOldOpac = setOldOpac;

    /**
     * Similar to the retrieveOrigDims function, but uses a proxy variable.
     */
    function setOrigDims(proxy) {
        var kfx = initKeyframe.x;
        var kfy = initKeyframe.y;
        var kfw = initKeyframe.w;
        var real_kfw = origPaperW / kfw;
        var real_kfh = real_kfw * (proxy.h / proxy.w);
        var real_kfx = -kfx * real_kfw;
        var real_kfy = -kfy * real_kfh;
        origpx = real_kfx;
        origpy = real_kfy;
        origpw = real_kfw;
        origph = real_kfh;
        lastpx = origpx;
        lastpy = origpy;
        lastpw = origpw;
        lastph = origph;
    }
    that.setOrigDims = setOrigDims;

    function resetText() {
        datastring = &quot;&quot;;
    }
    that.resetText = resetText;

    /**
     * Similar to add_attributes, gives text boxes drag functionality, drag handles, and undo/redo functionality.
     * @param textbox   the text box in question
     */
    function setTextAttributes(textbox) {
        var C1; //drag handles
        var rds = LADS.TourAuthoring.Constants.inkDragHandleRadius;
        var x = textbox.attrs.x,
            y = textbox.attrs.y,
            origposition = { x: 0, y: 0, },
            c1origposition = { x: 0, y: 0, },
            boundingBox = textbox.getBBox();
        var handlerad = LADS.TourAuthoring.Constants.inkDragHandleRadius;

        // set the positions of C1 and C2 using the styling of textbox
        C1 = paper.ellipse(x, y, rds - 2, rds - 2).attr({ &quot;stroke-width&quot;: 2, &quot;stroke&quot;: &quot;#ffffff&quot;, &quot;fill&quot;: &quot;#296B2F&quot;, &quot;fill-opacity&quot;: 0.8 }).data(&quot;type&quot;, &quot;grabHandle&quot;);
        C1.toFront();
        textbox.toFront();
        C1.data(&quot;curr_cx&quot;, C1.attr(&quot;cx&quot;));
        C1.data(&quot;curr_cy&quot;, C1.attr(&quot;cy&quot;));
        textbox.data({
            &#x27;x&#x27;: x,
            &#x27;y&#x27;: y,
        });

        // drag handler for C1 -- the pan handle.....
        C1.drag(function (dx, dy, mousex, mousey) { // move
            var circleRadius = C1.attr(&quot;rx&quot;);
            //Hard stops for textbox location in ink canvas
            if (origposition.x + dx &lt;= circleRadius + 5) {
                dx = (circleRadius + 5) - origposition.x;
            }
            if (origposition.y + dy &lt;= circleRadius + 5) {
                dy = (circleRadius + 5) - origposition.y;
            }
            if (origposition.x + dx &gt;= canvwidth - (circleRadius + 5)) {
                dx = canvwidth - (circleRadius + 5) - origposition.x;
            }
            if (origposition.y + dy &gt;= canvheight - (circleRadius + 5)) {
                dy = canvheight - (circleRadius + 5) - origposition.y;
            }

            var c1currx = parseInt(this.data(&quot;curr_cx&quot;),10); // x position at the start of drag
            var c1curry = parseInt(this.data(&quot;curr_cy&quot;),10);
            var xpos = c1currx + dx; // to get new x position, just add dx
            var ypos = c1curry + dy;
            this.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            // move the textbox
            textbox.attr(&quot;x&quot;, origposition.x + dx);
            textbox.attr(&quot;y&quot;, origposition.y + dy);
        },
        function (x, y) { // start -- record original positions
            origposition.x = parseFloat(textbox.attrs.x);
            origposition.y = parseFloat(textbox.attrs.y);

            var bbox = C1.getBBox();
            c1origposition.x = bbox.x;
            c1origposition.y = bbox.y;
            c1origposition.w = bbox.width;
            c1origposition.h = bbox.height;
        },
        function (x, y) { // stop -- deal with undo/redo functionality
            var c1bboxx = this.getBBox().x;
            var c1bboxy = this.getBBox().y;
            var c1bboxw = this.getBBox().width;
            var c1bboxh = this.getBBox().height;
            this.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0); // reset data using bounding box coords
            this.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);

            textbox.data({
                &quot;x&quot;: textbox.attrs.x,
                &quot;y&quot;: textbox.attrs.y
            });

            var bboxx = parseFloat(textbox.attrs.x);
            var bboxy = parseFloat(textbox.attrs.y);

            c1bboxx = C1.getBBox().x;
            c1bboxy = C1.getBBox().y;
            c1bboxw = C1.getBBox().width;
            c1bboxh = C1.getBBox().height;

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var command = LADS.TourAuthoring.Command({
                execute: function () {
                    svgText.attr({ x: bboxx });
                    svgText.attr({ y: bboxy });
                    textbox.attr({ x: bboxx, y: bboxy });
                    textbox.data({ x: bboxx, y: bboxy });

                    C1.data(&quot;curr_cx&quot;, c1bboxx + c1bboxw / 2.0);
                    C1.data(&quot;curr_cy&quot;, c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                },
                unexecute: function () {
                    svgText.attr({ x: ox });
                    svgText.attr({ y: oy });
                    textbox.attr({ x: ox, y: oy });
                    textbox.data({ x: ox, y: oy });

                    C1.data(&quot;curr_cx&quot;, o1x + o1w / 2.0);
                    C1.data(&quot;curr_cy&quot;, o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });
    }
    that.setTextAttributes = setTextAttributes;

    /**
     * Takes transparency bounding shapes and converts them to bezier paths
     * @param shapes     array of shapes to convert
     * @return    array of corresponding paths
     */
    function shapes_to_paths (shapes) {
        //takes in an array of shapes, returns an array of paths
        var cw = domelement.width();
        var ch = domelement.height();
        var paths = [];
        remove_all();/////////////////
        for (var i = 0; i &lt; shapes.length; i++) {
            var shape = shapes[i];
            var path;
            var type = shape.type.toLowerCase();
            if (shape.type == &quot;rect&quot;) { // in this case, bezier path is just four corners with bezier anchors along each segment
                var x = parseFloat(shape.X) / cw;
                var y = parseFloat(shape.Y) / ch;
                var w = parseFloat(shape.w) / cw;
                var h = parseFloat(shape.h) / ch;
                var xoff = 10.0 / cw;
                var yoff = 10.0 / ch;
                path = &quot;M&quot; + x + &quot;,&quot; + y + &quot;C&quot; + (x + xoff) + &quot;,&quot; + y + &quot;,&quot; + (x + w - xoff) + &quot;,&quot; + y + &quot;,&quot; + (x + w) + &quot;,&quot; + y + &quot;C&quot; + (x + w) + &quot;,&quot; + (y + yoff) + &quot;,&quot; + (x + w) + &quot;,&quot; + (y + h - yoff) + &quot;,&quot; + (x + w) + &quot;,&quot; + (y + h) + &quot;C&quot; + (x + w - xoff) + &quot;,&quot; + (y + h) + &quot;,&quot; + (x + xoff) + &quot;,&quot; + (y + h) + &quot;,&quot; + (x) + &quot;,&quot; + (y + h) + &quot;C&quot; + x + &quot;,&quot; + (y + h - yoff) + &quot;,&quot; + (x) + &quot;,&quot; + (y + yoff) + &quot;,&quot; + (x) + &quot;,&quot; + (y) + &quot;z&quot;;
            }
            else if (shape.type == &quot;ellipse&quot;) { // bezier path is four points (north, east, south, west) with bezier anchors vertical/horizonal from the points a certain distance (given by the &#x27;magic number&#x27; below)
                var cx = parseFloat(shape.cx) / cw;
                var cy = parseFloat(shape.cy) / ch;
                var rx = parseFloat(shape.rx) / cw;
                var ry = parseFloat(shape.ry) / ch;
                var k = (4.0 / 3.0) * (Math.sqrt(2) - 1); // &#x27;magic number&#x27; defining bezier anchor coordinates for ellipses
                path = &quot;M&quot; + cx + &quot;,&quot; + (cy - ry) + &quot;C&quot; + (cx + rx * k) + &quot;,&quot; + (cy - ry) + &quot;,&quot; + (cx + rx) + &quot;,&quot; + (cy - ry * k) + &quot;,&quot; + (cx + rx) + &quot;,&quot; + cy + &quot;C&quot; + (cx + rx) + &quot;,&quot; + (cy + ry * k) + &quot;,&quot; + (cx + rx * k) + &quot;,&quot; + (cy + ry) + &quot;,&quot; + cx + &quot;,&quot; + (cy + ry) + &quot;C&quot; + (cx - rx * k) + &quot;,&quot; + (cy + ry) + &quot;,&quot; + (cx - rx) + &quot;,&quot; + (cy + ry * k) + &quot;,&quot; + (cx - rx) + &quot;,&quot; + cy + &quot;C&quot; + (cx - rx) + &quot;,&quot; + (cy - ry * k) + &quot;,&quot; + (cx - rx * k) + &quot;,&quot; + (cy - ry) + &quot;,&quot; + cx + &quot;,&quot; + (cy - ry) + &quot;z&quot;;
            }
            paths.push(path);
        }
        get_outer_path(paths);
        return paths;
    }
    that.shapes_to_paths = shapes_to_paths;

    /**
     * Debugging function; prints out the ink path in our ink track
     */
    function showInkPath() {
        try {
            console.log(&quot;showInkPath gives: &quot; + inktrack.getInkPath());
        }
        catch (err) {
            console.log(&quot;error in showInkPath: &quot; + err.message);
        }
    }
    that.showInkPath = showInkPath;

    /**
     * Scales a path representing a transparency/marquee.
     * @param pth               the path whose coordinates we&#x27;ll scale
     * @param trans_factor_x    scale factor in x-direction
     * @param trans_factor_y    scale factor in y-direction
     * @return   scaled path
     */
    function transform_pathstring_marq (pth, trans_factor_x, trans_factor_y) {
        var nums = pth.match(/[0-9.\-]+/g); // gets coordinates from path
        var newpath = &quot;&quot;;
        var j = 0, n = pth.length;
        for (var i = 0; i &lt; n; i++) {
            if ((pth[i] == &quot;M&quot;) || (pth[i] == &quot;L&quot;)) { // if M or L, need to scale next two coords
                newpath = newpath + pth[i];
                newpath += (parseFloat(nums[j]) * trans_factor_x).toFixed(6) + &quot;,&quot;;
                newpath += (parseFloat(nums[j + 1]) * trans_factor_y).toFixed(6);
                j = j + 2;
            }
            else if (pth[i] == &quot;C&quot;) { // if C, need to scale next six coords
                newpath = newpath + pth[i];
                newpath += (parseFloat(nums[j]) * trans_factor_x).toFixed(6) + &quot;,&quot;;
                newpath += (parseFloat(nums[j + 1]) * trans_factor_y).toFixed(6) + &quot;,&quot;;
                newpath += (parseFloat(nums[j + 2]) * trans_factor_x).toFixed(6) + &quot;,&quot;;
                newpath += (parseFloat(nums[j + 3]) * trans_factor_y).toFixed(6) + &quot;,&quot;;
                newpath += (parseFloat(nums[j + 4]) * trans_factor_x).toFixed(6) + &quot;,&quot;;
                newpath += (parseFloat(nums[j + 5]) * trans_factor_y).toFixed(6);
                j = j + 6;
            }
            else if (pth[i] == &quot;z&quot;) { // if z, close path
                newpath += &quot;z&quot;;
            }
        }
        return newpath;
    }
    that.transform_pathstring_marq = transform_pathstring_marq;

    /**
     * Returns a string giving all necessary information to recreate the current scene.
     * The result is stored in ink tracks as the &#x27;datastring.&#x27; Also used throughout
     * InkAuthoring to make sure we have an up to date datastring. The formats for each
     * type of ink is given below (note that the trailing &#x27;[]&#x27; makes it easier to parse).
     * Note that the MARQUEE type is deprecated -- it has been replaced by TRANS type
     * transparencies represented by paths rather than collections of rectangles. The
     * BOUNDRECT and BOUNDELLIPSE types are for reloading rectangles and ellipses when we
     * edit transparencies (their formats are identical to RECT/ELLIPSE). All coordinates are relative.
     *
     *   PATH::[pathstring]&lt;svg path string&gt;[stroke]&lt;color&gt;[strokeo]&lt;opacity&gt;[strokew]&lt;width&gt;[]
     *   RECT::[x]&lt;x&gt;[y]&lt;y&gt;[w]&lt;width&gt;[h]&lt;height&gt;[fillc]&lt;color&gt;[fillo]&lt;opac&gt;[strokec]&lt;color&gt;[strokeo]&lt;opac&gt;[strokew]&lt;width&gt;[]
     *   ELLIPSE::[cx]&lt;center x&gt;[cy]&lt;center y&gt;[rx]&lt;x radius&gt;[ry]&lt;y radius&gt;[fillc]&lt;color&gt;[fillo]&lt;opac&gt;[strokec]&lt;color&gt;[strokeo]&lt;opac&gt;[strokew]&lt;width&gt;[]
     *   MARQUEE::[x]&lt;x&gt;[y]&lt;y&gt;[w]&lt;width&gt;[h]&lt;height&gt;[surrfillc]&lt;fill color&gt;[surrfillo]&lt;fill opac&gt;[]
     *   TEXT::[str]&lt;text&gt;[font]&lt;font&gt;[fontsize]&lt;fontsize&gt;[color]&lt;font color&gt;[x]&lt;x&gt;[y]&lt;y&gt;[w]&lt;width&gt;[h]&lt;height&gt;[]
     *   TRANS::[path]&lt;path&gt;[color]&lt;color&gt;[opac]&lt;opac&gt;[mode]&lt;block or isolate&gt;[]
     *   BOUNDRECT::[x]&lt;x&gt;[y]&lt;y&gt;[w]&lt;width&gt;[h]&lt;height&gt;[fillc]&lt;color&gt;[fillo]&lt;opac&gt;[strokec]&lt;color&gt;[strokeo]&lt;opac&gt;[strokew]&lt;width&gt;[]
     *   BOUNDELLIPSE::[cx]&lt;center x&gt;[cy]&lt;center y&gt;[rx]&lt;x radius&gt;[ry]&lt;y radius&gt;[fillc]&lt;color&gt;[fillo]&lt;opac&gt;[strokec]&lt;color&gt;[strokeo]&lt;opac&gt;[strokew]&lt;width&gt;[]
     *
     * @return    up to date datastring
     */
    function update_datastring () {
        var data_string = &quot;&quot;;
        var canv_width = domelement.width();
        var canv_height = domelement.height();
        var pth;
        if (currpaths) { // add pen paths to datastring
            if (currpaths.split(&quot;Mundefined&quot;).length &gt; 1)
                currpaths = currpaths.split(&quot;Mundefined&quot;).join(&quot;&quot;);
            data_string += currpaths;
        }
        if (trans_currpath) { // add transparency paths to datastring
            data_string += trans_currpath;
        }
        if (cpathstring) {
            data_string += cpathstring.replace(/undefined/g, &#x27;&#x27;);
        }

        paper.forEach(function (elt) { // now check the canvas for rectangles, ellipses, text, old marquees
            if (elt.data(&quot;type&quot;) === &quot;rect&quot; &amp;&amp; elt.data(&quot;visible&quot;) === &quot;yes&quot;) {
                pth = &quot;RECT::[x]&quot; + rel_dims(elt.attr(&quot;x&quot;), canv_width) + &quot;[y]&quot; + rel_dims(elt.attr(&quot;y&quot;), canv_height);
                pth += &quot;[w]&quot; + rel_dims(elt.attr(&quot;width&quot;), canv_width) + &quot;[h]&quot; + rel_dims(elt.attr(&quot;height&quot;), canv_height);
                pth += &quot;[fillc]&quot; + elt.attr(&quot;fill&quot;) + &quot;[fillo]&quot; + elt.attr(&quot;fill-opacity&quot;);
                pth += &quot;[strokec]&quot; + elt.attr(&quot;stroke&quot;) + &quot;[strokeo]&quot; + elt.attr(&quot;stroke-opacity&quot;) + &quot;[strokew]&quot; + elt.attr(&quot;stroke-width&quot;) + &quot;[]&quot;;
                data_string += pth + &quot;|&quot;;
            }
            else if (elt.data(&quot;type&quot;) === &quot;ellipse&quot; &amp;&amp; elt.data(&quot;visible&quot;) === &quot;yes&quot;) {
                pth = &quot;ELLIPSE::[cx]&quot; + rel_dims(elt.attr(&quot;cx&quot;), canv_width) + &quot;[cy]&quot; + rel_dims(elt.attr(&quot;cy&quot;), canv_height);
                pth += &quot;[rx]&quot; + rel_dims(elt.attr(&quot;rx&quot;), canv_width) + &quot;[ry]&quot; + rel_dims(elt.attr(&quot;ry&quot;), canv_height);
                pth += &quot;[fillc]&quot; + elt.attr(&quot;fill&quot;) + &quot;[fillo]&quot; + elt.attr(&quot;fill-opacity&quot;);
                pth += &quot;[strokec]&quot; + elt.attr(&quot;stroke&quot;) + &quot;[strokeo]&quot; + elt.attr(&quot;stroke-opacity&quot;) + &quot;[strokew]&quot; + elt.attr(&quot;stroke-width&quot;) + &quot;[]&quot;;
                data_string += pth + &quot;|&quot;;
            }
            else if (elt.data(&quot;type&quot;) === &quot;marquee&quot;) { //old marquees
                pth = &quot;MARQUEE::[x]&quot; + rel_dims(elt.attr(&quot;x&quot;), canv_width);
                pth = pth + &quot;[y]&quot; + rel_dims(elt.attr(&quot;y&quot;), canv_height);
                pth += &quot;[w]&quot; + rel_dims(elt.attr(&quot;width&quot;), canv_width) + &quot;[h]&quot; + rel_dims(elt.attr(&quot;height&quot;), canv_height);
                pth += &quot;[surrfillc]&quot; + elt.data(&quot;surr-fill&quot;) + &quot;[surrfillo]&quot; + elt.data(&quot;surr-opac&quot;) + &quot;[]&quot;;
                data_string += pth + &quot;|&quot;;
            }
            else if (elt.data(&quot;type&quot;) === &quot;text&quot;) {
                pth = &quot;TEXT::[str]&quot; + elt.data(&quot;str&quot;)
                    + &quot;[font]&quot; + elt.data(&quot;font&quot;)
                    + &quot;[fontsize]&quot; + rel_dims(elt.data(&quot;fontsize&quot;), canv_height) //scale font-size
                    + &quot;[color]&quot; + elt.data(&quot;color&quot;)
                    + &quot;[x]&quot; + rel_dims(elt.data(&quot;x&quot;), canv_width)
                    + &quot;[y]&quot; + rel_dims(elt.data(&quot;y&quot;), canv_height)
                    + &quot;[w]&quot; + elt.data(&#x27;w&#x27;)
                    + &quot;[h]&quot; + elt.data(&#x27;h&#x27;)
                    + &quot;[]&quot;;
                data_string += pth + &quot;|&quot;;
            }
        });
        datastring = data_string;
        return data_string;
    }
    that.update_datastring = update_datastring;

    /**
     * When we load in a path datastring, update ml, xy, and pa to reflect the new data.
     * @param str   the datastring loaded
     */
    function update_ml_xy_pa (str) {
        var i, j;

        // add info to ml and pa
        for (i = 0; i &lt; str.length; i++) {
            if ((str[i] === &quot;L&quot;) || (str[i] === &quot;M&quot;)) {
                var cpth = str.substring(i).split(&quot;|&quot;)[0];
                var strokec = get_attr(cpth, &quot;stroke&quot;, &quot;s&quot;);
                var strokeo = get_attr(cpth, &quot;strokeo&quot;, &quot;f&quot;);
                var strokew = get_attr(cpth, &quot;strokew&quot;, &quot;f&quot;);
                ml.push(str[i]);
                pa.push({ &quot;color&quot;: strokec, &quot;opacity&quot;: strokeo, &quot;width&quot;: strokew });
            }
        }

        // add info to xy (probably easier with regular expressions)
        var arr1 = str.split(&quot;L&quot;);
        for (i = 0; i &lt; arr1.length; i++) {
            if (arr1[i].length &gt; 0) {
                var arr2 = arr1[i].split(&quot;M&quot;);
                for (j = 0; j &lt; arr2.length; j++) {
                    if (arr2[j].length &gt; 0 &amp;&amp; arr2[j].charAt(0) != &#x27;P&#x27;) {
                        var arr3 = arr2[j].split(&quot;,&quot;);
                        xy.push([parseFloat(arr3[0]), parseFloat(arr3[1])]);
                    }
                }
            }
        }
        click = false;
    }
    that.update_ml_xy_pa = update_ml_xy_pa;

    /**
     * The following are setters for various ink parameters
     * @param _    the value to be set to the corresponding ink parameter
     */
    function setPenColor(c) { penColor = (c[0] == &#x27;#&#x27;) ? c : (&quot;#&quot; + c); }
    function setPenOpacity(o) { penOpacity = o; }
    function setPenWidth(w) { penWidth = w; }
    function setEraserWidth(w) { eraserWidth = w; }
    function setShapeStrokeColor(c) { shapeStrokeColor = (c[0] == &#x27;#&#x27;) ? c : (&quot;#&quot; + c); }
    function setShapeStrokeOpacity(o) { shapeStrokeOpacity = o; }
    function setShapeStrokeWidth(w) { shapeStrokeWidth = w; }
    function setMarqueeFillColor(c) { marqueeFillColor = (c[0] == &#x27;#&#x27;) ? c : (&quot;#&quot; + c); }
    function setMarqueeFillOpacity(o) { marqueeFillOpacity = o; }
    function setEnabled(en) { enabled = end; }
    function setFontFamily(f) {
        fontFamily = f;
        if (svgText) {
            svgText.attr({
                &quot;font-family&quot;: fontFamily,
            });
            svgText.data({
                &quot;font&quot;: fontFamily,
            });
        }
    }
    function setFontSize(f) {
        // set the value to &quot;&quot;, change font size, reset the value so we can see the results in real-time
        fontSize = f;
        if (svgText) {
            svgText.attr({
                &quot;font-size&quot;: fontSize
            });
            svgText.data({
                &quot;fontsize&quot;: fontSize
            });
        }
    }
    function setFontColor(f) {
        fontColor = (f[0] == &#x27;#&#x27;) ? f : (&quot;#&quot; + f);
        if (svgText) {
            svgText.attr({
                &quot;fill&quot;: fontColor
            });
            svgText.data({
                &quot;color&quot;: fontColor
            });
        }
    }
    function setFontOpacity(f) { fontOpacity = f; }
    function setTransMode(m) { trans_mode = m; }

    that.setPenColor = setPenColor;
    that.setPenOpacity = setPenOpacity;
    that.setPenWidth = setPenWidth;
    that.setEraserWidth = setEraserWidth;
    that.setShapeStrokeColor = setShapeStrokeColor;
    that.setShapeStrokeOpacity = setShapeStrokeOpacity;
    that.setShapeStrokeWidth = setShapeStrokeWidth;
    that.setMarqueeFillColor = setMarqueeFillColor;
    that.setMarqueeFillOpacity = setMarqueeFillOpacity;
    that.setEnabled = setEnabled;
    that.setFontFamily = setFontFamily;
    that.setFontSize = setFontSize;
    that.setFontColor = setFontColor;
    that.setFontOpacity = setFontOpacity;
    that.setTransMode = setTransMode;

    /**
     * The following are getters for different ink parameters.
     */
    function getPenColor() { return penColor; }
    function getPenOpacity() { return penOpacity; }
    function getPenWidth() { return penWidth; }
    function getEraserWidth() { return eraserWidth; }
    function getShapeStrokeColor() { return shapeStrokeColor; }
    function getShapeStrokeOpacity() { return shapeStrokeOpacity; }
    function getShapeStrokeWidth() { return shapeStrokeWidth; }
    function getMarqueeFillColor() { return marqueeFillColor; }
    function getMarqueeFillOpacity() { return marqueeFillOpacity; }
    function getEnabled() { return enabled; }
    function getFontFamily() { return fontFamily; }
    function getFontSize() { return fontSize; }
    function getFontColor() { return fontColor; }
    function getFontOpacity() { return fontOpacity; }
    function getTransMode() { return trans_mode; }

    that.getPenColor = getPenColor;
    that.getPenOpacity = getPenOpacity;
    that.getPenWidth = getPenWidth;
    that.getEraserWidth = getEraserWidth;
    that.getShapeStrokeColor = getShapeStrokeColor;
    that.getShapeStrokeOpacity = getShapeStrokeOpacity;
    that.getShapeStrokeWidth = getShapeStrokeWidth;
    that.getMarqueeFillColor = getMarqueeFillColor;
    that.getMarqueeFillOpacity = getMarqueeFillOpacity;
    that.getEnabled = getEnabled;
    that.getFontFamily = getFontFamily;
    that.getFontSize = getFontSize;
    that.getFontColor = getFontColor;
    that.getFontOpacity = getFontOpacity;
    that.getTransMode = getTransMode;

    /**
     * The following are essentially setters, but they take in an id, grab the
     * value of the dom element with that id, and set the correct variable accordingly
     * @param id   the id of the dom element whose value we want to use
     */
    function updatePenColor(id) {
        var val = document.getElementById(id).value;
        //console.log(&quot;col = &quot; + val);
        if (val !== undefined) {
            if (val.indexOf(&quot;#&quot;) == -1)
                val = &quot;#&quot; + val;
            penColor = val;
        }
    }
    function updatePenOpacity(id) {
        var val = document.getElementById(id).value;
        //console.log(&quot;opac = &quot; + val);
        if (val !== undefined)
            penOpacity = val;
    }
    function updatePenWidth(id) {
        var val = document.getElementById(id).value;
        //console.log(&quot;wid = &quot; + val);
        if (val !== undefined)
            penWidth = val;
    }
    function updateEraserWidth(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            eraserWidth = val;
    }
    function updateShapeStrokeColor(id) {
        var val = document.getElementById(id).value;
        if (val.length === 6) {
            shapeStrokeColor = &quot;#&quot; + val;
        }
    }
    function updateShapeStrokeOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            shapeStrokeOpacity = val;
    }
    function updateShapeStrokeWidth(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            shapeStrokeWidth = val;
    }
    function updateShapeFillColor(id) {
        var val = document.getElementById(id).value;
        if (val.length === 6)
            shapeFillColor = &quot;#&quot; + val;
    }
    function updateShapeFillOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            shapeFillOpacity = val;
    }
    function updateMarqueeColor(id) {
        var val = document.getElementById(id).value;
        if (val.length === 6)
            marqueeFillColor = val;
    }
    function updateMarqueeOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            marqueeFillOpacity = val;
    }
    function updateFontFamily(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            fontFamily = val;
        }
    }
    function updateFontSize(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            fontSize = parseFloat(val);
        }
    }
    function updateFontColor(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            if (val.indexOf(&quot;#&quot;) == -1)
                val = &quot;#&quot; + val;
            fontColor = val;
        }
    }
    function updateFontOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            fontOpacity = val;
        }
    }

    that.updatePenColor = updatePenColor;
    that.updatePenOpacity = updatePenOpacity;
    that.updatePenWidth = updatePenWidth;
    that.updateEraserWidth = updateEraserWidth;
    that.updateShapeStrokeColor = updateShapeStrokeColor;
    that.updateShapeStrokeOpacity = updateShapeStrokeOpacity;
    that.updateShapeFillColor = updateShapeFillColor;
    that.updateShapeFillOpacity = updateShapeFillOpacity;
    that.updateMarqueeColor = updateMarqueeColor;
    that.updateMarqueeOpacity = updateMarqueeOpacity;
    that.updateFontFamily = updateFontFamily;
    that.updateFontSize = updateFontSize;
    that.updateFontColor = updateFontColor;
    that.updateFontOpacity = updateFontOpacity;

    //////// NEW PATH SMOOTHING CODE //////////
    var points = [],
        roughPoints = [],
        paper,
        thresh = 8,
        closeThresh = 5,
        canBeClosed = false,
        pathstring = &quot;&quot;,
        closeCircle,
        old_points = [],
        old_pa = [],
        cpathstring = &quot;&quot;,
        old_pathstring = &#x27;&#x27;,
        canvW, canvH;
    domelement.on(&#x27;mousedown&#x27;, mstart);
    domelement.on(&#x27;mouseenter&#x27;, function() { // change cursor styling here
        domelement.css(&#x27;cursor&#x27;, ((mode == 1) || (mode == 2)) ? &#x27;crosshair&#x27; : &#x27;pointer&#x27;);
    });

    function distance(pt1, pt2, cw, ch) {
        var dx = (pt1[0] - pt2[0]) * (cw || 1);
        var dy = (pt1[1] - pt2[1]) * (ch || 1);
        return Math.sqrt(dx*dx + dy*dy);
    }

    // get array of coordinates from a pathstring (x, y, x, y, ...)
    function extractCoords(pthstr) {
        var strCoords = pthstr.match(/[0-9.\-]+/g) || [];
        var coords = [];
        for (var i = 0; i &lt; strCoords.length; i++) {
            coords.push(parseFloat(strCoords[i]));
        }
        return coords;
    }

    // get array of letters from a pathstring (&#x27;M&#x27;, &#x27;R&#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27;M&#x27;, &#x27;L&#x27;, ...)
    function extractLetters(pthstr) {
        return pthstr.match(/[MLR ]/g) || [];
    }

    // merge a coordinate array and a letter array to produce a pathstring
    function mergeToPath(letters, coords) {
        var merged = &quot;&quot;, i;
        for (i = 0; i &lt; letters.length; i++) {
            merged += letters[i] + coords[2 * i] + &quot;,&quot; + coords[2 * i + 1];
        }
        //points = coords.slice(0);
        return merged;
    }

    function saveOldValues() {
        old_pa = pa.slice(0);
        old_pathstring = pathstring;
    }

    // called on mousedown to start drawing
    function mstart(e) {
        e.stopImmediatePropagation();
        e.stopPropagation();
        if (!(mode === 1 || mode === 2)) return;
        canvW = viewerElt.width(),
        canvH = viewerElt.height();
        
        click = true;
        points.length = 0;
        roughPoints.length = 0;

        // for undo/redo
        saveOldValues();

        if (mode === 1) { // draw
            pa.push({ color: penColor, opacity: penOpacity, width: penWidth / canvH });
            points.push([e.offsetX/canvW, e.offsetY/canvH]);
            constructBezierPath();
        } else if (mode === 2) { // erase
            eraseBezier([e.offsetX, e.offsetY]);
            drawBezierPath();
        }
        
        domelement.on(&#x27;mousemove&#x27;, mmove);
        domelement.on(&#x27;mouseup&#x27;, mend);
        domelement.on(&#x27;mouseleave&#x27;, mend);
    }

    // called on mousemove to continue drawing
    function mmove(e) {
        var len = points.length,
            pt = [e.offsetX / canvW, e.offsetY / canvH],
            ptAbs = [e.offsetX, e.offsetY];
        if (mode === 1) { // draw
            //console.log(&quot;ptAbs = &quot; + ptAbs[0] + &quot;,&quot; + ptAbs[1]);
            if (len === 0 || distance(ptAbs, [points[len - 1][0]*canvW, points[len-1][1]*canvH]) &gt; thresh) {
                roughPoints.length = 0;
                points.push(pt);
                constructBezierPath();
            } else {
                roughPoints.push(pt);
                constructBezierPath();
            }
            //drawBezierPath();
        } else if (mode === 2) { // erase
            eraseBezier([e.offsetX, e.offsetY]);
            drawBezierPath();
        }
    }

    // called on mouseup and mouseleave to stop drawing
    function mend(e) {
        if (points.length &gt; 0) {
            constructBezierPath(true);
        }
        click = false;
        points.length = 0;
        roughPoints.length = 0;
        domelement.off(&#x27;mousemove&#x27;);
        domelement.off(&#x27;mouseup&#x27;);
        domelement.off(&#x27;mouseleave&#x27;);
        var new_data = { pathstring: pathstring, pa: pa };
        var old_data = { pathstring: old_pathstring, pa: old_pa };
        var command = LADS.TourAuthoring.Command({
            execute: function () {
                pathstring = new_data.pathstring;
                pa = new_data.pa.slice(0);
                drawBezierPath();
            },
            unexecute: function () {
                pathstring = old_data.pathstring;
                pa = old_data.pa.slice(0);
                drawBezierPath();
            }
        });
        command.execute();
        inkUndoManager.logCommand(command);

        //console.log(&#x27;pathstring = &#x27;+pathstring);
    }

    // draws either the given path or pathstring if none is provided
    function drawBezierPath(str) {
        var cw = viewerElt.width();
        var ch = viewerElt.height();
        var pathsToDraw=[], pathsToSave=&#x27;&#x27;, pathToDraw=&#x27;&#x27;;
        var raphaelpath = &#x27;&#x27;,
            roughpath=&#x27;&#x27;,
            i, path, circle;
        str = str || pathstring;
        paper.clear();
        if (!str) return;
        var MRL = extractLetters(str);
        var coords = extractCoords(str);
        
        var paCount = 0;
        for (i = 0; i &lt; MRL.length; i++) { //construct the paths
            if (MRL[i] === &#x27;M&#x27;) {
                pathsToSave += &quot;BEZIER::[pathstring]&quot;;
            }
            //console.log(&quot;ch*coords[&quot;+(2*i+1)+&quot;] = &quot;+ch*coords[2*i+1]);
            pathToDraw += MRL[i] + (cw * coords[2*i]) + &#x27;,&#x27; + (ch * coords[2*i+1]); // absolute coords
            pathsToSave += MRL[i] + coords[2*i] + &#x27;,&#x27; + coords[2*i+1]; // relative coords
            if (MRL[i + 1] === &#x27;M&#x27; || i === MRL.length - 1) {
                pathsToDraw.push(pathToDraw);
                pathToDraw = &#x27;&#x27;;
                pathsToSave += &quot;[stroke]&quot; + pa[paCount].color + &quot;[strokeo]&quot; + pa[paCount].opacity + &quot;[strokew]&quot; + pa[paCount].width + &quot;[]|&quot;;
                paCount++;
            }
        }
        //console.log(&quot;to save: &quot;+pathsToSave);
        for (i = 0; i &lt; pathsToDraw.length; i++) { // need to split up the paths so we can style each separately
            //console.log(&quot;to draw: &quot; + pathsToDraw[i]);
            var drawing = paper.path(pathsToDraw[i]); // draw the path to the canvas
            drawing.data(&quot;type&quot;, &quot;bezier&quot;);
            drawing.attr({
                &quot;stroke-width&quot;: pa[i].width * ch,
                &quot;stroke-opacity&quot;: pa[i].opacity,
                &quot;stroke&quot;: pa[i].color,
                &quot;stroke-linejoin&quot;: &quot;round&quot;,
                &quot;stroke-linecap&quot;: &quot;round&quot;
            });
        }
        cpathstring = pathsToSave; // currpaths is used in update_datastring as the string representing all paths on the canvas
    }
    that.drawBezierPath = drawBezierPath;

    // constructs bezier path to draw
    function constructBezierPath(clip) {
        var raphaelpath = &#x27;&#x27;,
            roughpath = &#x27;&#x27;,
            i, path, circle, len = points.length, rlen = roughPoints.length,
            p1x = points[0][0], p1y = points[0][1],
            rp1x, rp1y, matches;
        
        if (len === 1) {
            raphaelpath = &quot;M&quot;+p1x+&quot;,&quot;+p1y+&quot;L&quot;+p1x+&quot;,&quot;+p1y;
        } else if (len === 2) {
            raphaelpath = &quot;M&quot; + p1x + &quot;,&quot; + p1y + &quot;L&quot; + points[1][0] + &quot;,&quot; + points[1][1];//+&quot; &quot;+points[1][0]+&quot;,&quot;+points[1][1];
        } else if (len &gt; 2) {
            raphaelpath = &quot;M&quot;+p1x+&quot;,&quot;+p1y+&quot;R&quot;;
            for (i = 1; i &lt; len; i++) {
                raphaelpath+=((i===1) ? &quot;&quot; : &quot; &quot;)+points[i][0]+&quot;,&quot;+points[i][1];
            }
        }
        if (rlen &gt; 0) {
            rp1x = roughPoints[0][0];
            rp1y = roughPoints[0][1];
            if(len &gt; 0) {
                for (i = 0; i &lt; rlen; i++) {
                    roughpath+=&quot; &quot;+roughPoints[i][0]+&quot;,&quot;+roughPoints[i][1];
                }
            } else {
                if (rlen === 1) {
                    roughpath = &quot;M&quot; + rp1x + &quot;,&quot; + rp1y + &quot;L&quot; + rp1x + &quot;,&quot; + rp1y;
                }
                else if (rlen === 2) {
                    roughpath = &quot;M&quot; + rp1x + &quot;,&quot; + rp1y + &quot;L&quot; + roughPoints[1][0] + &quot;,&quot; + roughPoints[1][1];
                } else {
                    roughpath = &quot;M&quot; + rp1x + &quot;,&quot; + rp1y + &quot;R&quot;;
                    for (i = 1; i &lt; rlen; i++) {
                        roughpath += ((i === 1) ? &quot;&quot; : &quot; &quot;) + roughPoints[i][0] + &quot;,&quot; + roughPoints[i][1];
                    }
                }
            }
        }
        if(clip) {
            pathstring += raphaelpath;
            matches = pathstring.match(/[MLR ]/g);
            if (matches &amp;&amp; matches[matches.length - 1] !== &#x27;L&#x27;) {
                pathstring += (rlen === 0) ? &quot;&quot; : &quot; &quot; + roughPoints[rlen - 1][0] + &quot;,&quot; + roughPoints[rlen - 1][1];
            }
            drawBezierPath();
        } else {
            drawBezierPath(pathstring+raphaelpath+roughpath);
        }
    }

    // erase a portion of the bezier path
    function eraseBezier(location) {
        if (!pathstring) return;
        var cw = domelement.width(),
            ch = domelement.height(),
            coords = extractCoords(pathstring),
            letters = extractLetters(pathstring),
            currentPAIndex = -1;
        //console.log(&quot;start pathstring = &quot; + pathstring);
        for (var i = 0; i &lt; letters.length; i++) { // for each coordinate, test for proximity to location
            if (letters[i] === &#x27;M&#x27;) {
                currentPAIndex++;
            }
            if (distance(location,[cw*coords[2*i], ch*coords[2*i+1]]) &lt; eraserWidth) {
                if (letters[i] === &#x27;M&#x27;) {
                    if (letters[i + 1] === &#x27;R&#x27;) {
                        if (letters[i + 3] === &#x27;M&#x27; || !letters[i + 3]) { // here, we have M-R-_-M, turn to gone-M-L-M
                            //console.log(&#x27;case 1&#x27;);
                            letters.splice(i, 3, &#x27;M&#x27;, &#x27;L&#x27;);
                            coords.splice(2*i, 2);
                        } else { // here, M-R-_-_, turn to gone-M-R-_
                            //console.log(&#x27;case 2&#x27;);
                            letters.splice(i, 3, &#x27;M&#x27;, &#x27;R&#x27;);
                            coords.splice(2 * i, 2);
                        }
                    } else if (letters[i + 1] === &#x27;L&#x27;) { // M-L-M or M-L-done, turn to gone-M or gone-done
                        //console.log(&#x27;case 3&#x27;);
                        letters.splice(i, 2);
                        coords.splice(2 * i, 4);
                        pa.splice(currentPAIndex, 1);
                    }
                } else if (letters[i] === &#x27;L&#x27;) { // M-L, turn to gone
                    //console.log(&#x27;case 4&#x27;);
                    letters.splice(i - 1, 2);
                    coords.splice(2 * (i - 1), 4);
                    pa.splice(currentPAIndex, 1);
                } else if (letters[i] === &#x27;R&#x27;) {
                    if (letters[i + 2] === &#x27;M&#x27; || !letters[i + 2]) { // M-R-_-M or M-R-_-done, turn to gone-M or gone
                        //console.log(&#x27;case 5&#x27;);
                        letters.splice(i - 1, 3);
                        coords.splice(2 * (i - 1), 6);
                        pa.splice(currentPAIndex, 1);
                    } else if (letters[i+3] ===&#x27; &#x27;) { // M-R-_-_-_-, turn to M-R-_-
                        //console.log(&#x27;case 6&#x27;);
                        letters.splice(i - 1, 4,&#x27;M&#x27;,&#x27;R&#x27;);
                        coords.splice(2 * (i - 1), 4);
                    } else {
                        //console.log(&#x27;case 6.5&#x27;);
                        letters.splice(i - 1, 4, &#x27;M&#x27;, &#x27;L&#x27;);
                        coords.splice(2 * (i - 1), 4);
                    }
                } else if (letters[i] === &quot; &quot;) {
                    if (letters[i + 1] === &#x27;M&#x27; || !letters[i + 1]) {
                        if (letters[i - 1] === &#x27;R&#x27;) { // M-R-_-M or M-R-_-M, turn to gone-M or gone
                            //console.log(&#x27;case 7&#x27;);
                            letters.splice(i - 2, 3);
                            coords.splice(2 * (i - 2), 6);
                            pa.splice(currentPAIndex, 1);
                        } else { // R-_-_-M or R-_-_, turn to R-_
                            //console.log(&#x27;case 8&#x27;);
                            letters.splice(i, 1);
                            coords.splice(2 * i, 2);
                        }
                    } else if (letters[i + 1] === &#x27; &#x27; &amp;&amp; letters[i + 2] === &#x27; &#x27; &amp;&amp; letters[i + 3] === &#x27; &#x27;) { // R-_-*-_, turn to R-_-M-R-_
                        //console.log(&#x27;case 8.1&#x27;);
                        letters.splice(i, 3, &quot;M&quot;, &quot;R&quot;);
                        coords.splice(2 * i, 2);
                        pa.splice(currentPAIndex,0,pa[currentPAIndex]);
                    } else if (letters[i + 1] === &#x27; &#x27; &amp;&amp; letters[i + 2] === &#x27; &#x27;) {
                        //console.log(&#x27;case 8.2&#x27;);
                        letters.splice(i,3,&quot;M&quot;,&quot;L&quot;);
                        coords.splice(2 * i, 2);
                        pa.splice(currentPAIndex, 0, pa[currentPAIndex]);
                    } else if (letters[i + 1] === &#x27; &#x27;) {
                        //console.log(&#x27;case 8.3&#x27;);
                        letters.splice(i,2);
                        coords.splice(2*i,4);
                    } else {
                        //console.log(&#x27;case 8.4&#x27;);
                        letters.splice(i,1);
                        coords.splice(2*i,2);
                    }
                }
                //break;
            }
        }
        currentPAIndex = -1;
        var lastM = 0;
        for (i = 0; i &lt; letters.length; i++) {
            if (letters[i] === &#x27;M&#x27;) {
                lastM = i;
                currentPAIndex++
                if (letters[i + 1] === &#x27;R&#x27; &amp;&amp; letters[i + 2] !== &#x27; &#x27;) {
                    letters.splice(i, 2);
                    coords.splice(2 * i, 4);
                    i--;
                    pa.splice(currentPAIndex, 1);
                    currentPAIndex--;
                    lastM--;
                    continue;
                }
            }
            if (isNaN(coords[2 * i]) || isNaN(coords[2 * i + 1])) {
                for (var j = 0; j &lt; letters.length - i; j++) {
                    if (letters[j + 1] === &#x27;M&#x27; &amp;&amp; !letters[j + 1]) {
                        letters.splice(lastM, i + j - lastM);
                        coords.splice(2 * lastM, 2 * (i + j - lastM));
                        pa.splice(currentPAIndex, 1);
                        currentPAIndex--;
                        i = lastM;
                        continue;
                    }
                }
            }
        }
        pathstring = mergeToPath(letters, coords);
        if (pathstring.match(/undefined/) || (pathstring &amp;&amp; pathstring[0] !== &#x27;M&#x27;)) {
            console.log(&#x27;uh oh&#x27;);
        }
    }
    that.erase = erase;

    // setter for distance between bezier points
    function setThresh(val) {
        thresh = parseInt(val, 10);
    }

    // setter for close path threshold
    function setCloseThresh(val) {
        closeThresh = parseInt(val, 10);
    }
    //////////////////////////////////////////

    // allow drawing on the Raphael paper by recording mouse locations on mousemove events, add coordinates to xl (similar with erase) (old code removed)
    var old_ml = [], old_xy = [], old_pa = [], canvwidth, canvheight;
    
    return that;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
