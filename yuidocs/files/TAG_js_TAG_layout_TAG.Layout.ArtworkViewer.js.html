<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>TAG/js/TAG/layout/TAG.Layout.ArtworkViewer.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../TAG/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/TAG.AnnotatedImage.html">TAG.AnnotatedImage</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkViewer.html">TAG.Layout.ArtworkViewer</a></li>
            
                <li><a href="../classes/TAG.Layout.CollectionsPage.html">TAG.Layout.CollectionsPage</a></li>
            
                <li><a href="../classes/TAG.Layout.InternetFailurePage.js.html">TAG.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/TAG.Layout.StartPage.html">TAG.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG.Layout.VideoPlayer.html">TAG.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG.Util.Artwork.html">TAG.Util.Artwork</a></li>
            
                <li><a href="../classes/TAG.Util.IdleTimer.html">TAG.Util.IdleTimer</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: TAG/js/TAG/layout/TAG.Layout.ArtworkViewer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿TAG.Util.makeNamespace(&quot;TAG.Layout.ArtworkViewer&quot;);

/**
 * The artwork viewer, which contains a sidebar with tools and thumbnails as well
 * as a central area for the deepzoom image.
 * @class TAG.Layout.ArtworkViewer
 * @constructor
 * @param {Object} options        some options for the artwork viewer page
 * @return {Object}               some public methods
 */
TAG.Layout.ArtworkViewer = function (options) { // prevInfo, options, exhibition) {
    &quot;use strict&quot;;

    options = options || {}; // cut down on null checks later

    var // DOM-related
        root                = TAG.Util.getHtmlAjax(&#x27;Artmode.html&#x27;),
        sideBar             = root.find(&#x27;#sideBar&#x27;),
        toggler             = root.find(&#x27;#toggler&#x27;),
        togglerImage        = root.find(&#x27;#togglerImage&#x27;),
        backButton          = root.find(&#x27;#backButton&#x27;),
        locHistoryDiv       = root.find(&#x27;#locationHistoryDiv&#x27;),
        info                = root.find(&#x27;#info&#x27;),
        locHistoryToggle    = root.find(&#x27;#locationHistoryToggle&#x27;),
        locHistory          = root.find(&#x27;#locationHistory&#x27;),
        locHistoryContainer = root.find(&#x27;#locationHistoryContainer&#x27;),

        // constants
        FIX_PATH = TAG.Worktop.Database.fixPath,

        // input options
        doq            = options.doq,              // the artwork doq
        prevPage       = options.prevPage,         // the page we came from (string)
        prevScroll     = options.prevScroll || 0,  // scroll position where we came from
        prevCollection = options.prevCollection,   // collection we came from, if any

        // misc initialized vars  
        locHistoryActive = false,                   // whether location history is open
        locClosing       = false,                   // wheter location history is closing
        locOpening       = false,                   // whether location history is opening
        drawers          = [],                      // the expandable sections for assoc media, tours, description, etc...
        mediaHolders     = [],                      // array of thumbnail buttons
        loadQueue        = TAG.Util.createQueue(), // async queue for thumbnail button creation, etc


        // misc uninitialized vars
        locationList,                               // location history data
        map,                                        // Bing Maps map for location history
        annotatedImage,                             // an AnnotatedImage object
        associatedMedia,                            // object of associated media objects generated by AnnotatedImage
        manipulate;                                 // Manipulation method
        
    // get things rolling if doq is defined (it better be)
    doq &amp;&amp; init();

    return {
        getRoot: getRoot
    };

    /**
     * Initiate artmode with a root, artwork image and a sidebar on the left
     * @method init
     */
    function init() {
        var head,
            script,
            meta;

        idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
        idleTimer.start();

        // add script for displaying bing maps
        head = document.getElementsByTagName(&#x27;head&#x27;).item(0);
        script = document.createElement(&quot;script&quot;);
        script.charset = &quot;UTF-8&quot;;
        script.type = &quot;text/javascript&quot;;
        script.src = &quot;http://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&quot;;
        head.appendChild(script);

        meta = document.createElement(&#x27;meta&#x27;);
        meta.httpEquiv = &quot;Content-Type&quot;;
        meta.content = &quot;text/html; charset=utf-8&quot;;
        head.appendChild(meta);

        locationList = TAG.Util.UI.getLocationList(doq.Metadata);

        annotatedImage = TAG.AnnotatedImage({
            root: root,
            doq:  doq,
            callback: function () {
                associatedMedia = annotatedImage.getAssociatedMedia();
                associatedMedia.guids.sort(function (a, b) {
                    return associatedMedia[a].doq.Name.toLowerCase() &lt; associatedMedia[b].doq.Name.toLowerCase() ? -1 : 1;
                });
                try { // TODO figure out why loadDoq sometimes causes a NetworkError (still happening?)
                    annotatedImage.openArtwork(doq);
                } catch(err) {
                    debugger;
                    console.log(err); // TODO if we hit a network error, show an error message
                }
                TAG.Util.Splitscreen.setViewers(root, annotatedImage); // TODO should we get rid of all splitscreen stuff?
                makeSidebar();
                createSeadragonControls();
            },
            noMedia: false
        });
    }

    /**
     * Add controls and key handlers for manual Seadragon manipulation
     * @method createSeadragonControls
     */
    function createSeadragonControls() {
        var container        = root.find(&#x27;#seadragonManipContainer&#x27;),
            slideButton      = root.find(&#x27;#seadragonManipSlideButton&#x27;),
            tagRoot          = $(&#x27;#tagRoot&#x27;),
            CENTER_X         = tagRoot.width()/2,
            CENTER_Y         = tagRoot.height()/2,
            D_PAD_TOP        = 26,
            D_PAD_LEFT       = 60,
            top              = 0,
            count            = 0,
            panDelta         = 20,
            zoomScale        = 1.1,
            containerFocused = true,
            interval;

        container.css(&#x27;left&#x27;, ($(&#x27;#tagRoot&#x27;).width() - 160) + &quot;px&quot;); // do this with &#x27;right&#x27; instead

        slideButton.on(&#x27;click&#x27;, function () {
            count = 1 - count;
            container.animate({
                top: top
            });
            if (count === 0){
                top = 0;
                slideButton.html(&quot;Show Controls&quot;);
            } else {
                top = -100;
                slideButton.html(&#x27;Hide Controls&#x27;);
            }   
        });
        
        container.append(slideButton);
        container.append(createButton(&#x27;leftControl&#x27;,  tagPath+&#x27;images/icons/zoom_left.svg&#x27;,  D_PAD_LEFT,    D_PAD_TOP+14));
        container.append(createButton(&#x27;upControl&#x27;,    tagPath+&#x27;images/icons/zoom_up.svg&#x27;,    D_PAD_LEFT+12, D_PAD_TOP+2));
        container.append(createButton(&#x27;rightControl&#x27;, tagPath+&#x27;images/icons/zoom_right.svg&#x27;, D_PAD_LEFT+41, D_PAD_TOP+14));
        container.append(createButton(&#x27;downControl&#x27;,  tagPath+&#x27;images/icons/zoom_down.svg&#x27;,  D_PAD_LEFT+12, D_PAD_TOP+43));
        container.append(createButton(&#x27;zinControl&#x27;,   tagPath+&#x27;images/icons/zoom_plus.svg&#x27;,  D_PAD_LEFT-40, D_PAD_TOP-6));
        container.append(createButton(&#x27;zoutControl&#x27;,  tagPath+&#x27;images/icons/zoom_minus.svg&#x27;, D_PAD_LEFT-40, D_PAD_TOP+34));

        /////////////////////////// RAPID PROTOTYPING /////////////////////////////

        var crossfadeSlider = $(document.createElement(&#x27;input&#x27;)).attr({
            &#x27;id&#x27;: &#x27;crossfadeSlider&#x27;,
            &#x27;type&#x27;: &#x27;range&#x27;,
            &#x27;value&#x27;: 1,
            &#x27;min&#x27;: 0,
            &#x27;max&#x27;: 1,
            &#x27;step&#x27;: 0.05
        });

        crossfadeSlider.on(&#x27;change mousemove&#x27;, function() {
            $(&#x27;.mediaOuterContainer&#x27;).css(&#x27;opacity&#x27;, crossfadeSlider.val());
        });
        // container.append(crossfadeSlider);

        ///////////////////////////////////////////////////////////////////////////



        /**
         * Create a seadragon control button
         * @method createButton
         * @param {String} id        the id for the new button
         * @param {String} imgPath   the path to the button&#x27;s image
         * @param {Number} left      css left property for button
         * @param {Number} top       css top property for button
         * @return {jQuery obj}      the button
         */
        function createButton(id, imgPath, left, top) {
            var img = $(document.createElement(&#x27;img&#x27;));

            img.attr({
                src: imgPath,
                id:  id
            });
            
            img.css({
                left: left + &quot;px&quot;,
                top:  top  + &quot;px&quot;
            });

            if (id === &#x27;leftControl&#x27; || id === &#x27;rightControl&#x27;){
                img.addClass(&#x27;seadragonManipButtonLR&#x27;);
            } else if (id === &#x27;upControl&#x27;|| id === &#x27;downControl&#x27;){
                img.addClass(&#x27;seadragonManipButtonUD&#x27;);
            } else if (id === &#x27;zinControl&#x27;|| id === &#x27;zoutControl&#x27;){
                img.addClass(&#x27;seadragonManipButtoninout&#x27;);
            }

            return img;
        }
    
        
        /**
         * Keydown handler for artwork manipulation; wrapper around doManip that first
         * prevents default key behaviors
         * @method keyHandler
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function keyHandler(evt, direction) {
            evt.preventDefault();
            clearInterval(interval);
            doManip(evt, direction);
        }

        /**
         * Click handler for button in given direction; a wrapper around doManip that also
         * executes doManip in an interval if the user is holding down a button
         * @method buttonHandler
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function buttonHandler(evt, direction) {
            doManip(evt, direction);
            clearInterval(interval);
            interval = setInterval(function() {
                doManip(evt, direction);
            }, 100);
        }

        /**
         * Do fixed manipulation in response to seadragon controls or key presses
         * @method doManip
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function doManip(evt, direction) {
            manipulate = annotatedImage.getToManip();

             var pivot = {
                    x: annotatedImage.getMediaDimensions().width / 2,
                    y: annotatedImage.getMediaDimensions().height / 2
                };

            if (direction === &#x27;left&#x27;) {
                manipulate({pivot: pivot, translation: {x: -panDelta, y: 0}, scale: 1});
            } else if (direction === &#x27;up&#x27;) {
                manipulate({pivot: pivot, translation: {x: 0, y: -panDelta}, scale: 1});
            } else if (direction === &#x27;right&#x27;) {
                manipulate({pivot: pivot, translation: {x: panDelta, y: 0}, scale: 1});
            } else if (direction === &#x27;down&#x27;) {
                manipulate({pivot: pivot, translation: {x: 0, y: panDelta}, scale: 1});
            } else if (direction === &#x27;in&#x27;) {
                manipulate({pivot: pivot, translation: {x: 0, y: 0}, scale: zoomScale});
            } else if (direction === &#x27;out&#x27;) {
                manipulate({pivot: pivot, translation: {x: 0, y: 0}, scale: 1/zoomScale});
            }   
        }


        // tabindex code is to allow key press controls (focus needs to be on the TAG container)
        $(&#x27;#tagContainer&#x27;).attr(&quot;tabindex&quot;, -1);
        $(&quot;[tabindex=&#x27;-1&#x27;]&quot;).focus();
        $(&quot;[tabindex=&#x27;-1&#x27;]&quot;).css(&#x27;outline&#x27;, &#x27;none&#x27;);
        $(&quot;[tabindex=&#x27;-1&#x27;]&quot;).on(&#x27;click&#x27;, function() {
            $(&quot;[tabindex=&#x27;-1&#x27;]&quot;).focus();
            containerFocused = true;
            annotatedImage.dzManipPreprocessing();     //Tell AnnotatedImage that the main artwork is active
        });
        $(&quot;[tabindex=&#x27;-1&#x27;]&quot;).focus(function() {
            containerFocused = true;
        });
        $(&quot;[tabindex=&#x27;-1&#x27;]&quot;).focusout(function() {
            containerFocused = false;
        });



        $(document).on(&#x27;keydown&#x27;, function(evt) {
            if(containerFocused) {
                switch(evt.which) {
                    case 37:
                        keyHandler(evt, &#x27;left&#x27;);
                        break;
                    case 38:
                        keyHandler(evt, &#x27;up&#x27;);
                        break;
                    case 39:
                        keyHandler(evt, &#x27;right&#x27;);
                        break;
                    case 40:
                        keyHandler(evt, &#x27;down&#x27;);
                        break;
                    case 187:
                    case 61:
                        keyHandler(evt, &#x27;in&#x27;);
                        break;
                    case 189:
                    case 173:
                        keyHandler(evt, &#x27;out&#x27;);
                        break;
                }
            }
        });

        $(document).keyup(function(evt){
            clearInterval(interval);
        });

        $(&#x27;#seadragonManipContainer&#x27;).on(&#x27;click&#x27;, function(evt) {
            evt.stopPropagation(); //Prevent the click going through to the main container
            evt.preventDefault();
            TAG.Util.IdleTimer.restartTimer();
        });

        $(&#x27;#leftControl&#x27;).on(&#x27;mousedown&#x27;, function(evt) {
            buttonHandler(evt, &#x27;left&#x27;);
        });
        $(&#x27;#upControl&#x27;).on(&#x27;mousedown&#x27;, function(evt) {
            buttonHandler(evt, &#x27;up&#x27;);
        });
        $(&#x27;#rightControl&#x27;).on(&#x27;mousedown&#x27;, function(evt) {
            buttonHandler(evt, &#x27;right&#x27;);
        });
        $(&#x27;#downControl&#x27;).on(&#x27;mousedown&#x27;, function(evt) {
            buttonHandler(evt, &#x27;down&#x27;);
        });
        $(&#x27;#zinControl&#x27;).on(&#x27;mousedown&#x27;, function(evt) {
            buttonHandler(evt, &#x27;in&#x27;);
        });
        $(&#x27;#zoutControl&#x27;).on(&#x27;mousedown&#x27;, function(evt) {
            buttonHandler(evt, &#x27;out&#x27;);
        });

        $(&#x27;.seadragonManipButtonLR&#x27;).on(&#x27;mouseup mouseleave&#x27;, function() {
            clearInterval(interval);
        });

        $(&#x27;.seadragonManipButtonUD&#x27;).on(&#x27;mouseup mouseleave&#x27;, function() {
            clearInterval(interval);
        });

        $(&#x27;.seadragonManipButtoninout&#x27;).on(&#x27;mouseup mouseleave&#x27;, function() {
            clearInterval(interval);
        });
    }

    /**
     * Makes the artwork viewer sidebar
     * @method makeSidebar
     */
    function makeSidebar() {
        var backBttnContainer = root.find(&quot;#backBttnContainer&quot;),
            sideBarSections   = root.find(&#x27;#sideBarSections&#x27;),
            sideBarInfo       = root.find(&#x27;#sideBarInfo&#x27;),
            infoTitle         = root.find(&#x27;#infoTitle&#x27;),
            infoArtist        = root.find(&#x27;#infoArtist&#x27;),
            infoYear          = root.find(&#x27;#infoYear&#x27;),
            assetContainer    = root.find(&#x27;#assetContainer&#x27;),
            isBarOpen         = true,
            currBottom        = 0,
            item,
            fieldTitle,
            fieldValue,
            infoCustom,
            i,
            curr,
            button,
            descriptionDrawer,
            tourDrawer,
            locHistoryButton,
            mediaDrawer;


        
        backButton.attr(&#x27;src&#x27;,tagPath+&#x27;images/icons/Back.svg&#x27;);
        togglerImage.attr(&quot;src&quot;, tagPath+&#x27;images/icons/Close.svg&#x27;);
        infoTitle.text(doq.Name);
        infoArtist.text(doq.Metadata.Artist);
        infoYear.text(doq.Metadata.Year);
        

        // toggler to hide/show sidebar
        toggler.on(&#x27;click&#x27;, function () {
            var opts = {};
            opts.left = isBarOpen ? &#x27;-22%&#x27; : &#x27;0%&#x27;
            isBarOpen = !isBarOpen;
            sideBar.animate(opts, 1000, function () {
                togglerImage.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/&#x27; + (isBarOpen ? &#x27;Close.svg&#x27; : &#x27;Open.svg&#x27;));
            });
        });

        TAG.Util.UI.setUpBackButton(backButton, goBack);
        TAG.Telemetry.register(backButton, &#x27;click&#x27;, &#x27;artwork_to_collections&#x27;, function(tobj) {
            tobj.work_name = doq.Name;
            tobj.work_guid = doq.Identifier;
        });

        function goBack() {
            var collectionsPage;
            backButton.off(&#x27;click&#x27;);
            idleTimer &amp;&amp; idleTimer.kill();
            idleTimer = null;
            annotatedImage &amp;&amp; annotatedImage.unload();
            collectionsPage = new TAG.Layout.CollectionsPage({
                backScroll:     prevScroll,
                backArtwork:    doq,
                backCollection: prevCollection
            });
            TAG.Util.UI.slidePageRightSplit(root, collectionsPage.getRoot(), function () {});

            currentPage.name = TAG.Util.Constants.pages.COLLECTIONS_PAGE;
            currentPage.obj  = collectionsPage;
        }


        // add more information for the artwork if curator added in the authoring mode
        for (item in doq.Metadata.InfoFields) {
            if(doq.Metadata.InfoFields.hasOwnProperty(item)) {
                fieldTitle = item;
                fieldValue = doq.Metadata.InfoFields[item];
                infoCustom = $(document.createElement(&#x27;div&#x27;));
                infoCustom.addClass(&#x27;infoCustom&#x27;);
                infoCustom.text(fieldTitle + &#x27;: &#x27; + fieldValue);
                infoCustom.appendTo(info);
            }
        }

        // make sure the info text fits in the div (TODO is this necessary?)
        TAG.Util.fitText(info, 1.1);

        // create drawers
        if (doq.Metadata.Description) {
            descriptionDrawer = createDrawer(&quot;Description&quot;);
            descriptionDrawer.contents.html(Autolinker.link(doq.Metadata.Description.replace(/\n/g, &quot;&lt;br /&gt;&quot;), {email: false, twitter: false}));
            assetContainer.append(descriptionDrawer);
            currBottom = descriptionDrawer.height();
        }
 
        if (locationList.length &gt; 0) {
            locHistoryButton = initlocationHistory();
            assetContainer.append(locHistoryButton);
            currBottom += locHistoryButton.height();
        } else {
            $(&#x27;#locationHistoryContainer&#x27;).remove();
        }

        if (associatedMedia.guids.length &gt; 0) {
            mediaDrawer = createDrawer(&#x27;Associated Media&#x27;);
            for(i=0; i&lt;associatedMedia.guids.length; i++) {
                curr = associatedMedia[associatedMedia.guids[i]];
                loadQueue.add(createMediaButton(mediaDrawer.contents, curr));
            }
            assetContainer.append(mediaDrawer);
            currBottom += mediaDrawer.height();
        }

        /**
         * Creates a tour thumbnail button
         * @method createTourButton
         * @param {jQuery obj} container     the element to which we&#x27;ll append this button
         * @param {doq} tour                 the tour doq
         */
        function createTourButton(container, tour) {
            return function() {
                container.append(TAG.Util.Artwork.createThumbnailButton({
                    title:       TAG.Util.htmlEntityDecode(tour.Name),
                    handler:     tourClicked(tour),
                    buttonClass: &#x27;tourButton&#x27;,
                    src:         (tour.Metadata.Thumbnail ? FIX_PATH(tour.Metadata.Thumbnail) : tagPath+&#x27;images/tour_icon.svg&#x27;)
                }));
            }
        }

        /**
         * Creates a thumbnail button for an associated media
         * @method createMediaButton
         * @param {jQuery obj} container       the element to which we&#x27;ll append the button
         * @param {Object} media               an associated media object (from AnnotatedImage)
         */
        function createMediaButton(container, media) {
            return function() {
                var src = &#x27;&#x27;,
                    metadata = media.doq.Metadata,
                    thumb = metadata.Thumbnail;

                switch (metadata.ContentType) {
                    case &#x27;Audio&#x27;:
                        src = tagPath+&#x27;images/audio_icon.svg&#x27;;
                        break;
                    case &#x27;Video&#x27;:
                        src = (thumb &amp;&amp; !thumb.match(/.mp4/)) ? FIX_PATH(thumb) : &#x27;images/video_icon.svg&#x27;;
                        break;
                    case &#x27;Image&#x27;:
                        src = thumb ? FIX_PATH(thumb) : FIX_PATH(metadata.Source);
                        break;
                    default:
                        src = tagPath + &#x27;images/text_icon.svg&#x27;;
                        break;
                }

                container.append(TAG.Util.Artwork.createThumbnailButton({
                    title:       TAG.Util.htmlEntityDecode(media.doq.Name),
                    handler:     mediaClicked(media),
                    buttonClass: &#x27;mediaButton&#x27;,
                    buttonID:    &#x27;thumbnailButton-&#x27;+media.doq.Identifier,
                    src:         src
                }));
            }
        }

        /**
         * Generates a click handler for a specific associated media object
         * @method mediaClicked
         * @param {Object} media       the associated media object (from AnnotatedImage)
         */
        function mediaClicked(media) {
            return function (evt) {
                evt.stopPropagation();
                locHistoryActive &amp;&amp; toggleLocationPanel();
                media.create(); // returns if already created
                media.toggle();
                TAG.Util.IdleTimer.restartTimer();
                media.mediaManipPreprocessing();                    //Set the newly opened media as active for manipulation
                media.pauseReset();
            };
        }

        // Load tours and filter for tours associated with this artwork
        TAG.Worktop.Database.getTours(function (tours) {
            var relatedTours,
                maxHeight;

            relatedTours = tours.filter(function (tour) {
                var relatedArtworks;
                if (!tour.Metadata || !tour.Metadata.RelatedArtworks || tour.Metadata.Private === &quot;true&quot;) {
                    return false;
                }
                relatedArtworks = JSON.parse(tour.Metadata.RelatedArtworks);
                if(!relatedArtworks || !relatedArtworks.length) {
                    return false;
                }
                return relatedArtworks.indexOf(doq.Identifier) &gt;= 0;
            });

            if (relatedTours.length &gt; 0) {
                tourDrawer = createDrawer(&#x27;Tours&#x27;);
                assetContainer.append(tourDrawer);
                currBottom += tourDrawer.height();

                tourDrawer.contents.text(&#x27;&#x27;);
                for(i=0; i&lt;relatedTours.length; i++) {
                    loadQueue.add(createTourButton(tourDrawer.contents, relatedTours[i]));
                }
            }

            // set max height of drawers to avoid expanding into minimap area
            maxHeight = Math.max(1, assetContainer.height() - currBottom- root.find(&quot;.drawerLabel&quot;).height()); //to account for the height of the drawerLabel of the current drawer.
            console.log(currBottom);
            root.find(&quot;.drawerContents&quot;).css({
                &quot;max-height&quot;: maxHeight + &quot;px&quot;,

            });
        });

        function tourClicked(tour) {
            return function () {
                var rinData,
                    parentid,
                    prevInfo,
                    rinPlayer;
                
                idleTimer &amp;&amp; idleTimer.kill();
                idleTimer = null;

                annotatedImage.unload();
                prevInfo = { artworkPrev: &quot;artmode&quot;, prevScroll: prevScroll };
                rinData = JSON.parse(unescape(tour.Metadata.Content));
                rinPlayer = new TAG.Layout.TourPlayer(rinData, prevCollection, prevInfo, options);
            
                TAG.Util.UI.slidePageLeftSplit(root, rinPlayer.getRoot(), rinPlayer.startPlayback);
            };
        }

        /*************************************************************************
         * MINIMAP CODE. bleveque: didn&#x27;t rewrite this; separate issue
         *                         if some variable names are off now, let me know
         */

        //Create minimapContainer...
        var minimapContainer = root.find(&#x27;#minimapContainer&#x27;);

        sideBarSections.append(minimapContainer);

        //A white rectangle for minimap to show the current shown area for artwork
        var minimaprect = root.find(&#x27;#minimaprect&#x27;);

        //Load deepzoom thumbnail. 
        var img = new Image();
        var loaded = false;
        var AR = 1;//ratio between width and height.
        var minimapw = 1;//minimap width
        var minimaph = 1;//minimap height
        var minimap;

        /*
        **Load the image of artwork and initialize the minimap rectangle
        * @method minimapLoaded
        */
        function minimapLoaded() {
            if (loaded) return;
            loaded = true;
            //load the artwork image
            minimap = root.find(&#x27;#minimap&#x27;);
            minimap.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(doq.URL));

            //make the minimap not moveable. 
            minimap.mousedown(function () {
                return false;
            });

            TAG.Util.disableDrag(minimapContainer);

            AR = img.naturalWidth / img.naturalHeight;
            var heightR = img.naturalHeight / $(minimapContainer).height();//the ratio between the height of image and the container.
            var widthR = img.naturalWidth / $(minimapContainer).width();//ratio between the width of image and the container.
            //make sure the whole image shown inside the container based on the longer one of height and width.
            if (heightR &gt; widthR) {
                minimap.removeAttr(&quot;height&quot;);
                minimap.removeAttr(&quot;width&quot;);
                minimap.css({ &quot;height&quot;: &quot;100%&quot; });
            }
            else {
                minimap.removeAttr(&quot;height&quot;);
                minimap.removeAttr(&quot;width&quot;);
                minimap.css({ &quot;width&quot;: &quot;100%&quot; });
            }

            //make the image manipulatable. 
            var gr = TAG.Util.makeManipulatable(minimap[0],
            {
                onManipulate: onMinimapManip,
                onScroll: onMinimapScroll,
                onTapped: onMinimapTapped
            }, true);

            /**********************/
            var minimaph = minimap.height();
            var minimapw = minimap.width();

            //centers rectangle
            var minimapt = (minimapContainer.height() / 2) - (minimap.height() / 2);
            var minimapl = (minimapContainer.width() / 2) - (minimap.width() / 2);
            minimaprect.css({
                width: (minimapw - 1) + &quot;px&quot;,
                height: (minimaph - 1) + &quot;px&quot;,
                top: minimapt + &quot;px&quot;,
                left: (minimapl - 1) + &quot;px&quot;
            });
            /*********************/
        }
        /*
        **Implement manipulation function from makeManipulatable.
        * @method onMinimapManip
        * @param {Object} evt        object containing hammer event info 
        */
        function onMinimapManip(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css(&#x27;marginLeft&#x27;));

            //find pivot and translation of manipulation event
            var px = evt.pivot.x;
            var py = evt.pivot.y;
            var tx = evt.translation.x;
            var ty = evt.translation.y;

            var x = px + tx;
            var y = py + ty;
            x = (x - minimapl) / minimapw;
            y = (y - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1 + (1 - evt.scale);
            if (s) annotatedImage.viewer.viewport.zoomBy(s, false);
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }
        /**Implement scroll function from makeManipulatable
         * @method onMinimapScroll
         * @param {Number} scale     scale factor
         * @param {Object} pivot     x and y location of event
         */
        function onMinimapScroll(scale, pivot) {
            //create hammer event and pass into onMinimapManip
            onMinimapManip({
                scale: scale,
                translation: {
                    x: 0,
                    y: 0
                },
                pivot: pivot
            });    
        }
        /**Implement tapped function from makeManipulatable
        * @method onMinimapTapped
        * @param {Object} evt        object containing hammer event info
        */
        function onMinimapTapped(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css(&#x27;marginLeft&#x27;));

            var xPos = evt.position.x;
            var yPos = evt.position.y;
            var x =(xPos-minimapl)/ minimapw;
            var y = (yPos-minimapt)/minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1;
            if (s) annotatedImage.viewer.viewport.zoomBy(s, false);
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        img.onload = minimapLoaded;
        //should be complete image of artwork NOT thumbnail
        img.src = TAG.Worktop.Database.fixPath(doq.URL);
        if (img.complete) {
            minimapLoaded();
        }
        /*
        **Move the minimap rectangle based on the manipulation of the image
        * @method dzMoveHandler
        * @param {event} evt            manipulation event of the image
        */
        function dzMoveHandler(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();

            //centers rectangle
            var minimapt = (minimapContainer.height() / 2) - (minimap.height() / 2);
            var minimapl = (minimapContainer.width() / 2) - (minimap.width() / 2);

            var viewport = evt.viewport;
            var rect = viewport.getBounds(true);
            var tl = rect.getTopLeft();
            var br = rect.getBottomRight();
            var x = tl.x;
            var y = tl.y;
            var xp = br.x;
            var yp = br.y;
            if (x &lt; 0) x = 0;
            if (y &lt; 0) y = 0;
            if (xp &gt; 1) xp = 1;
            if (yp &gt; 1 / AR) yp = 1 / AR;
            y = y * AR;
            yp = yp * AR;
            yp = yp - y;
            xp = xp - x;
            x = minimapl + x * minimapw;
            y = minimapt + y * minimaph;
            xp = xp * minimapw;
            yp = yp * minimaph;
            minimaprect.css({
                width: (xp-1) + &quot;px&quot;,
                height: (yp - 1) + &quot;px&quot;,
                top: y + &quot;px&quot;,
                left: (x-1) + &quot;px&quot;
            });
        }
        annotatedImage.addAnimateHandler(dzMoveHandler);

        //condition to check for overlap of the assetscontainer with minimap. If they overlap, we restrict the height of #info div to its original max-height.
        var overlap = !(assetContainer.right &lt; minimapContainer.left || 
                assetContainer.left &gt; minimapContainer.right || 
                assetContainer.bottom &lt; minimapContainer.top || 
                assetContainer.top &gt; minimapContainer.bottom)

        if (overlap) {
        
            info.css({

                &#x27;overflow-y&#x27; : &#x27;auto&#x27;,
                &#x27;max-height&#x27; : &#x27;5em&#x27;,

            });

    }
        /*
         * END MINIMAP CODE
         ******************/
    }

    /**
     * Create a drawer with a disclosure button used to display
     * hotspots, assets, tours. The returned jQuery object has
     * a property called &quot;contents&quot; which should be used to add
     * buttons or messages to the contents of the drawer.
     *
     * @param title, the display title for the drawer
     * @author jastern
     */
    function initlocationHistory() {
        if(locationList.length === 0) {
            locHistoryContainer.remove();
            return;
        }

        var locHistoryPanel      = root.find(&#x27;#locationHistoryPanel&#x27;),
            locHistoryToggleIcon = root.find(&#x27;#locationHistoryToggleIcon&#x27;),
            mapOverlay           = $(TAG.Util.UI.blockInteractionOverlay()).addClass(&#x27;mapOverlay&#x27;),
            overlayLabel         = $(document.createElement(&#x27;label&#x27;)),
            lpContents           = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;lpContents&#x27;),
            lpTitle              = $(document.createElement(&#x27;div&#x27;)),
            lpMapDiv             = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;lpMapDiv&#x27;),
            lpTextInfoDiv        = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;lpTextInfoDiv&#x27;),
            lpTextDiv            = $(document.createElement(&#x27;div&#x27;)).addClass(&quot;lpTextDiv&quot;),
            lpInfoDiv            = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;lpInfoDiv&#x27;);

        overlayLabel.text(&#x27;Map has no location history to display.&#x27;);
        overlayLabel.attr(&#x27;id&#x27;, &#x27;mapOverlayLabel&#x27;);
        mapOverlay.append(overlayLabel);

        lpContents.append(mapOverlay);
        locHistoryPanel.append(lpContents);

        lpTitle.attr(&#x27;id&#x27;, &#x27;lpTitle&#x27;);
        lpTitle.text(&#x27;Location History&#x27;);
        lpContents.append(lpTitle);

        lpMapDiv.attr(&#x27;id&#x27;, &#x27;lpMapDiv&#x27;);
        lpContents.append(lpMapDiv);

        lpContents.append(lpTextInfoDiv);
        lpTextInfoDiv.append(lpTextDiv);
        lpTextInfoDiv.append(lpInfoDiv);

        locHistoryToggle.css({
            left: &#x27;87.5%&#x27;,
            &#x27;border-bottom-right-radius&#x27;: &#x27;10px&#x27;,
            &#x27;border-top-right-radius&#x27;: &#x27;10px&#x27;
        });
        locHistoryToggleIcon.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/Close.svg&#x27;);


        locHistoryToggle.on(&#x27;click&#x27;, toggleLocationPanel);
        locHistoryContainer.on(&#x27;click&#x27;, histOnClick);

        /**
         * A callback function to populate the location history map after it has been created
         * @method prepMap
         */
        function prepMap () {
            var unselectedCSS = {
                    &#x27;background-color&#x27;: &#x27;transparent&#x27;,
                    &#x27;color&#x27;: &#x27;white&#x27;
                },
                selectedCSS = {
                    &#x27;background-color&#x27;: &#x27;white&#x27;,
                    &#x27;color&#x27;: &#x27;black&#x27;,
                },
                address,
                date,
                year,
                i,
                locBox,
                pushpinOptions;

            /**
             * Helper function to draw pushpin on location history map when a location&#x27;s info
             * box is clicked
             * @method drawPinHelper
             * @param {Object} e    event data related to a location
             */
            function drawPinHelper(e) {
                var $this = $(this),
                    latitude,
                    longitude,
                    location,
                    viewOptions;

                TAG.Util.UI.drawPushpins(locationList, map);

                lpInfoDiv.html($this.html() + &quot;&lt;br/&gt;&quot; + (e.data.info ? e.data.info : &#x27;&#x27;));

                $(&#x27;img.removeButton&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/minus.svg&#x27;);
                $(&#x27;img.editButton&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/edit.png&#x27;);
                $(&#x27;div.locations&#x27;).css(unselectedCSS);

                $this.find(&#x27;img.removeButton&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/minusB.svg&#x27;);
                $this.find(&#x27;img.editButton&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/editB.png&#x27;);
                $this.css(selectedCSS);

                if (e.data.resource.latitude) {
                    location  = e.data.resource;
                } else {
                    latitude  = e.data.resource.point.coordinates[0];
                    longitude = e.data.resource.point.coordinates[1];
                    location  = new Microsoft.Maps.Location(latitude, longitude);
                }
                viewOptions = {
                    center: location,
                    zoom: 4,
                };
                map.setView(viewOptions);
            }

            for (i = 0; i &lt; locationList.length; i++) {
                pushpinOptions = {
                    text: &#x27;&#x27; + (i + 1),
                    icon: tagPath+&#x27;images/icons/locationPin.png&#x27;,
                    width: 20,
                    height: 30
                };
                address = locationList[i].address;
                date = &#x27;&#x27;;
                if (locationList[i].date &amp;&amp; locationList[i].date.year) {
                    year = locationList[i].date.year;
                    if (year &lt; 0) { // add BC to years that are less than 0
                        year = Math.abs(year) + &#x27; BC&#x27;;
                    }
                    date = year;
                } else {
                    date = &#x27;&lt;i&gt;Date Unspecified&lt;/i&gt;&#x27;;
                }

                // create a box in the lower pane for each location
                locBox = $(document.createElement(&#x27;div&#x27;));
                locBox.addClass(&#x27;locations&#x27;);
                locBox.html((i + 1) + &#x27;. &#x27; + address + &#x27; - &#x27; + date + &#x27;&lt;br&gt;&#x27;);

                lpTextDiv.append(locBox);

                // display more information about the location when locBox is clicked
                locBox.click(locationList[i], drawPinHelper);
                locBox.fadeIn();
            }

            TAG.Util.UI.drawPushpins(locationList, map);
            toggleLocationPanel();
        };

        /**
         * Click handler to expand location history window
         * @method histOnClick 
         */
        function histOnClick() {
            if (locationList.length === 0) {
                mapOverlay.show();
            }
            if (!map) {
                makeMap(prepMap);
            } else {
                toggleLocationPanel();
            }
        }

        /**
         * Toggles location panel when locHistoryContainer or toggler is clicked
         * @method toggleLocationPanel
        */
        function toggleLocationPanel() {
            if (locationList.length === 0) {
                return;
            }
            if (locOpening||locClosing){
                return;
            }
            if (locHistoryActive) {
                locHistory.text(&#x27;Location History&#x27;);
                locHistory.css(&#x27;color&#x27;, &#x27;white&#x27;);
                locClosing = true;
                locHistoryToggle.hide();
                locHistoryDiv.hide(&quot;slide&quot;, { direction: &#x27;left&#x27; }, 500, function(){
                    toggler.show();
                    locClosing = false;
                });
            } else {
                locHistory.text(&#x27;Location History&#x27;);
                locHistoryToggle.hide();
                locOpening = true;
                locHistoryDiv.show(&quot;slide&quot;, { direction: &#x27;left&#x27; }, 500, function () {
                    locHistoryToggle.show();
                    locOpening = false;
                });
                locHistoryDiv.css(&#x27;display&#x27;, &#x27;inline&#x27;);
                toggler.hide();
            }
            locHistoryActive = !locHistoryActive;
        }

        locHistoryContainer.append(locHistory);

        return locHistoryContainer;
    }

    /**
     * Create a drawer (e.g., for list of related tours or the artwork&#x27;s description) 
     * @param {String} title        title of the drawer
     * @return {jQuery obj}         the drawer
     */
    function createDrawer(title) {
        var drawer          = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;drawer&#x27;),
            drawerHeader    = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;drawerHeader&#x27;),
            label           = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;drawerLabel&#x27;),
            toggleContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;drawerToggleContainer&#x27;),
            toggle          = $(document.createElement(&#x27;img&#x27;)).addClass(&quot;drawerPlusToggle&quot;),
            drawerContents  = $(document.createElement(&#x27;div&#x27;)).addClass(&quot;drawerContents&quot;),
            i;
       
        label.text(title);
        toggle.attr({
            src: tagPath+&#x27;images/icons/plus.svg&#x27;,
            expanded: false
        });

        drawer.append(drawerHeader);
        drawerHeader.append(label);
        drawerHeader.append(toggleContainer);
        toggleContainer.append(toggle);
        drawer.append(drawerContents);

        //have the toggler icon minus when is is expanded, plus otherwise.
        drawerHeader.on(&#x27;click&#x27;, function (evt) {
            if (toggle.attr(&#x27;expanded&#x27;) !== &#x27;true&#x27;) {
                $(&quot;.drawerPlusToggle&quot;).attr({
                   src: tagPath+&#x27;images/icons/plus.svg&#x27;,
                    expanded: false
                });

                $(&quot;.drawerContents&quot;).slideUp();

                toggle.attr({
                    src: tagPath+&#x27;images/icons/minus.svg&#x27;,
                    expanded: true
                });
            } else {
                toggle.attr({
                    src: tagPath+&#x27;images/icons/plus.svg&#x27;,
                    expanded: false
                });

                for(i=0; i&lt;associatedMedia.guids.length; i++) {
                    if(associatedMedia[associatedMedia.guids[i]].isVisible()) {
                        associatedMedia[associatedMedia.guids[i]].hide();
                    }
                }
            }
            drawerContents.slideToggle();
        });
        
        drawer.contents = drawerContents;
        return drawer;
    }

    /**
     * Return art viewer root element
     * @method
     * @return {jQuery obj}    root jquery object
     */
    function getRoot() {
        return root;
    }

    /**
     * Make the map for location History.
     * @method makeMap
     * @param {Function} callback     function to be called when map making is complete
    */
    function makeMap(callback) {
        var mapOptions,
            viewOptions;

        mapOptions = {
            credentials:         &quot;AkNHkEEn3eGC3msbfyjikl4yNwuy5Qt9oHKEnqh4BSqo5zGiMGOURNJALWUfhbmj&quot;,
            mapTypeID:           Microsoft.Maps.MapTypeId.road,
            showScalebar:        true,
            enableClickableLogo: false,
            enableSearchLogo:    false,
            showDashboard:       true,
            showMapTypeSelector: false,
            zoom:                2,
            center:              new Microsoft.Maps.Location(20, 0)
        };
        
        viewOptions = {
            mapTypeId: Microsoft.Maps.MapTypeId.road,
        };
        
        map = new Microsoft.Maps.Map(document.getElementById(&#x27;lpMapDiv&#x27;), mapOptions);
        map.setView(viewOptions);

        callback &amp;&amp; callback();
    }

};

TAG.Layout.ArtworkViewer.default_options = {
    catalogState: {},
    doq: null,
    split: &#x27;L&#x27;,
};


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
