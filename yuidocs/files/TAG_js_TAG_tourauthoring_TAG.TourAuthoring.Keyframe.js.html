<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>TAG/js/TAG/tourauthoring/TAG.TourAuthoring.Keyframe.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../TAG/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/TAG.AnnotatedImage.html">TAG.AnnotatedImage</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkViewer.html">TAG.Layout.ArtworkViewer</a></li>
            
                <li><a href="../classes/TAG.Layout.CollectionsPage.html">TAG.Layout.CollectionsPage</a></li>
            
                <li><a href="../classes/TAG.Layout.InternetFailurePage.js.html">TAG.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/TAG.Layout.StartPage.html">TAG.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG.Layout.VideoPlayer.html">TAG.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG.Util.Artwork.html">TAG.Util.Artwork</a></li>
            
                <li><a href="../classes/TAG.Util.IdleTimer.html">TAG.Util.IdleTimer</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: TAG/js/TAG/tourauthoring/TAG.TourAuthoring.Keyframe.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿ TAG.Util.makeNamespace(&#x27;TAG.TourAuthoring.Keyframe&#x27;);

/**
 * Makes a keyframe
 * Associated with a display (keyframe sequence)
 * Maps to keyframe in RIN (duh)
 * @param spec      location (loc - x,y if audio, just x if visual), keyframe svg group (gkey) attrs
 * @param my        Update currentKeyframe param for touch handling, contains timeManager, undoManager, and svg
 */
TAG.TourAuthoring.Keyframe = function (spec, my) {
    &quot;use strict&quot;;

    var that = {},
        _data = spec.data || { viewport: { region: { center: { x: 0, y: 0 }, span: { x: 1, y: 1 } } } },
        loc = spec.loc, // location in seconds - {x,y}
        gkey = spec.gkey, // SVG group containing keyframe
        display = spec.display, // containing display
        displayDiv = spec.displayDiv, // div of containing display (we&#x27;ll append the keyframe divs to this)
        position = 0,
        captureData,
        menu = TAG.TourAuthoring.EditorMenu({
            type: TAG.TourAuthoring.MenuType.keyframe,
            parent: that
        }, my),

        // svg/div variables
        circle, line, innerCircle, offsetx, offsety, hidden = false,

        // keyframe edit command logging functionality
        _updateKeyFrameCommand, needsLogging;

    var KEYFRAME_COLOR = TAG.TourAuthoring.Constants.keyframeColor,
        KEYFRAME_LINE_W = TAG.TourAuthoring.Constants.keyframeLineW,
        KEYFRAME_STROKE_W = TAG.TourAuthoring.Constants.keyframeStrokeW,
        KEYFRAME_SIZE = TAG.TourAuthoring.Constants.keyframeSize,
        T2P = my.timeManager.timeToPx,
        P2T = my.timeManager.pxToTime;

    //that.openMenu = false;
    that.position = 0; 
    that.removed = false;

    function initVisuals() {
        var px_x = my.timeManager.timeToPx(loc.x);
        var px_y = (my.type !== TAG.TourAuthoring.TrackType.audio) ? 48 : loc.y;
        var keyframeDivs = TAG.Util.UI.createKeyframe({ container: my.track, x: px_x, y: px_y });
        line = keyframeDivs.line,
        circle = keyframeDivs.circ,
        innerCircle = keyframeDivs.innerCirc;

        circle.on(&#x27;mousedown&#x27;, function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });

        innerCircle.on(&#x27;mousedown&#x27;, function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });

        function toggleCircle() {
            hidden = !hidden;
            if (hidden) {
                circle.css(&#x27;display&#x27;, &#x27;none&#x27;);
                innerCircle.css(&#x27;display&#x27;, &#x27;none&#x27;);
            } else {
                circle.css(&#x27;display&#x27;, &#x27;block&#x27;);
                innerCircle.css(&#x27;display&#x27;, &#x27;block&#x27;);
            }
        }
        that.toggleCircle = toggleCircle;
    }
    initVisuals(); // replacing call to initSVG

    function restoreHandlers() {
        circle.off(&#x27;mousedown&#x27;);
        innerCircle.off(&#x27;mousedown&#x27;);

        circle.on(&#x27;mousedown&#x27;, function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });

        innerCircle.on(&#x27;mousedown&#x27;, function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });
    }
    that.restoreHandlers = restoreHandlers;

    function _keyframeMousedown(mouseoffsetx, mouseoffsety) {
        var oldlocx = loc.x, // for command logging
            oldlocy = loc.y;

        // Stop playback on mousedown
        my.timeManager.stop();

        // Setting movement related vars
        offsetx = mouseoffsetx;
        offsety = mouseoffsety;
        my.currentKeyframe = that;
        $(&#x27;body&#x27;).on(&#x27;mouseup.keyframe&#x27;, function () {
            var command, newlocx, newlocy;
            my.currentKeyframe = null;
            offsetx = null;
            offsety = null;
            $(&#x27;body&#x27;).off(&#x27;mouseup.keyframe&#x27;);

            // If movement has occured, update and log command for undo/redo
            if (loc.x !== oldlocx || loc.y !== oldlocy) {
                my.update();
                newlocx = loc.x;
                newlocy = loc.y;
                command = TAG.TourAuthoring.Command({
                    execute: function () {
                        loc.x = newlocx;
                        loc.y = newlocy;
                        scale();
                        my.update();
                    }, unexecute: function () {
                        loc.x = oldlocx;
                        loc.y = oldlocy;
                        scale();
                        my.update();
                    }
                });
                my.undoManager.logCommand(command);
            }
        });
    }

    function resetVisuals() {
        var px_x = T2P(loc.x);
        circle.css({
            &quot;left&quot;: px_x - 21 - 5 + &quot;px&quot;,
            &quot;top&quot;: ((my.type !== TAG.TourAuthoring.TrackType.audio) ? 48 : loc.y) - 21 - 5 + &quot;px&quot;
        });
        innerCircle.css({
            &quot;left&quot;: px_x - 17 + &quot;px&quot;,
            &quot;top&quot;: ((my.type !== TAG.TourAuthoring.TrackType.audio) ? 48 : loc.y) - 17 + &quot;px&quot;
        });
        line.css(&quot;left&quot;, px_x - 3 / 2 + &quot;px&quot;);
    }
    that.resetVisuals = resetVisuals;

    function initSVG() {
        var timex = my.timeManager.timeToPx(loc.x);

        // Remember: svg height is just 100%!

        // middle marking line
        line = gkey.append(&#x27;line&#x27;)
            .attr(&#x27;x1&#x27;, timex).attr(&#x27;y1&#x27;, &#x27;0%&#x27;)
            .attr(&#x27;x2&#x27;, timex).attr(&#x27;y2&#x27;, &#x27;100%&#x27;)
            .attr(&#x27;style&#x27;, &#x27;stroke:&#x27; + TAG.TourAuthoring.Constants.keyframeColor + &#x27;; stroke-width:&#x27; + TAG.TourAuthoring.Constants.keyframeLineW + &#x27;;&#x27;);

        // keyframe circle
        circle = gkey.append(&#x27;circle&#x27;)
                     .attr(&#x27;style&#x27;, &#x27;stroke:&#x27; + TAG.TourAuthoring.Constants.keyframeColor
                     + &#x27;; fill:white; stroke-width:&#x27; + TAG.TourAuthoring.Constants.keyframeStrokeW + &#x27;;&#x27;);
        //circle.on(&#x27;mousedown&#x27;, function (d, i) {
        //    var mouse = d3.mouse(circle[0][0]);
        //    _keyframeMousedown(mouse[0] - parseInt(this.getAttribute(&#x27;cx&#x27;)), mouse[1] - parseInt(this.getAttribute(&#x27;cy&#x27;)));
        //});

        $(circle[0][0]).on(&#x27;mousedown&#x27;, function (e) {
            console.log(&quot;using new events&quot;);
            var offsetX = e.offsetX;
            var offsetY = e.offsetY;
            _keyframeMousedown(offsetX - parseInt(circle.attr(&#x27;cx&#x27;), 10), offsetY - parseInt(circle.attr(&#x27;cy&#x27;), 10));
        });

        if (my.type !== TAG.TourAuthoring.TrackType.audio) { // set vertical positioning of non-audio keyframes
            loc.y = 48;
        }
        circle.attr(&#x27;cx&#x27;, timex)
                  .attr(&#x27;cy&#x27;, loc.y) // TODO: convert linear scale to dBFS (logarithmic for even fades)
                  .attr(&#x27;r&#x27;, TAG.TourAuthoring.Constants.keyframeSize);

        innerCircle = gkey.append(&#x27;circle&#x27;)
                        .attr(&#x27;cx&#x27;, timex)
                        .attr(&#x27;cy&#x27;, loc.y)
                        .attr(&#x27;r&#x27;, TAG.TourAuthoring.Constants.innerKeyframeSize)
                        .attr(&#x27;style&#x27;, &#x27;display:none; stroke:&#x27; + TAG.TourAuthoring.Constants.keyframeColor + &#x27;; fill:&#x27; + TAG.TourAuthoring.Constants.keyframeColor + &#x27;; stroke-width:0;&#x27;);
        //innerCircle.on(&#x27;mousedown&#x27;, function (d, i) {
        //    var mouse = d3.mouse(circle[0][0]);
        //    _keyframeMousedown(mouse[0] - parseInt(this.getAttribute(&#x27;cx&#x27;)), mouse[1] - parseInt(this.getAttribute(&#x27;cy&#x27;)));
        //});

        $(innerCircle[0][0]).on(&#x27;mousedown&#x27;, function (e) {
            console.log(&quot;using new events&quot;);
            var offsetX = e.offsetX;
            var offsetY = e.offsetY;
            _keyframeMousedown(offsetX - parseInt(innerCircle.attr(&#x27;cx&#x27;), 10), offsetY - parseInt(innerCircle.attr(&#x27;cy&#x27;), 10));
        });

        function toggleCircle() {
            hidden = !hidden;
            if (hidden) {
                circle.attr(&#x27;display&#x27;, &#x27;none&#x27;);
                innerCircle.attr(&#x27;display&#x27;, &#x27;none&#x27;);
            } else {
                circle.attr(&#x27;display&#x27;, null);
                innerCircle.attr(&#x27;display&#x27;, null);
            }
        }
        that.toggleCircle = toggleCircle;

        /**
         * Helper function to set currentKeyframe and other vars in prep for movement
         */
        function _keyframeMousedown(mouseoffsetx, mouseoffsety) {
            var oldlocx = loc.x, // for command logging
                oldlocy = loc.y;

            // Stop playback on mousedown
            my.timeManager.stop();

            // Setting movement related vars
            offsetx = mouseoffsetx;
            offsety = mouseoffsety;
            my.currentKeyframe = that;
            $(&#x27;body&#x27;).on(&#x27;mouseup.keyframe&#x27;, function () {
                var command, newlocx, newlocy;
                my.currentKeyframe = null;
                offsetx = null;
                offsety = null;
                $(&#x27;body&#x27;).off(&#x27;mouseup.keyframe&#x27;);

                // If movement has occured, update and log command for undo/redo
                if (loc.x !== oldlocx || loc.y !== oldlocy) {
                    my.update();
                    newlocx = loc.x;
                    newlocy = loc.y;
                    command = TAG.TourAuthoring.Command({
                        execute: function () {
                            loc.x = newlocx;
                            loc.y = (my.type === TAG.TourAuthoring.TrackType.audio) ? newlocy : 48;
                            scale();
                            my.update();
                        }, unexecute: function () {
                            loc.x = oldlocx;
                            loc.y = (my.type === TAG.TourAuthoring.TrackType.audio) ? oldlocy : 48;
                            scale();
                            my.update();
                        }
                    });
                    my.undoManager.logCommand(command);
                }
            });
        }
    }
    //initSVG();

    (function initMenu() {
        menu.addInput(&#x27;Time&#x27;, TAG.TourAuthoring.MenuInputFormats.minSec,
            getTime, setTime);
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            menu.addInput(&#x27;Volume&#x27;, TAG.TourAuthoring.MenuInputFormats.percent,
                getVolume, setVolume);
        }
        menu.addButton(&#x27;Delete&#x27;, &#x27;left&#x27;, removeHelper);
        //menu.addButton(&#x27;Duplicate&#x27;, &#x27;left&#x27;, duplicate);
        menu.addButton(&#x27;Close&#x27;, &#x27;right&#x27;, menu.forceClose);
    })();

    //function duplicate() {
    //    var copyTo = Math.min(display.getEnd(), loc.x + TAG.TourAuthoring.Constants.epsilon),
    //        newKey = display.addKeyframe(copyTo);

    //    newKey.loadRIN({ state: _data });
    //}

    function removeHelper() {
        remove(true);
    }
    that.removeHelper = removeHelper;

    function remove(displayRemoved, preventClose) {
        closeMenu(preventClose);
        var index,
            command = TAG.TourAuthoring.Command({
            execute: function () {
                index = display.removeKeyframe(that);
                circle.remove();
                line.remove();
                innerCircle.remove();
                that.removed = true;
                display.getTrack().drawLines();
                scale();
                my.update();
            }, unexecute: function () {
                reactivateKeyframe();
                display.insertKeyframe(that, index);
                display.getTrack().drawLines();
                scale();
                my.update();
            }
        });
        command.execute();
        if (displayRemoved) {
            my.undoManager.logCommand(command);
        }
    }
    that.remove = remove;

    function reactivateKeyframe() {
        that.removed = false;
        initVisuals();//initSVG();
    }
    that.reactivateKeyframe = reactivateKeyframe;

    function updatePosition(newpos) {
        position = newpos;
    }
    that.updatePosition = updatePosition;

	function getPosition() {
		return position;
	}
	that.getPosition = getPosition;

	function getCaptureData() {
	    return captureData;
	}
	that.getCaptureData = getCaptureData;

    function closeMenu(preventClose) {
        menu.close(preventClose);
    }
    that.closeMenu = closeMenu;

    function menuIsOpen() {
        return menu.menuCloseable;
    }

    function setMenuCloseable(state) {
        menu.menuCloseable = state;
    }

    // handles long press on a keyframe
    function rightTapped(evt) {
        menu.open(evt);
    }
    that.rightTapped = rightTapped;

    function tapped(evt) {
        my.timeManager.seek(loc.x);
        setSelected();
    }
    that.tapped = tapped;

    var setSelectedDebounced = $.debounce(250, function () {
        if (my.type !== TAG.TourAuthoring.TrackType.audio) {
            my.selectedKeyframe = that;
            $(&#x27;.keyframeInnerCirc&#x27;).css(&#x27;background-color&#x27;, &#x27;#ffffff&#x27;);
            circle.css({ &#x27;background-color&#x27;: &#x27;white&#x27; });
            innerCircle.css(&#x27;background-color&#x27;, &#x27;#296b2f&#x27;);

            var currData = _data;
            var command = createKeyframeCommand();
            //my.undoManager.logCommand(command);
            _updateKeyFrameCommand = command;
        }

        function createKeyframeCommand() {
            return TAG.TourAuthoring.Command({
                execute: function () {

                },
                unexecute: function () {
                    _data = currData;
                    my.update();

                    if (my.selectedKeyframe === that) {
                        _updateKeyFrameCommand = createKeyframeCommand();
                        needsLogging = true;
                    }
                }
            });
        }
    });

    /**
     * functions for changing keyframe style based on selected status
     */
    function setSelected(forceInstant) {
        //if (my.type !== TAG.TourAuthoring.TrackType.audio) {
        //    my.selectedKeyframe = that;
        //    $(&quot;circle&quot;).css({ &#x27;fill&#x27;: &#x27;white&#x27; });
        //    innerCircle.attr(&#x27;style&#x27;, &#x27;display: inherit; fill: #296b2f&#x27;);

        //    var currData = _data;
        //    var command = createKeyframeCommand();
        //    if (!delayLogging) {
        //        my.undoManager.logCommand(command);
        //    }
        //    needsLogging = !!delayLogging; // convert null or undefined to false
        //    _updateKeyFrameCommand = command;
        //}

        function createKeyframeCommand() {
            return TAG.TourAuthoring.Command({
                execute: function () {

                },
                unexecute: function () {
                    _data = currData;
                    my.update();

                    if (my.selectedKeyframe === that) {
                        _updateKeyFrameCommand = createKeyframeCommand();
                        needsLogging = true;
                    }
                }
            });
        }

        if (forceInstant) {
            my.selectedKeyframe = that;
            circle.css({ &#x27;background-color&#x27;: &#x27;white&#x27; });
            innerCircle.css({&#x27;display&#x27;: &#x27;inherit&#x27;,&#x27;background-color&#x27;: &#x27;#296b2f&#x27;});
        } else {
            setSelectedDebounced();
        }
    }
    that.setSelected = setSelected;

    function setDeselected() {
        _updateKeyFrameCommand = null;
        my.selectedKeyframe = null;
        innerCircle.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
    }
    that.setDeselected = setDeselected;


    
    // Gets x location (time in px) of keyframe
    function getTime() {
        return loc.x;
    }
    that.getTime = getTime;

    function setTime(newtime) {
        var timex,
            keyframes = display.getKeyframes(),
            leftbound = (position &gt; 0)
                        ? Math.max(keyframes[position - 1].getTime(), display.getStart())
                        : display.getStart(),
            rightbound = (position + 1 &lt; keyframes.length)
                        ? Math.min(keyframes[position + 1].getTime(), display.getEnd())
                        : display.getEnd();

        loc.x = Math.constrain(newtime,
                                leftbound + TAG.TourAuthoring.Constants.epsilon,
                                rightbound + TAG.TourAuthoring.Constants.epsilon);

        timex = my.timeManager.timeToPx(loc.x);
        circle.css(&#x27;left&#x27;, (timex - 21 - 5)+&quot;px&quot;); // DON&#x27;T HARDCODE
        line.css(&#x27;left&#x27;, (timex - 3/2)+&quot;px&quot;);
        innerCircle.css(&#x27;left&#x27;, (timex - 17)+&quot;px&quot;);
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            display.getTrack().drawLines();
        }

        setDeselected();
    }
    that.setTime = setTime;

    // Gets y location (volume in px) of keyframe
    function getVolumePx() {
        return loc.y;
    }
    that.getVolumePx = getVolumePx;

    // Gets volume (in percent) of keyframe
    function getVolume() {
        return heightToPercent(loc.y);
    }
    that.getVolume = getVolume;

    /**
     * Sets keyframe volume
     * @param newvolume     new volume in percent
     */
    function setVolume(newvolume) {
        loc.y = percentToHeight(Math.constrain(newvolume, 0, 100));
        circle.css(&#x27;top&#x27;, (loc.y - 21 - 5)+&quot;px&quot;);
        innerCircle.css(&#x27;top&#x27;, (loc.y - 17)+&quot;px&quot;);
        my.that.drawLines();
    }
    that.setVolume = setVolume;

    // generate vertical fader value out of 100% based on track height constant
    function heightToPercent(height) {
        //rounds to 2 decimal places
        return (Math.round(((TAG.TourAuthoring.Constants.trackHeight - height) * 100 / TAG.TourAuthoring.Constants.trackHeight) * 100) / 100);
    }

    // generate raw height value from percentage vertical fader value
    function percentToHeight(percent) {
        return TAG.TourAuthoring.Constants.trackHeight - (percent * TAG.TourAuthoring.Constants.trackHeight / 100);
    }

    // Gets containing display
    function getContainingDisplay() {
        return display;
    }

    // Gets whether the keyframe has been removed
    function isRemoved() {
        return that.removed;
    }
    that.isRemoved = isRemoved;
    that.getContainingDisplay = getContainingDisplay;

    /**   
     * Logic for manipulation + dragging of keyframes
     * Moves keyframe to an absolute position given in res
     * currentKeyframe and offsets should be set, see initSVG / _keyframeMousedown for details
     * Automatically bounds keyframe movement to associated display
     * @param res           event from makeManipulable, onManipulate
     * @param leftbound     leftmost position keyframe can move to (not required)
     * @param rightbound    rightmost position keyframe can move to (not required)
     */
    function move(res, leftbound, rightbound) {
        var timex;

        // If no bounds are set, keyframe can be anywhere within display except non-negative times
        leftbound = leftbound || 0;
        rightbound = rightbound || Infinity;

        // error checking
        if ((!offsetx &amp;&amp; offsetx !== 0) || (!offsety &amp;&amp; offsety !== 0) || !my.currentKeyframe) {
            console.log(&#x27;Move keyframe called when no keyframe is selected!&#x27;);
        }
        // Editing
        else {
            loc.x = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offsetx),
                                    Math.max(leftbound, display.getStart()) + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.fadeBtnSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.keyframeSize),
                                    Math.min(rightbound, display.getEnd()) - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.fadeBtnSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.keyframeSize));
            if (loc.x &lt; display.getStart() || loc.x &gt; display.getEnd()) {
                loc.x = (display.getStart() + display.getEnd()) / 2;
            }
            if (loc.x &lt; leftbound) {
                loc.x = leftbound;
            }
            if (loc.x &gt; rightbound) {
                loc.x = rightbound;
            }
            timex = my.timeManager.timeToPx(loc.x);
            circle.css(&#x27;left&#x27;, (timex - 21 - 5)+&quot;px&quot;); // DON&#x27;T HARDCODE
            line.css(&#x27;left&#x27;, (timex-3/2)+&quot;px&quot;);
            innerCircle.css(&#x27;left&#x27;, (timex - 17)+&quot;px&quot;);
            if (my.type === TAG.TourAuthoring.TrackType.audio) { // Change y loc only if keyframe is audio
                loc.y = Math.constrain(res.pivot.y - offsety, 0, TAG.TourAuthoring.Constants.trackHeight); // bound y movement to svg!
                circle.css(&#x27;top&#x27;, (loc.y - 21 - 5) + &quot;px&quot;);
                innerCircle.css(&#x27;top&#x27;, (loc.y - 17) + &quot;px&quot;);
                display.getTrack().drawLines();
                // leave as pixel values
            } else {
                loc.y = 48;
            }
            setDeselected();
            //my.update();
            // TODO: command logging
        }
    }
    that.move = move;

    /**
     * Used to debug move from command line
     * Flips internal state to simulate clicks
     * Resets state when finished
     * Use only in test code or functions inside display
     */
    function internalMove(x, y, leftbound, rightbound) {
        var res = {
            pivot: { x: x, y:y}
        };
        offsetx = 0;
        offsety = 0;
        my.currentKeyframe = that;

        move(res, leftbound, rightbound);
        display.sortKeyframes();
        my.update();

        offsetx = null;
        offsety = null;
        my.currentKeyframe = null;
    }
    that.internalMove = internalMove;

    /**
     * Translates keyframe by t secs
     * @param t     amount of translation
     */
    function translate(t) {
        var timex;
        //loc.x = !isNaN(loc.x) ? Math.constrain(loc.x + t, display.getStart(), display.getEnd()) : Math.constrain(t, display.getStart(), display.getEnd());
        loc.x = Math.constrain(loc.x + t, display.getStart(), display.getEnd());
        timex = my.timeManager.timeToPx(loc.x);
        circle.css(&#x27;left&#x27;,( timex - 21 - 5)+&quot;px&quot;);
        line.css(&#x27;left&#x27;, (timex - 3/2)+&quot;px&quot;);
        innerCircle.css(&#x27;left&#x27;, (timex - 17)+&quot;px&quot;);
        setDeselected();
        //newVal.val(createminsec(loc.x));
        //my.update();
    }
    that.translate = translate;

    /**
     * Called when ratio of time to pixels is changed
     * Just resets positioning of keyframes
     */
    function scale() {
        var timex = my.timeManager.timeToPx(loc.x);
        circle.css({&#x27;left&#x27;: (timex - 21 - 5) + &quot;px&quot;, &#x27;top&#x27;: (loc.y-21-5)+&quot;px&quot;});
        line.css(&#x27;left&#x27;, (timex - 3/2)+&quot;px&quot;);
        innerCircle.css({ &#x27;left&#x27;: (timex - 17) + &quot;px&quot;, &#x27;top&#x27;: (loc.y - 17) + &quot;px&quot; });
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            display.getTrack().drawLines();
        }
    }
    that.scale = scale;

    /**
     * Converts the y location of the keyframe onto scale from 0 to 1
     * 0 is bottom of timeline, 1 is top
     * Scale is linear
     * Used for audio keyframes only
     */
    function ypixToVolume() {
        return Math.constrain((TAG.TourAuthoring.Constants.trackHeight - loc.y) / TAG.TourAuthoring.Constants.trackHeight, 0, 1);
    }

    /**
     * Maps keyframe to RIN keyframe
     */
    function toRIN() {
        var keyframe;
        switch (my.type) {
            case TAG.TourAuthoring.TrackType.artwork:
                keyframe = {
                    offset: loc.x - display.getStart(),
                    init: false,
                    holdDuration: 0,
                    state: _data
                    /*data: { // Need to determine where keyframe info is getting stored, also why does it need a media source?
                        &#x27;default&#x27;: _data,
                        TransitionTime: &quot;&lt;TransitionTime&gt;3&lt;/TransitionTime&gt;&quot;,
                        PauseDuration: &quot;&lt;PauseDuration&gt;1&lt;/PauseDuration&gt;&quot;,
                        keyframeThumbnail: &quot;&lt;Thumbnail&gt;&lt;/Thumbnail&gt;&quot;
                    }*/
                };
                break;
            case TAG.TourAuthoring.TrackType.image:
                keyframe = {
                    offset: loc.x - display.getStart(),
                    init: false,
                    holdDuration: 0,
                    state: _data
                };
                break;
            case TAG.TourAuthoring.TrackType.audio:
                keyframe = {
                    offset: loc.x - display.getStart(),
                    init: false,
                    holdDuration: 0,
                    state: { // Need to determine where keyframe info is getting stored, also why does it need a media source?
                        &#x27;sound&#x27;: {
                            &#x27;volume&#x27;: ypixToVolume()
                        }
                    }
                };
                break;
            default:
                console.log(&#x27;RIN track type not yet implemented&#x27;);
                break;
        }
        return keyframe;
    }
    that.toRIN = toRIN;

    /**
     * Initializes keyframe using RIN data
     * @param data      keyframe in RIN xml format
     */ 
    function loadRIN(data) {
        captureData = data;
        if (data.state) {
            _data = data.state;
        }
        else if (data.data) {
            var xml = data.data.default,
            center = {
                x: Number((/Viewport_X=&#x27;([^&#x27;]+)&#x27;/.exec(xml))[1]),
                y: Number((/Viewport_Y=&#x27;([^&#x27;]+)&#x27;/.exec(xml))[1])
            },
            span = {
                x: Number((/Viewport_Width=&#x27;([^&#x27;]+)&#x27;/.exec(xml))[1]),
                y: Number((/Viewport_Height=&#x27;([^&#x27;]+)&#x27;/.exec(xml))[1])
            };
            _data = {
                viewport: {
                    region: {
                        center: center,
                        span: span
                    }
                }
            };
            // parse into new format
        }
        if (_updateKeyFrameCommand) {
            (function (command) {
                command.execute = function () {
                    _data = data;
                    my.update();
                    _updateKeyFrameCommand = command;
                    needsLogging = false;
                };
            })(_updateKeyFrameCommand);

            if (needsLogging) {
                my.undoManager.logCommand(_updateKeyFrameCommand);
                needsLogging = false;
            }
        }
    }
    that.loadRIN = loadRIN;

    return that;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
