<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>LADS/js/html2canvas/html2canvas.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../LADS/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/CryptoJS.html">CryptoJS</a></li>
            
                <li><a href="../classes/LADS.Layout.Artmode.html">LADS.Layout.Artmode</a></li>
            
                <li><a href="../classes/LADS.Layout.InternetFailurePage.js.html">LADS.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/LADS.Layout.StartPage.html">LADS.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: LADS/js/html2canvas/html2canvas.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
﻿/**
  @license html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
 */
(function(window, document, undefined){

/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
 */
&quot;use strict&quot;;

var _html2canvas = {},
previousElement,
computedCSS,
html2canvas;


function h2clog(a) {
    if (_html2canvas.logging &amp;&amp; window.console &amp;&amp; window.console.log) {
        window.console.log(a);
    }
}

_html2canvas.Util = {};

_html2canvas.Util.backgroundImage = function (src) {

    if (/data:image\/.*;base64,/i.test( src ) || /^(-webkit|-moz|linear-gradient|-o-)/.test( src )) {
        return src;
    }

    if (src.toLowerCase().substr( 0, 5 ) === &#x27;url(&quot;&#x27;) {
        src = src.substr( 5 );
        src = src.substr( 0, src.length - 2 );
    } else {
        src = src.substr( 4 );
        src = src.substr( 0, src.length - 1 );
    }

    return src;
};

_html2canvas.Util.Bounds = function getBounds (el) {
    var clientRect,
    bounds = {};

    if (el.getBoundingClientRect){
        clientRect = el.getBoundingClientRect();


        // TODO add scroll position to bounds, so no scrolling of window necessary
        bounds.top = clientRect.top;
        bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);
        bounds.left = clientRect.left;

        // older IE doesn&#x27;t have width/height, but top/bottom instead
        bounds.width = clientRect.width || (clientRect.right - clientRect.left);
        bounds.height = clientRect.height || (clientRect.bottom - clientRect.top);

        return bounds;

    }
};

_html2canvas.Util.getCSS = function (el, attribute) {
    // return $(el).css(attribute);

    var val;

    function toPX( attribute, val ) {
        var rsLeft = el.runtimeStyle &amp;&amp; el.runtimeStyle[ attribute ],
        left,
        style = el.style;

        // Check if we are not dealing with pixels, (Opera has issues with this)
        // Ported from jQuery css.js
        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we&#x27;re not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels

        if ( !/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test( val ) &amp;&amp; /^-?\d/.test( val ) ) {

            // Remember the original values
            left = style.left;

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                el.runtimeStyle.left = el.currentStyle.left;
            }
            style.left = attribute === &quot;fontSize&quot; ? &quot;1em&quot; : (val || 0);
            val = style.pixelLeft + &quot;px&quot;;

            // Revert the changed values
            style.left = left;
            if ( rsLeft ) {
                el.runtimeStyle.left = rsLeft;
            }

        }

        if (!/^(thin|medium|thick)$/i.test( val )) {
            return Math.round(parseFloat( val )) + &quot;px&quot;;
        }

        return val;

    }


    if ( window.getComputedStyle ) {
        if ( previousElement !== el ) {
            computedCSS = document.defaultView.getComputedStyle(el, null);
        }
        val = computedCSS[ attribute ];

        if ( attribute === &quot;backgroundPosition&quot; ) {

            val = (val.split(&quot;,&quot;)[0] || &quot;0 0&quot;).split(&quot; &quot;);

            val[ 0 ] = ( val[0].indexOf( &quot;%&quot; ) === -1 ) ? toPX(  attribute + &quot;X&quot;, val[ 0 ] ) : val[ 0 ];
            val[ 1 ] = ( val[1] === undefined ) ? val[0] : val[1]; // IE 9 doesn&#x27;t return double digit always
            val[ 1 ] = ( val[1].indexOf( &quot;%&quot; ) === -1 ) ? toPX(  attribute + &quot;Y&quot;, val[ 1 ] ) : val[ 1 ];
        }

    } else if ( el.currentStyle ) {
        // IE 9&gt;
        if (attribute === &quot;backgroundPosition&quot;) {
            // Older IE uses -x and -y
            val = [ toPX(  attribute + &quot;X&quot;, el.currentStyle[ attribute + &quot;X&quot; ]  ), toPX(  attribute + &quot;Y&quot;, el.currentStyle[ attribute + &quot;Y&quot; ]  ) ];
        } else {

            val = toPX(  attribute, el.currentStyle[ attribute ]  );

            if (/^(border)/i.test( attribute ) &amp;&amp; /^(medium|thin|thick)$/i.test( val )) {
                switch (val) {
                    case &quot;thin&quot;:
                        val = &quot;1px&quot;;
                        break;
                    case &quot;medium&quot;:
                        val = &quot;0px&quot;; // this is wrong, it should be 3px but IE uses medium for no border as well.. TODO find a work around
                        break;
                    case &quot;thick&quot;:
                        val = &quot;5px&quot;;
                        break;
                }
            }
        }



    }




    return val;



//return $(el).css(attribute);


};


_html2canvas.Util.BackgroundPosition = function ( el, bounds, image ) {
    // TODO add support for multi image backgrounds

    var bgposition =  _html2canvas.Util.getCSS( el, &quot;backgroundPosition&quot; ) ,
    topPos,
    left,
    percentage,
    val;

    if (bgposition.length === 1){
        val = bgposition;

        bgposition = [];

        bgposition[0] = val;
        bgposition[1] = val;
    }



    if (bgposition[0].toString().indexOf(&quot;%&quot;) !== -1){
        percentage = (parseFloat(bgposition[0])/100);
        left =  ((bounds.width * percentage)-(image.width*percentage));

    }else{
        left = parseInt(bgposition[0],10);
    }

    if (bgposition[1].toString().indexOf(&quot;%&quot;) !== -1){

        percentage = (parseFloat(bgposition[1])/100);
        topPos =  ((bounds.height * percentage)-(image.height*percentage));
    }else{
        topPos = parseInt(bgposition[1],10);
    }




    return {
        top: topPos,
        left: left
    };

};

_html2canvas.Util.Extend = function (options, defaults) {
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            defaults[key] = options[key];
        }
    }
    return defaults;
};


/*
 * Derived from jQuery.contents()
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
_html2canvas.Util.Children = function( elem ) {


    var children;
    try {

        children = (elem.nodeName &amp;&amp; elem.nodeName.toUpperCase() === &quot;IFRAME&quot;) ?
        elem.contentDocument || elem.contentWindow.document : (function( array ){
            var ret = [];

            if ( array !== null ) {

                (function( first, second ) {
                    var i = first.length,
                    j = 0;

                    if ( typeof second.length === &quot;number&quot; ) {
                        for ( var l = second.length; j &lt; l; j++ ) {
                            first[ i++ ] = second[ j ];
                        }

                    } else {
                        while ( second[j] !== undefined ) {
                            first[ i++ ] = second[ j++ ];
                        }
                    }

                    first.length = i;

                    return first;
                })( ret, array );

            }

            return ret;
        })( elem.childNodes );

    } catch (ex) {
        h2clog(&quot;html2canvas.Util.Children failed with exception: &quot; + ex.message);
        children = [];
    }
    return children;
};

/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Contributor(s):
      Niklas von Hertzen &lt;http://www.twitter.com/niklasvh&gt;
      André Fiedler      &lt;http://www.twitter.com/sonnenkiste&gt;

  Released under MIT License
 */

(function(){

_html2canvas.Generate = {};

var reGradients = [
    /^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)-]+)\)$/,
    /^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,
    /^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z-]+)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z-]*)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z-]+)([\w\d\.\s,%\(\)]+)\)$/
];

/*
 * TODO: Add IE10 vendor prefix (-ms) support
 * TODO: Add W3C gradient (linear-gradient) support
 * TODO: Add old Webkit -webkit-gradient(radial, ...) support
 * TODO: Maybe some RegExp optimizations are possible ;o)
 */
_html2canvas.Generate.parseGradient = function(css, bounds) {
    var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3;

    for(i = 0; i &lt; len; i+=1){
        m1 = css.match(reGradients[i]);
        if(m1) break;
    }

    if(m1) {
        switch(m1[1]) {
            case &#x27;-webkit-linear-gradient&#x27;:
            case &#x27;-o-linear-gradient&#x27;:

                gradient = {
                    type: &#x27;linear&#x27;,
                    x0: null,
                    y0: null,
                    x1: null,
                    y1: null,
                    colorStops: []
                };

                // get coordinates
                m2 = m1[2].match(/\w+/g);
                if(m2){
                    m2Len = m2.length;
                    for(i = 0; i &lt; m2Len; i+=1){
                        switch(m2[i]) {
                            case &#x27;top&#x27;:
                                gradient.y0 = 0;
                                gradient.y1 = bounds.height;
                                break;

                            case &#x27;right&#x27;:
                                gradient.x0 = bounds.width;
                                gradient.x1 = 0;
                                break;

                            case &#x27;bottom&#x27;:
                                gradient.y0 = bounds.height;
                                gradient.y1 = 0;
                                break;

                            case &#x27;left&#x27;:
                                gradient.x0 = 0;
                                gradient.x1 = bounds.width;
                                break;
                        }
                    }
                }
                if(gradient.x0 === null &amp;&amp; gradient.x1 === null){ // center
                    gradient.x0 = gradient.x1 = bounds.width / 2;
                }
                if(gradient.y0 === null &amp;&amp; gradient.y1 === null){ // center
                    gradient.y0 = gradient.y1 = bounds.height / 2;
                }

                // get colors and stops
                m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                if(m2){
                    m2Len = m2.length;
                    step = 1 / Math.max(m2Len - 1, 1);
                    for(i = 0; i &lt; m2Len; i+=1){
                        m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                        if(m3[2]){
                            stop = parseFloat(m3[2]);
                            if(m3[3] === &#x27;%&#x27;){
                                stop /= 100;
                            } else { // px - stupid opera
                                stop /= bounds.width;
                            }
                        } else {
                            stop = i * step;
                        }
                        gradient.colorStops.push({
                            color: m3[1],
                            stop: stop
                        });
                    }
                }
                break;

            case &#x27;-webkit-gradient&#x27;:

                gradient = {
                    type: m1[2] === &#x27;radial&#x27; ? &#x27;circle&#x27; : m1[2], // TODO: Add radial gradient support for older mozilla definitions
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 0,
                    colorStops: []
                };

                // get coordinates
                m2 = m1[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/);
                if(m2){
                    gradient.x0 = (m2[1] * bounds.width) / 100;
                    gradient.y0 = (m2[2] * bounds.height) / 100;
                    gradient.x1 = (m2[3] * bounds.width) / 100;
                    gradient.y1 = (m2[4] * bounds.height) / 100;
                }

                // get colors and stops
                m2 = m1[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g);
                if(m2){
                    m2Len = m2.length;
                    for(i = 0; i &lt; m2Len; i+=1){
                        m3 = m2[i].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/);
                        stop = parseFloat(m3[2]);
                        if(m3[1] === &#x27;from&#x27;) stop = 0.0;
                        if(m3[1] === &#x27;to&#x27;) stop = 1.0;
                        gradient.colorStops.push({
                            color: m3[3],
                            stop: stop
                        });
                    }
                }
                break;

            case &#x27;-moz-linear-gradient&#x27;:

                gradient = {
                    type: &#x27;linear&#x27;,
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 0,
                    colorStops: []
                };

                // get coordinates
                m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);

                // m2[1] == 0%   -&gt; left
                // m2[1] == 50%  -&gt; center
                // m2[1] == 100% -&gt; right

                // m2[2] == 0%   -&gt; top
                // m2[2] == 50%  -&gt; center
                // m2[2] == 100% -&gt; bottom

                if(m2){
                    gradient.x0 = (m2[1] * bounds.width) / 100;
                    gradient.y0 = (m2[2] * bounds.height) / 100;
                    gradient.x1 = bounds.width - gradient.x0;
                    gradient.y1 = bounds.height - gradient.y0;
                }

                // get colors and stops
                m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g);
                if(m2){
                    m2Len = m2.length;
                    step = 1 / Math.max(m2Len - 1, 1);
                    for(i = 0; i &lt; m2Len; i+=1){
                        m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/);
                        if(m3[2]){
                            stop = parseFloat(m3[2]);
                            if(m3[3]){ // percentage
                                stop /= 100;
                            }
                        } else {
                            stop = i * step;
                        }
                        gradient.colorStops.push({
                            color: m3[1],
                            stop: stop
                        });
                    }
                }
                break;

            case &#x27;-webkit-radial-gradient&#x27;:
            case &#x27;-moz-radial-gradient&#x27;:
            case &#x27;-o-radial-gradient&#x27;:

                gradient = {
                    type: &#x27;circle&#x27;,
                    x0: 0,
                    y0: 0,
                    x1: bounds.width,
                    y1: bounds.height,
                    cx: 0,
                    cy: 0,
                    rx: 0,
                    ry: 0,
                    colorStops: []
                };

                // center
                m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);
                if(m2){
                    gradient.cx = (m2[1] * bounds.width) / 100;
                    gradient.cy = (m2[2] * bounds.height) / 100;
                }

                // size
                m2 = m1[3].match(/\w+/);
                m3 = m1[4].match(/[a-z-]*/);
                if(m2 &amp;&amp; m3){
                    switch(m3[0]){
                        case &#x27;farthest-corner&#x27;:
                        case &#x27;cover&#x27;: // is equivalent to farthest-corner
                        case &#x27;&#x27;: // mozilla removes &quot;cover&quot; from definition :(
                            var tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            var tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);
                            break;
                        case &#x27;closest-corner&#x27;:
                            var tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            var tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);
                            break;
                        case &#x27;farthest-side&#x27;:
                            if(m2[0] === &#x27;circle&#x27;){
                                gradient.rx = gradient.ry = Math.max(
                                    gradient.cx,
                                    gradient.cy,
                                    gradient.x1 - gradient.cx,
                                    gradient.y1 - gradient.cy
                                );
                            } else { // ellipse

                                gradient.type = m2[0];

                                gradient.rx = Math.max(
                                    gradient.cx,
                                    gradient.x1 - gradient.cx
                                );
                                gradient.ry = Math.max(
                                    gradient.cy,
                                    gradient.y1 - gradient.cy
                                );
                            }
                            break;
                        case &#x27;closest-side&#x27;:
                        case &#x27;contain&#x27;: // is equivalent to closest-side
                            if(m2[0] === &#x27;circle&#x27;){
                                gradient.rx = gradient.ry = Math.min(
                                    gradient.cx,
                                    gradient.cy,
                                    gradient.x1 - gradient.cx,
                                    gradient.y1 - gradient.cy
                                );
                            } else { // ellipse

                                gradient.type = m2[0];

                                gradient.rx = Math.min(
                                    gradient.cx,
                                    gradient.x1 - gradient.cx
                                );
                                gradient.ry = Math.min(
                                    gradient.cy,
                                    gradient.y1 - gradient.cy
                                );
                            }
                            break;

                        // TODO: add support for &quot;30px 40px&quot; sizes (webkit only)
                    }
                }

                // color stops
                m2 = m1[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                if(m2){
                    m2Len = m2.length;
                    step = 1 / Math.max(m2Len - 1, 1);
                    for(i = 0; i &lt; m2Len; i+=1){
                        m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                        if(m3[2]){
                            stop = parseFloat(m3[2]);
                            if(m3[3] === &#x27;%&#x27;){
                                stop /= 100;
                            } else { // px - stupid opera
                                stop /= bounds.width;
                            }
                        } else {
                            stop = i * step;
                        }
                        gradient.colorStops.push({
                            color: m3[1],
                            stop: stop
                        });
                    }
                }
                break;
        }
    }

    return gradient;
};

_html2canvas.Generate.Gradient = function(src, bounds) {
    var canvas = document.createElement(&#x27;canvas&#x27;),
    ctx = canvas.getContext(&#x27;2d&#x27;),
    gradient, grad, i, len, img;

    canvas.width = bounds.width;
    canvas.height = bounds.height;

    // TODO: add support for multi defined background gradients (like radial gradient example in background.html)
    gradient = _html2canvas.Generate.parseGradient(src, bounds);

    img = new Image();

    if(gradient){
        if(gradient.type === &#x27;linear&#x27;){
            grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);

            for (i = 0, len = gradient.colorStops.length; i &lt; len; i+=1) {
                try {
                    grad.addColorStop(gradient.colorStops[i].stop, gradient.colorStops[i].color);
                }
                catch(e) {
                    h2clog([&#x27;failed to add color stop: &#x27;, e, &#x27;; tried to add: &#x27;, gradient.colorStops[i], &#x27;; stop: &#x27;, i, &#x27;; in: &#x27;, src]);
                }
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, bounds.width, bounds.height);

            img.src = canvas.toDataURL();
        } else if(gradient.type === &#x27;circle&#x27;){

            grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);

            for (i = 0, len = gradient.colorStops.length; i &lt; len; i+=1) {
                try {
                    grad.addColorStop(gradient.colorStops[i].stop, gradient.colorStops[i].color);
                }
                catch(e) {
                    h2clog([&#x27;failed to add color stop: &#x27;, e, &#x27;; tried to add: &#x27;, gradient.colorStops[i], &#x27;; stop: &#x27;, i, &#x27;; in: &#x27;, src]);
                }
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, bounds.width, bounds.height);

            img.src = canvas.toDataURL();
        } else if(gradient.type === &#x27;ellipse&#x27;){

            // draw circle
            var canvasRadial = document.createElement(&#x27;canvas&#x27;),
                ctxRadial = canvasRadial.getContext(&#x27;2d&#x27;),
                ri = Math.max(gradient.rx, gradient.ry),
                di = ri * 2, imgRadial;

            canvasRadial.width = canvasRadial.height = di;

            grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);

            for (i = 0, len = gradient.colorStops.length; i &lt; len; i+=1) {
                try {
                    grad.addColorStop(gradient.colorStops[i].stop, gradient.colorStops[i].color);
                }
                catch(e) {
                    h2clog([&#x27;failed to add color stop: &#x27;, e, &#x27;; tried to add: &#x27;, gradient.colorStops[i], &#x27;; stop: &#x27;, i, &#x27;; in: &#x27;, src]);
                }
            }

            ctxRadial.fillStyle = grad;
            ctxRadial.fillRect(0, 0, di, di);

            ctx.fillStyle = gradient.colorStops[i - 1].color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            imgRadial = new Image();
            imgRadial.onload = function() { // wait until the image is filled

                // transform circle to ellipse
                ctx.drawImage(imgRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);

                img.src = canvas.toDataURL();

            }
            imgRadial.src = canvasRadial.toDataURL();
        }
    }

    return img;
};

_html2canvas.Generate.ListAlpha = function(number) {
    var tmp = &quot;&quot;,
    modulus;

    do {
        modulus = number % 26;
        tmp = String.fromCharCode((modulus) + 64) + tmp;
        number = number / 26;
    }while((number*26) &gt; 26);

    return tmp;
};

_html2canvas.Generate.ListRoman = function(number) {
    var romanArray = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;],
    decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    roman = &quot;&quot;,
    v,
    len = romanArray.length;

    if (number &lt;= 0 || number &gt;= 4000) {
        return number;
    }

    for (v=0; v &lt; len; v+=1) {
        while (number &gt;= decimal[v]) {
            number -= decimal[v];
            roman += romanArray[v];
        }
    }

    return roman;

};

})();
/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/

/*
 *  New function for traversing elements
 */

_html2canvas.Parse = function ( images, options ) {
    window.scroll(0,0);

    var support = {
        rangeBounds: false,
        svgRendering: options.svgRendering &amp;&amp; (function( ){
            var img = new Image(),
            canvas = document.createElement(&quot;canvas&quot;),
            ctx = (canvas.getContext === undefined) ? false : canvas.getContext(&quot;2d&quot;);
            if (ctx === false) {
                // browser doesn&#x27;t support canvas, good luck supporting SVG on canvas
                return false;
            }
            canvas.width = canvas.height = 10;
            img.src = [
            &quot;data:image/svg+xml,&quot;,
            &quot;&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; width=&#x27;10&#x27; height=&#x27;10&#x27;&gt;&quot;,
            &quot;&lt;foreignObject width=&#x27;10&#x27; height=&#x27;10&#x27;&gt;&quot;,
            &quot;&lt;div xmlns=&#x27;http://www.w3.org/1999/xhtml&#x27; style=&#x27;width:10;height:10;&#x27;&gt;&quot;,
            &quot;sup&quot;,
            &quot;&lt;/div&gt;&quot;,
            &quot;&lt;/foreignObject&gt;&quot;,
            &quot;&lt;/svg&gt;&quot;
            ].join(&quot;&quot;);
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            } catch(e) {
                return false;
            }
            h2clog(&#x27;html2canvas: Parse: SVG powered rendering available&#x27;);
            return true;

        })()
    },
    element = (( options.elements === undefined ) ? document.body : options.elements[0]), // select body by default
    needReorder = false,
    numDraws = 0,
    fontData = {},
    doc = element.ownerDocument,
    ignoreElementsRegExp = new RegExp(&quot;(&quot; + options.ignoreElements + &quot;)&quot;),
    body = doc.body,
    r,
    testElement,
    rangeBounds,
    rangeHeight,
    stack,
    ctx,
    docDim,
    i,
    children,
    childrenLen;


    function docSize(){

        return {
            width: Math.max(
                Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
                Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
                Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
                ),
            height: Math.max(
                Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
                Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
                Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
                )
        };

    }

    images = images || {};

    // Test whether we can use ranges to measure bounding boxes
    // Opera doesn&#x27;t provide valid bounds.height/bottom even though it supports the method.


    if (doc.createRange) {
        r = doc.createRange();
        //this.support.rangeBounds = new Boolean(r.getBoundingClientRect);
        if (r.getBoundingClientRect){
            testElement = doc.createElement(&#x27;boundtest&#x27;);
            testElement.style.height = &quot;123px&quot;;
            testElement.style.display = &quot;block&quot;;
            body.appendChild(testElement);

            r.selectNode(testElement);
            rangeBounds = r.getBoundingClientRect();
            rangeHeight = rangeBounds.height;

            if (rangeHeight === 123) {
                support.rangeBounds = true;
            }
            body.removeChild(testElement);


        }

    }


    /*
    var rootStack = new this.storageContext($(document).width(),$(document).height());
    rootStack.opacity = this.getCSS(this.element,&quot;opacity&quot;);
    var stack = this.newElement(this.element,rootStack);


    this.parseElement(this.element,stack);
     */




    var getCSS = _html2canvas.Util.getCSS;
    function getCSSInt(element, attribute) {
        var val = parseInt(getCSS(element, attribute), 10);
        return (isNaN(val)) ? 0 : val; // borders in old IE are throwing &#x27;medium&#x27; for demo.html
    }

    // Drawing a rectangle
    function renderRect (ctx, x, y, w, h, bgcolor) {
        if (bgcolor !==&quot;transparent&quot;){
            ctx.setVariable(&quot;fillStyle&quot;, bgcolor);
            ctx.fillRect (x, y, w, h);
            numDraws+=1;
        }
    }


    function textTransform (text, transform) {
        switch(transform){
            case &quot;lowercase&quot;:
                return text.toLowerCase();

            case &quot;capitalize&quot;:
                return text.replace( /(^|\s|:|-|\(|\))([a-z])/g , function (m, p1, p2) {
                    if (m.length &gt; 0) {
                        return p1 + p2.toUpperCase();
                    }
                } );

            case &quot;uppercase&quot;:
                return text.toUpperCase();

            default:
                return text;

        }

    }

    function trimText (text) {
        return text.replace(/^\s*/g, &quot;&quot;).replace(/\s*$/g, &quot;&quot;);
    }

    function fontMetrics (font, fontSize) {

        if (fontData[font + &quot;-&quot; + fontSize] !== undefined) {
            return fontData[font + &quot;-&quot; + fontSize];
        }


        var container = doc.createElement(&#x27;div&#x27;),
        img = doc.createElement(&#x27;img&#x27;),
        span = doc.createElement(&#x27;span&#x27;),
        baseline,
        middle,
        metricsObj;


        container.style.visibility = &quot;hidden&quot;;
        container.style.fontFamily = font;
        container.style.fontSize = fontSize;
        container.style.margin = 0;
        container.style.padding = 0;

        body.appendChild(container);



        // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)
        img.src = &quot;data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=&quot;;
        img.width = 1;
        img.height = 1;

        img.style.margin = 0;
        img.style.padding = 0;
        img.style.verticalAlign = &quot;baseline&quot;;

        span.style.fontFamily = font;
        span.style.fontSize = fontSize;
        span.style.margin = 0;
        span.style.padding = 0;




        span.appendChild(doc.createTextNode(&#x27;Hidden Text&#x27;));
        container.appendChild(span);
        container.appendChild(img);
        baseline = (img.offsetTop - span.offsetTop) + 1;

        container.removeChild(span);
        container.appendChild(doc.createTextNode(&#x27;Hidden Text&#x27;));

        container.style.lineHeight = &quot;normal&quot;;
        img.style.verticalAlign = &quot;super&quot;;

        middle = (img.offsetTop-container.offsetTop) + 1;
        metricsObj = {
            baseline: baseline,
            lineWidth: 1,
            middle: middle
        };


        fontData[font + &quot;-&quot; + fontSize] = metricsObj;

        body.removeChild(container);

        return metricsObj;

    }


    function drawText(currentText, x, y, ctx){
        if (trimText(currentText).length&gt;0) {
            ctx.fillText(currentText,x,y);
            numDraws+=1;
        }
    }


    function renderText(el, textNode, stack) {
        var ctx = stack.ctx,
        family = getCSS(el, &quot;fontFamily&quot;),
        size = getCSS(el, &quot;fontSize&quot;),
        color = getCSS(el, &quot;color&quot;),
        text_decoration = getCSS(el, &quot;textDecoration&quot;),
        text_align = getCSS(el, &quot;textAlign&quot;),
        letter_spacing = getCSS(el, &quot;letterSpacing&quot;),
        bounds,
        text,
        metrics,
        renderList,
        listLen,
        bold = getCSS(el, &quot;fontWeight&quot;),
        font_style = getCSS(el, &quot;fontStyle&quot;),
        font_variant = getCSS(el, &quot;fontVariant&quot;),
        align = false,
        newTextNode,
        textValue,
        textOffset = 0,
        oldTextNode,
        c,
        range,
        parent,
        wrapElement,
        backupText;

        // apply text-transform:ation to the text



        textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, &quot;textTransform&quot;));
        text = trimText(textNode.nodeValue);

        if (text.length&gt;0){

            if (text_decoration !== &quot;none&quot;){
                metrics = fontMetrics(family, size);
            }

            text_align = text_align.replace([&quot;-webkit-auto&quot;],[&quot;auto&quot;]);

            if (options.letterRendering === false &amp;&amp; /^(left|right|justify|auto)$/.test(text_align) &amp;&amp; /^(normal|none)$/.test(letter_spacing)){
                // this.setContextVariable(ctx,&quot;textAlign&quot;,text_align);
                renderList = textNode.nodeValue.split(/(\b| )/);

            }else{
                //  this.setContextVariable(ctx,&quot;textAlign&quot;,&quot;left&quot;);
                renderList = textNode.nodeValue.split(&quot;&quot;);
            }

            switch(parseInt(bold, 10)){
                case 401:
                    bold = &quot;bold&quot;;
                    break;
                case 400:
                    bold = &quot;normal&quot;;
                    break;
            }

            ctx.setVariable(&quot;fillStyle&quot;, color);

            /*
              need to be defined in the order as defined in http://www.w3.org/TR/CSS21/fonts.html#font-shorthand
              to properly work in Firefox
            */
            ctx.setVariable(&quot;font&quot;, font_style+ &quot; &quot; + font_variant  + &quot; &quot; + bold + &quot; &quot; + size + &quot; &quot; + family);

            if (align){
                ctx.setVariable(&quot;textAlign&quot;, &quot;right&quot;);
            }else{
                ctx.setVariable(&quot;textAlign&quot;, &quot;left&quot;);
            }


            /*
        if (stack.clip){
        ctx.rect (stack.clip.left, stack.clip.top, stack.clip.width, stack.clip.height);
        ctx.clip();
        }
             */


            oldTextNode = textNode;


            for ( c=0, listLen = renderList.length; c &lt; listLen; c+=1 ) {
                textValue = null;



                if (support.rangeBounds){
                    // getBoundingClientRect is supported for ranges
                    if (text_decoration !== &quot;none&quot; || trimText(renderList[c]).length !== 0) {
                        textValue = renderList[c];
                        if (doc.createRange){
                            range = doc.createRange();

                            range.setStart(textNode, textOffset);
                            range.setEnd(textNode, textOffset + textValue.length);
                        }else{
                            // TODO add IE support
                            range = body.createTextRange();
                        }

                        if (range.getBoundingClientRect()) {
                            bounds = range.getBoundingClientRect();
                        }else{
                            bounds = {};
                        }

                    }
                }else{
                    // it isn&#x27;t supported, so let&#x27;s wrap it inside an element instead and get the bounds there

                    // IE 9 bug
                    if (typeof oldTextNode.nodeValue !== &quot;string&quot; ){
                        continue;
                    }

                    newTextNode = oldTextNode.splitText(renderList[c].length);

                    parent = oldTextNode.parentNode;
                    wrapElement = doc.createElement(&#x27;wrapper&#x27;);
                    backupText = oldTextNode.cloneNode(true);

                    wrapElement.appendChild(oldTextNode.cloneNode(true));
                    parent.replaceChild(wrapElement, oldTextNode);

                    bounds = _html2canvas.Util.Bounds(wrapElement);

                    textValue = oldTextNode.nodeValue;

                    oldTextNode = newTextNode;
                    parent.replaceChild(backupText, wrapElement);


                }

                if (textValue !== null){
                    drawText(textValue, bounds.left, bounds.bottom, ctx);
                }

                switch(text_decoration) {
                    case &quot;underline&quot;:
                        // Draws a line at the baseline of the font
                        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                        renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);
                        break;
                    case &quot;overline&quot;:
                        renderRect(ctx, bounds.left, bounds.top, bounds.width, 1, color);
                        break;
                    case &quot;line-through&quot;:
                        // TODO try and find exact position for line-through
                        renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);
                        break;

                }





                textOffset += renderList[c].length;

            }



        }

    }

    function listPosition (element, val) {
        var boundElement = doc.createElement( &quot;boundelement&quot; ),
        type,
        bounds;

        boundElement.style.display = &quot;inline&quot;;
        //boundElement.style.width = &quot;1px&quot;;
        //boundElement.style.height = &quot;1px&quot;;

        type = element.style.listStyleType;
        element.style.listStyleType = &quot;none&quot;;

        boundElement.appendChild( doc.createTextNode( val ) );


        element.insertBefore(boundElement, element.firstChild);


        bounds = _html2canvas.Util.Bounds( boundElement );
        element.removeChild( boundElement );
        element.style.listStyleType = type;
        return bounds;

    }
    

    
    function elementIndex( el ) {
        var i = -1,
        count = 1,
        childs = el.parentNode.childNodes;

        if ( el.parentNode ) {
            while( childs[ ++i ] !== el ) {
               if ( childs[ i ].nodeType === 1 ) {
                   count++;
               }
            }
            return count;
        } else {
            return -1;
        }
       
    }

    function renderListItem(element, stack, elBounds) {


        var position = getCSS(element, &quot;listStylePosition&quot;),
        x,
        y,
        type = getCSS(element, &quot;listStyleType&quot;),
        currentIndex,
        text,
        listBounds,
        bold = getCSS(element, &quot;fontWeight&quot;);

        if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {

            currentIndex = elementIndex( element );

            switch(type){
                case &quot;decimal&quot;:
                    text = currentIndex;
                    break;
                case &quot;decimal-leading-zero&quot;:
                    if (currentIndex.toString().length === 1){
                        text = currentIndex = &quot;0&quot; + currentIndex.toString();
                    }else{
                        text = currentIndex.toString();
                    }
                    break;
                case &quot;upper-roman&quot;:
                    text = _html2canvas.Generate.ListRoman( currentIndex );
                    break;
                case &quot;lower-roman&quot;:
                    text = _html2canvas.Generate.ListRoman( currentIndex ).toLowerCase();
                    break;
                case &quot;lower-alpha&quot;:
                    text = _html2canvas.Generate.ListAlpha( currentIndex ).toLowerCase();
                    break;
                case &quot;upper-alpha&quot;:
                    text = _html2canvas.Generate.ListAlpha( currentIndex );
                    break;
            }


            text += &quot;. &quot;;
            listBounds = listPosition(element, text);



            switch(bold){
                case 401:
                    bold = &quot;bold&quot;;
                    break;
                case 400:
                    bold = &quot;normal&quot;;
                    break;
            }




            ctx.setVariable( &quot;fillStyle&quot;, getCSS(element, &quot;color&quot;) );
            ctx.setVariable( &quot;font&quot;, getCSS(element, &quot;fontVariant&quot;) + &quot; &quot; + bold + &quot; &quot; + getCSS(element, &quot;fontStyle&quot;) + &quot; &quot; + getCSS(element, &quot;fontSize&quot;) + &quot; &quot; + getCSS(element, &quot;fontFamily&quot;) );


            if ( position === &quot;inside&quot; ) {
                ctx.setVariable(&quot;textAlign&quot;, &quot;left&quot;);
                //   this.setFont(stack.ctx, element, false);
                x = elBounds.left;

            }else{
                return;
            /*
                 TODO really need to figure out some more accurate way to try and find the position.
                 as defined in http://www.w3.org/TR/CSS21/generate.html#propdef-list-style-position, it does not even have a specified &quot;correct&quot; position, so each browser
                 may display it whatever way it feels like.
                 &quot;The position of the list-item marker adjacent to floats is undefined in CSS 2.1. CSS 2.1 does not specify the precise location of the marker box or its position in the painting order&quot;

                ctx.setVariable(&quot;textAlign&quot;, &quot;right&quot;);
                //  this.setFont(stack.ctx, element, true);
                x = elBounds.left - 10;
                 */
            }

            y = listBounds.bottom;

            drawText(text, x, y, ctx);


        }


    }

    function loadImage (src){
        var img = images[src];
        if (img &amp;&amp; img.succeeded === true) {
            return img.img;
        } else {
            return false;
        }
    }






    function clipBounds(src, dst){

        var x = Math.max(src.left, dst.left),
        y = Math.max(src.top, dst.top),
        x2 = Math.min((src.left + src.width), (dst.left + dst.width)),
        y2 = Math.min((src.top + src.height), (dst.top + dst.height));

        return {
            left:x,
            top:y,
            width:x2-x,
            height:y2-y
        };

    }

    function setZ(zIndex, parentZ){
        // TODO fix static elements overlapping relative/absolute elements under same stack, if they are defined after them
        var newContext;
        if (!parentZ){
            newContext = h2czContext(0);
            return newContext;
        }

        if (zIndex !== &quot;auto&quot;){
            needReorder = true;
            newContext = h2czContext(zIndex);
            parentZ.children.push(newContext);
            return newContext;

        }

        return parentZ;

    }

    function renderBorders(el, ctx, bounds, clip){

        /*
         *  TODO add support for different border-style&#x27;s than solid
         */

        var x = bounds.left,
        y = bounds.top,
        w = bounds.width,
        h = bounds.height,
        borderSide,
        borderData,
        bx,
        by,
        bw,
        bh,
        borderBounds,
        borders = (function(el){
            var borders = [],
            sides = [&quot;Top&quot;,&quot;Right&quot;,&quot;Bottom&quot;,&quot;Left&quot;],
            s;

            for (s = 0; s &lt; 4; s+=1){
                borders.push({
                    width: getCSSInt(el, &#x27;border&#x27; + sides[s] + &#x27;Width&#x27;),
                    color: getCSS(el, &#x27;border&#x27; + sides[s] + &#x27;Color&#x27;)
                });
            }

            return borders;

        }(el));


        for (borderSide = 0; borderSide &lt; 4; borderSide+=1){
            borderData = borders[borderSide];

            if (borderData.width&gt;0){
                bx = x;
                by = y;
                bw = w;
                bh = h - (borders[2].width);

                switch(borderSide){
                    case 0:
                        // top border
                        bh = borders[0].width;
                        break;
                    case 1:
                        // right border
                        bx = x + w - (borders[1].width);
                        bw = borders[1].width;
                        break;
                    case 2:
                        // bottom border
                        by = (by + h) - (borders[2].width);
                        bh = borders[2].width;
                        break;
                    case 3:
                        // left border
                        bw = borders[3].width;
                        break;
                }

                borderBounds = {
                    left:bx,
                    top:by,
                    width: bw,
                    height:bh
                };

                if (clip){
                    borderBounds = clipBounds(borderBounds, clip);
                }


                if (borderBounds.width&gt;0 &amp;&amp; borderBounds.height&gt;0){
                    renderRect(ctx, bx, by, borderBounds.width, borderBounds.height, borderData.color);
                }


            }
        }

        return borders;

    }


    function renderFormValue (el, bounds, stack){

        var valueWrap = doc.createElement(&#x27;valuewrap&#x27;),
        cssArr = [&#x27;lineHeight&#x27;,&#x27;textAlign&#x27;,&#x27;fontFamily&#x27;,&#x27;color&#x27;,&#x27;fontSize&#x27;,&#x27;paddingLeft&#x27;,&#x27;paddingTop&#x27;,&#x27;width&#x27;,&#x27;height&#x27;,&#x27;border&#x27;,&#x27;borderLeftWidth&#x27;,&#x27;borderTopWidth&#x27;],
        i,
        textValue,
        textNode,
        arrLen,
        style;

        for (i = 0, arrLen = cssArr.length; i &lt; arrLen; i+=1){
            style = cssArr[i];

            try {
                valueWrap.style[style] = getCSS(el, style);
            } catch( e ) {
                // Older IE has issues with &quot;border&quot;
                h2clog(&quot;html2canvas: Parse: Exception caught in renderFormValue: &quot; + e.message);
            }
        }


        valueWrap.style.borderColor = &quot;black&quot;;
        valueWrap.style.borderStyle = &quot;solid&quot;;
        valueWrap.style.display = &quot;block&quot;;
        valueWrap.style.position = &quot;absolute&quot;;
        if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === &quot;SELECT&quot;){
            valueWrap.style.lineHeight = getCSS(el, &quot;height&quot;);
        }


        valueWrap.style.top = bounds.top + &quot;px&quot;;
        valueWrap.style.left = bounds.left + &quot;px&quot;;

        if (el.nodeName === &quot;SELECT&quot;){
            // TODO increase accuracy of text position
            textValue = el.options[el.selectedIndex].text;
        } else{
            textValue = el.value;
        }
        textNode = doc.createTextNode(textValue);

        valueWrap.appendChild(textNode);
        body.appendChild(valueWrap);


        renderText(el, textNode, stack);
        body.removeChild(valueWrap);



    }





    function renderImage (ctx, image, sx, sy, sw, sh, dx, dy, dw, dh) {
        ctx.drawImage(
            image,
            sx, //sx
            sy, //sy
            sw, //sw
            sh, //sh
            dx, //dx
            dy, // dy
            dw, //dw
            dh //dh
            );
        numDraws+=1;

    }


    function renderBackgroundRepeat (ctx, image, x, y, width, height, elx, ely){
        var sourceX = 0,
        sourceY=0;
        if (elx-x&gt;0){
            sourceX = elx-x;
        }

        if (ely-y&gt;0){
            sourceY = ely-y;
        }

        renderImage(
            ctx,
            image,
            sourceX, // source X
            sourceY, // source Y
            width-sourceX, // source Width
            height-sourceY, // source Height
            x+sourceX, // destination X
            y+sourceY, // destination Y
            width-sourceX, // destination width
            height-sourceY // destination height
            );
    }


    function renderBackgroundRepeatY (ctx, image, bgp, x, y, w, h){

        var height,
        width = Math.min(image.width,w),bgy;

        bgp.top = bgp.top-Math.ceil(bgp.top/image.height)*image.height;


        for(bgy=(y+bgp.top);bgy&lt;h+y;){


            if ( Math.floor(bgy+image.height)&gt;h+y){
                height = (h+y)-bgy;
            }else{
                height = image.height;
            }
            renderBackgroundRepeat(ctx,image,x+bgp.left,bgy,width,height,x,y);

            bgy = Math.floor(bgy+image.height);

        }
    }

    function renderBackgroundRepeatX(ctx, image, bgp, x, y, w, h){

        var height = Math.min(image.height,h),
        width,bgx;


        bgp.left = bgp.left-Math.ceil(bgp.left/image.width)*image.width;


        for (bgx=(x+bgp.left);bgx&lt;w+x;) {

            if (Math.floor(bgx+image.width)&gt;w+x){
                width = (w+x)-bgx;
            }else{
                width = image.width;
            }

            renderBackgroundRepeat(ctx,image,bgx,(y+bgp.top),width,height,x,y);

            bgx = Math.floor(bgx+image.width);


        }
    }

    function renderBackground(el,bounds,ctx){

        // TODO add support for multi background-images
        var background_image = getCSS(el, &quot;backgroundImage&quot;),
        background_repeat = getCSS(el, &quot;backgroundRepeat&quot;).split(&quot;,&quot;)[0],
        image,
        bgp,
        bgy,
        bgw,
        bgsx,
        bgsy,
        bgdx,
        bgdy,
        bgh,
        h,
        height,
        add;

        //   if (typeof background_image !== &quot;undefined&quot; &amp;&amp; /^(1|none)$/.test(background_image) === false &amp;&amp; /^(-webkit|-moz|linear-gradient|-o-)/.test(background_image)===false){

        if ( !/data:image\/.*;base64,/i.test(background_image) &amp;&amp; !/^(-webkit|-moz|linear-gradient|-o-)/.test(background_image) ) {
            background_image = background_image.split(&quot;,&quot;)[0];
        }

        if ( typeof background_image !== &quot;undefined&quot; &amp;&amp; /^(1|none)$/.test( background_image ) === false ) {
            background_image = _html2canvas.Util.backgroundImage( background_image );
            image = loadImage( background_image );


            bgp = _html2canvas.Util.BackgroundPosition(el, bounds, image);

            // TODO add support for background-origin
            if ( image ){
                switch ( background_repeat ) {

                    case &quot;repeat-x&quot;:
                        renderBackgroundRepeatX( ctx, image, bgp, bounds.left, bounds.top, bounds.width, bounds.height );
                        break;

                    case &quot;repeat-y&quot;:
                        renderBackgroundRepeatY( ctx, image, bgp, bounds.left, bounds.top, bounds.width, bounds.height );
                        break;

                    case &quot;no-repeat&quot;:
                        /*
                    this.drawBackgroundRepeat(
                        ctx,
                        image,
                        bgp.left+bounds.left, // sx
                        bgp.top+bounds.top, // sy
                        Math.min(bounds.width,image.width),
                        Math.min(bounds.height,image.height),
                        bounds.left,
                        bounds.top
                        );*/


                       
                        bgw = bounds.width - bgp.left;
                        bgh = bounds.height - bgp.top;
                        bgsx = bgp.left;
                        bgsy = bgp.top;
                        bgdx = bgp.left+bounds.left;
                        bgdy = bgp.top+bounds.top;

                        //
                        //     bgw = Math.min(bgw,image.width);
                        //  bgh = Math.min(bgh,image.height);

                        if (bgsx&lt;0){
                            bgsx = Math.abs(bgsx);
                            bgdx += bgsx;
                            bgw = Math.min(bounds.width,image.width-bgsx);
                        }else{
                            bgw = Math.min(bgw,image.width);
                            bgsx = 0;
                        }

                        if (bgsy&lt;0){
                            bgsy = Math.abs(bgsy);
                            bgdy += bgsy;
                            // bgh = bgh-bgsy;
                            bgh = Math.min(bounds.height,image.height-bgsy);
                        }else{
                            bgh = Math.min(bgh,image.height);
                            bgsy = 0;
                        }


                        if (bgh&gt;0 &amp;&amp; bgw &gt; 0){
                            renderImage(
                                ctx,
                                image,
                                bgsx, // source X : 0
                                bgsy, // source Y : 1695
                                bgw, // source Width : 18
                                bgh, // source Height : 1677
                                bgdx, // destination X :906
                                bgdy, // destination Y : 1020
                                bgw, // destination width : 18
                                bgh // destination height : 1677
                                );

                        }
                        break;
                    default:



                        bgp.top = bgp.top-Math.ceil(bgp.top/image.height)*image.height;


                        for(bgy=(bounds.top+bgp.top);bgy&lt;bounds.height+bounds.top;){



                            h = Math.min(image.height,(bounds.height+bounds.top)-bgy);


                            if ( Math.floor(bgy+image.height)&gt;h+bgy){
                                height = (h+bgy)-bgy;
                            }else{
                                height = image.height;
                            }
                            // console.log(height);

                            if (bgy&lt;bounds.top){
                                add = bounds.top-bgy;
                                bgy = bounds.top;

                            }else{
                                add = 0;
                            }

                            renderBackgroundRepeatX(ctx,image,bgp,bounds.left,bgy,bounds.width,height);
                            if (add&gt;0){
                                bgp.top += add;
                            }
                            bgy = Math.floor(bgy+image.height)-add;
                        }
                        break;


                }
            }else{
                h2clog(&quot;html2canvas: Error loading background:&quot; + background_image);
            //console.log(images);
            }

        }
    }



    function renderElement(el, parentStack){

        var bounds = _html2canvas.Util.Bounds(el),
        x = bounds.left,
        y = bounds.top,
        w = bounds.width,
        h = bounds.height,
        image,
        bgcolor = getCSS(el, &quot;backgroundColor&quot;),
        cssPosition = getCSS(el, &quot;position&quot;),
        zindex,
        opacity = getCSS(el, &quot;opacity&quot;),
        stack,
        stackLength,
        borders,
        ctx,
        bgbounds,
        imgSrc,
        paddingLeft,
        paddingTop,
        paddingRight,
        paddingBottom;

        if (!parentStack){
            docDim = docSize();
            parentStack = {
                opacity: 1
            };
        }else{
            docDim = {};
        }


        //var zindex = this.formatZ(this.getCSS(el,&quot;zIndex&quot;),cssPosition,parentStack.zIndex,el.parentNode);

        zindex = setZ( getCSS( el, &quot;zIndex&quot;), parentStack.zIndex );



        stack = {
            ctx: h2cRenderContext( docDim.width || w , docDim.height || h ),
            zIndex: zindex,
            opacity: opacity * parentStack.opacity,
            cssPosition: cssPosition
        };



        // TODO correct overflow for absolute content residing under a static position

        if (parentStack.clip){
            stack.clip = _html2canvas.Util.Extend( {}, parentStack.clip );
        //stack.clip = parentStack.clip;
        //   stack.clip.height = stack.clip.height - parentStack.borders[2].width;
        }


        if ( options.useOverflow === true &amp;&amp; /(hidden|scroll|auto)/.test(getCSS(el, &quot;overflow&quot;)) === true &amp;&amp; /(BODY)/i.test(el.nodeName) === false ){
            if (stack.clip){
                stack.clip = clipBounds(stack.clip, bounds);
            }else{
                stack.clip = bounds;
            }
        }


        stackLength =  zindex.children.push(stack);

        ctx = zindex.children[stackLength-1].ctx;

        ctx.setVariable(&quot;globalAlpha&quot;, stack.opacity);

        // draw element borders
        borders = renderBorders(el, ctx, bounds, false);
        stack.borders = borders;


        // let&#x27;s modify clip area for child elements, so borders dont get overwritten

        /*
    if (stack.clip){
        stack.clip.width = stack.clip.width-(borders[1].width);
        stack.clip.height = stack.clip.height-(borders[2].width);
    }
     */
        if (ignoreElementsRegExp.test(el.nodeName) &amp;&amp; options.iframeDefault !== &quot;transparent&quot;){
            if (options.iframeDefault === &quot;default&quot;){
                bgcolor = &quot;#efefef&quot;;
            }else{
                bgcolor = options.iframeDefault;
            }
        }

        // draw base element bgcolor

        bgbounds = {
            left: x + borders[3].width,
            top: y + borders[0].width,
            width: w - (borders[1].width + borders[3].width),
            height: h - (borders[0].width + borders[2].width)
        };

        //if (this.withinBounds(stack.clip,bgbounds)){

        if (stack.clip){
            bgbounds = clipBounds(bgbounds, stack.clip);

        //}

        }


        if (bgbounds.height &gt; 0 &amp;&amp; bgbounds.width &gt; 0){
            renderRect(
                ctx,
                bgbounds.left,
                bgbounds.top,
                bgbounds.width,
                bgbounds.height,
                bgcolor
                );

            renderBackground(el, bgbounds, ctx);
        }

        switch(el.nodeName){
            case &quot;IMG&quot;:
                imgSrc = el.getAttribute(&#x27;src&#x27;);
                image = loadImage(imgSrc);
                if (image){

                    paddingLeft = getCSSInt(el, &#x27;paddingLeft&#x27;);
                    paddingTop = getCSSInt(el, &#x27;paddingTop&#x27;);
                    paddingRight = getCSSInt(el, &#x27;paddingRight&#x27;);
                    paddingBottom = getCSSInt(el, &#x27;paddingBottom&#x27;);


                    renderImage(
                        ctx,
                        image,
                        0, //sx
                        0, //sy
                        image.width, //sw
                        image.height, //sh
                        x + paddingLeft + borders[3].width, //dx
                        y + paddingTop + borders[0].width, // dy
                        bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
                        bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
                        );

                }else{
                    h2clog(&quot;html2canvas: Error loading &lt;img&gt;:&quot; + imgSrc);
                }
                break;
            case &quot;INPUT&quot;:
                // TODO add all relevant type&#x27;s, i.e. HTML5 new stuff
                // todo add support for placeholder attribute for browsers which support it
                if (/^(text|url|email|submit|button|reset)$/.test(el.type) &amp;&amp; el.value.length &gt; 0){

                    renderFormValue(el, bounds, stack);


                /*
                 this just doesn&#x27;t work well enough

                this.newText(el,{
                    nodeValue:el.value,
                    splitText: function(){
                        return this;
                    },
                    formValue:true
                },stack);
                 */
                }
                break;
            case &quot;TEXTAREA&quot;:
                if (el.value.length &gt; 0){
                    renderFormValue(el, bounds, stack);
                }
                break;
            case &quot;SELECT&quot;:
                if (el.options.length &gt; 0){
                    renderFormValue(el, bounds, stack);
                }
                break;
            case &quot;LI&quot;:
                renderListItem(el, stack, bgbounds);
                break;
            case &quot;CANVAS&quot;:
                paddingLeft = getCSSInt(el, &#x27;paddingLeft&#x27;);
                paddingTop = getCSSInt(el, &#x27;paddingTop&#x27;);
                paddingRight = getCSSInt(el, &#x27;paddingRight&#x27;);
                paddingBottom = getCSSInt(el, &#x27;paddingBottom&#x27;);
                renderImage(
                    ctx,
                    el,
                    0, //sx
                    0, //sy
                    el.width, //sw
                    el.height, //sh
                    x + paddingLeft + borders[3].width, //dx
                    y + paddingTop + borders[0].width, // dy
                    bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
                    bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
                    );
                break;
        }

        return zindex.children[stackLength - 1];
    }



    function parseElement (el, stack) {

        // skip hidden elements and their children
        if (getCSS(el, &#x27;display&#x27;) !== &quot;none&quot; &amp;&amp; getCSS(el, &#x27;visibility&#x27;) !== &quot;hidden&quot;) {

            stack = renderElement(el, stack) || stack;

            ctx = stack.ctx;

            if ( !ignoreElementsRegExp.test( el.nodeName ) ) {
                var elementChildren = _html2canvas.Util.Children( el ),
                i,
                node,
                childrenLen;
                for (i = 0, childrenLen = elementChildren.length; i &lt; childrenLen; i+=1) {
                    node = elementChildren[i];

                    if ( node.nodeType === 1 ) {
                        parseElement(node, stack);
                    }else if ( node.nodeType === 3 ) {
                        renderText(el, node, stack);
                    }

                }

            }
        } 
    }

    stack = renderElement(element, null);

    /*
    SVG powered HTML rendering, non-tainted canvas available from FF 11+ onwards
    */

    if ( support.svgRendering ) {
        (function( body ){
            var img = new Image(),
            size =  docSize(),
            html = &quot;&quot;;

            function parseDOM( el ) {
                var children = _html2canvas.Util.Children( el ),
                len = children.length,
                attr,
                a,
                alen,
                elm,
                i;
                for ( i = 0; i &lt; len; i+=1 ) {
                    elm = children[ i ];
                    if ( elm.nodeType === 3 ) {
                        // Text node

                        html += elm.nodeValue.replace(/\&lt;/g,&quot;&amp;lt;&quot;).replace(/\&gt;/g,&quot;&amp;gt;&quot;);
                    } else if ( elm.nodeType === 1 ) {
                        // Element
                        if ( !/^(script|meta|title)$/.test(elm.nodeName.toLowerCase()) ) {

                            html += &quot;&lt;&quot; + elm.nodeName.toLowerCase();

                            // add attributes
                            if ( elm.hasAttributes() ) {
                                attr = elm.attributes;
                                alen = attr.length;
                                for ( a = 0; a &lt; alen; a+=1 ) {
                                    html += &quot; &quot; + attr[ a ].name + &#x27;=&quot;&#x27; + attr[ a ].value + &#x27;&quot;&#x27;;
                                }
                            }


                            html += &#x27;&gt;&#x27;;

                            parseDOM( elm );


                            html += &quot;&lt;/&quot; + elm.nodeName.toLowerCase() + &quot;&gt;&quot;;
                        }
                    }

                }

            }

            parseDOM( body );
            img.src = [
            &quot;data:image/svg+xml,&quot;,
            &quot;&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27; width=&#x27;&quot; + size.width + &quot;&#x27; height=&#x27;&quot; + size.height + &quot;&#x27;&gt;&quot;,
            &quot;&lt;foreignObject width=&#x27;&quot; + size.width + &quot;&#x27; height=&#x27;&quot; + size.height + &quot;&#x27;&gt;&quot;,
            &quot;&lt;html xmlns=&#x27;http://www.w3.org/1999/xhtml&#x27; style=&#x27;margin:0;&#x27;&gt;&quot;,
            html.replace(/\#/g,&quot;%23&quot;),
            &quot;&lt;/html&gt;&quot;,
            &quot;&lt;/foreignObject&gt;&quot;,
            &quot;&lt;/svg&gt;&quot;
            ].join(&quot;&quot;);




            img.onload = function() {
                stack.svgRender = img;
            };

        })( document.documentElement );

    }


    // parse every child element
    for (i = 0, children = element.children, childrenLen = children.length; i &lt; childrenLen; i+=1){
        parseElement(children[i], stack);
    }


    stack.backgroundColor = getCSS( document.documentElement, &quot;backgroundColor&quot; );

    return stack;

};

function h2czContext(zindex) {
    return {
        zindex: zindex,
        children: []
    };
}

/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
 */

_html2canvas.Preload = function( options ) {

    var images = {
        numLoaded: 0,   // also failed are counted here
        numFailed: 0,
        numTotal: 0,
        cleanupDone: false
    },
    pageOrigin,
    methods,
    i,
    count = 0,
    element = options.elements[0] || document.body,
    doc = element.ownerDocument,
    domImages = doc.images, // TODO probably should limit it to images present in the element only
    imgLen = domImages.length,
    link = doc.createElement(&quot;a&quot;),
    supportCORS = (function( img ){
        return (img.crossOrigin !== undefined);
    })(new Image()),
    timeoutTimer;

    link.href = window.location.href;
    pageOrigin  = link.protocol + link.host;






    function isSameOrigin(url){
        link.href = url;
        link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/
        var origin = link.protocol + link.host;
        return (origin === pageOrigin);
    }

    function start(){
        h2clog(&quot;html2canvas: start: images: &quot; + images.numLoaded + &quot; / &quot; + images.numTotal + &quot; (failed: &quot; + images.numFailed + &quot;)&quot;);
        if (!images.firstRun &amp;&amp; images.numLoaded &gt;= images.numTotal){
            h2clog(&quot;Finished loading images: # &quot; + images.numTotal + &quot; (failed: &quot; + images.numFailed + &quot;)&quot;);

            if (typeof options.complete === &quot;function&quot;){
                options.complete(images);
            }

        }
    }

    // TODO modify proxy to serve images with CORS enabled, where available
    function proxyGetImage(url, img, imageObj){
        var callback_name,
        scriptUrl = options.proxy,
        script;

        link.href = url;
        url = link.href; // work around for pages with base href=&quot;&quot; set - WARNING: this may change the url

        callback_name = &#x27;html2canvas_&#x27; + (count++);
        imageObj.callbackname = callback_name;

        if (scriptUrl.indexOf(&quot;?&quot;) &gt; -1) {
            scriptUrl += &quot;&amp;&quot;;
        } else {
            scriptUrl += &quot;?&quot;;
        }
        scriptUrl += &#x27;url=&#x27; + encodeURIComponent(url) + &#x27;&amp;callback=&#x27; + callback_name;
        script = doc.createElement(&quot;script&quot;);

        window[callback_name] = function(a){
            if (a.substring(0,6) === &quot;error:&quot;){
                imageObj.succeeded = false;
                images.numLoaded++;
                images.numFailed++;
                start();
            } else {
                setImageLoadHandlers(img, imageObj);
                img.src = a;
            }
            window[callback_name] = undefined; // to work with IE&lt;9  // NOTE: that the undefined callback property-name still exists on the window object (for IE&lt;9)
            try {
                delete window[callback_name];  // for all browser that support this
            } catch(ex) {}
            script.parentNode.removeChild(script);
            script = null;
            delete imageObj.script;
            delete imageObj.callbackname;
        };

        script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;);
        script.setAttribute(&quot;src&quot;, scriptUrl);
        imageObj.script = script;
        window.document.body.appendChild(script);

    }

    function getImages (el) {



        // if (!this.ignoreRe.test(el.nodeName)){
        //
        
        var contents = _html2canvas.Util.Children(el),
        i,
        background_image,
        src,
        img,
        elNodeType = false;

        // Firefox fails with permission denied on pages with iframes
        try {
            var contentsLen = contents.length;
            for (i = 0;  i &lt; contentsLen; i+=1 ){
                // var ignRe = new RegExp(&quot;(&quot;+this.ignoreElements+&quot;)&quot;);
                // if (!ignRe.test(element.nodeName)){
                getImages(contents[i]);
                // }
            }
        }
        catch( e ) {}


        // }
        try {
            elNodeType = el.nodeType;
        } catch (ex) {
            elNodeType = false;
            h2clog(&quot;html2canvas: failed to access some element&#x27;s nodeType - Exception: &quot; + ex.message);
        }

        if (elNodeType === 1 || elNodeType === undefined){

            // opera throws exception on external-content.html
            try {
                background_image = _html2canvas.Util.getCSS(el, &#x27;backgroundImage&#x27;);
            }catch(e) {
                h2clog(&quot;html2canvas: failed to get background-image - Exception: &quot; + e.message);
            }
            if ( background_image &amp;&amp; background_image !== &quot;1&quot; &amp;&amp; background_image !== &quot;none&quot; ) {

                // TODO add multi image background support

                if (/^(-webkit|-o|-moz|-ms|linear)-/.test( background_image )) {

                    img = _html2canvas.Generate.Gradient( background_image, _html2canvas.Util.Bounds( el ) );

                    if ( img !== undefined ){
                        images[background_image] = {
                            img: img,
                            succeeded: true
                        };
                        images.numTotal++;
                        images.numLoaded++;
                        start();

                    }

                } else {
                    src = _html2canvas.Util.backgroundImage(background_image.match(/data:image\/.*;base64,/i) ? background_image : background_image.split(&quot;,&quot;)[0]);
                    methods.loadImage(src);
                }

                /*
            if (background_image &amp;&amp; background_image !== &quot;1&quot; &amp;&amp; background_image !== &quot;none&quot; &amp;&amp; background_image.substring(0,7) !== &quot;-webkit&quot; &amp;&amp; background_image.substring(0,3)!== &quot;-o-&quot; &amp;&amp; background_image.substring(0,4) !== &quot;-moz&quot;){
                // TODO add multi image background support
                src = _html2canvas.Util.backgroundImage(background_image.split(&quot;,&quot;)[0]);
                methods.loadImage(src);            */
            }
        }
    }

    function setImageLoadHandlers(img, imageObj) {
        img.onload = function() {
            if ( imageObj.timer !== undefined ) {
                // CORS succeeded
                window.clearTimeout( imageObj.timer );
            }

            images.numLoaded++;
            imageObj.succeeded = true;
            img.onerror = img.onload = null;
            start();
        };
        img.onerror = function() {

            if (img.crossOrigin === &quot;anonymous&quot;) {
                // CORS failed
                window.clearTimeout( imageObj.timer );

                // let&#x27;s try with proxy instead
                if ( options.proxy ) {
                    var src = img.src;
                    img = new Image();
                    imageObj.img = img;
                    img.src = src;

                    proxyGetImage( img.src, img, imageObj );
                    return;
                }
            }


            images.numLoaded++;
            images.numFailed++;
            imageObj.succeeded = false;
            img.onerror = img.onload = null;
            start();

        };

        // TODO Opera has no load/error event for SVG images

        // Opera ninja onload&#x27;s cached images
        /*
        window.setTimeout(function(){
            if ( img.width !== 0 &amp;&amp; imageObj.succeeded === undefined ) {
                img.onload();
            }
        }, 100); // needs a reflow for base64 encoded images? interestingly timeout of 0 doesn&#x27;t work but 1 does.
         */
    }


    methods = {
        loadImage: function( src ) {
            var img, imageObj;
            if ( src &amp;&amp; images[src] === undefined ) {
                img = new Image();
                if ( src.match(/data:image\/.*;base64,/i) ) {
                    img.src = src.replace(/url\([&#x27;&quot;]{0,}|[&#x27;&quot;]{0,}\)$/ig, &#x27;&#x27;);
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    setImageLoadHandlers(img, imageObj);
                } else if ( isSameOrigin( src ) || options.allowTaint ===  true ) {
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    setImageLoadHandlers(img, imageObj);
                    img.src = src;
                } else if ( supportCORS &amp;&amp; !options.allowTaint &amp;&amp; options.useCORS ) {
                    // attempt to load with CORS

                    img.crossOrigin = &quot;anonymous&quot;;
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    setImageLoadHandlers(img, imageObj);
                    img.src = src;

                    // work around for https://bugs.webkit.org/show_bug.cgi?id=80028
                    img.customComplete = function () {
                        if (!this.img.complete) {
                            this.timer = window.setTimeout(this.img.customComplete, 100);
                        } else {
                            this.img.onerror();
                        }
                    }.bind(imageObj);
                    img.customComplete();

                } else if ( options.proxy ) {
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    proxyGetImage( src, img, imageObj );
                }
            }

        },
        cleanupDOM: function(cause) {
            var img, src;
            if (!images.cleanupDone) {
                if (cause &amp;&amp; typeof cause === &quot;string&quot;) {
                    h2clog(&quot;html2canvas: Cleanup because: &quot; + cause);
                } else {
                    h2clog(&quot;html2canvas: Cleanup after timeout: &quot; + options.timeout + &quot; ms.&quot;);
                }

                for (src in images) {
                    if (images.hasOwnProperty(src)) {
                        img = images[src];
                        if (typeof img === &quot;object&quot; &amp;&amp; img.callbackname &amp;&amp; img.succeeded === undefined) {
                            // cancel proxy image request
                            window[img.callbackname] = undefined; // to work with IE&lt;9  // NOTE: that the undefined callback property-name still exists on the window object (for IE&lt;9)
                            try {
                                delete window[img.callbackname];  // for all browser that support this
                            } catch(ex) {}
                            if (img.script &amp;&amp; img.script.parentNode) {
                                img.script.setAttribute(&quot;src&quot;, &quot;about:blank&quot;);  // try to cancel running request
                                img.script.parentNode.removeChild(img.script);
                            }
                            images.numLoaded++;
                            images.numFailed++;
                            h2clog(&quot;html2canvas: Cleaned up failed img: &#x27;&quot; + src + &quot;&#x27; Steps: &quot; + images.numLoaded + &quot; / &quot; + images.numTotal);
                        }
                    }
                }

                // cancel any pending requests
                if(window.stop !== undefined) {
                    window.stop();
                } else if(document.execCommand !== undefined) {
                    document.execCommand(&quot;Stop&quot;, false);
                }
                if (document.close !== undefined) {
                    document.close();
                }
                images.cleanupDone = true;
                if (!(cause &amp;&amp; typeof cause === &quot;string&quot;)) {
                    start();
                }
            }
        },
        renderingDone: function() {
            if (timeoutTimer) {
                window.clearTimeout(timeoutTimer);
            }
        }

    };

    if (options.timeout &gt; 0) {
        timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);
    }
    h2clog(&#x27;html2canvas: Preload starts: finding background-images&#x27;);
    images.firstRun = true;

    getImages( element );

    h2clog(&#x27;html2canvas: Preload: Finding images&#x27;);
    // load &lt;img&gt; images
    for (i = 0; i &lt; imgLen; i+=1){
        methods.loadImage( domImages[i].getAttribute( &quot;src&quot; ) );
    }

    images.firstRun = false;
    h2clog(&#x27;html2canvas: Preload: Done.&#x27;);
    if ( images.numTotal === images.numLoaded ) {
        start();
    }

    return methods;

};




/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/
function h2cRenderContext(width, height) {
    var storage = [];
    return {
        storage: storage,
        width: width,
        height: height,
        fillRect: function () {
            storage.push({
                type: &quot;function&quot;,
                name: &quot;fillRect&quot;,
                &#x27;arguments&#x27;: arguments
            });
        },
        drawImage: function () {
            storage.push({
                type: &quot;function&quot;,
                name: &quot;drawImage&quot;,
                &#x27;arguments&#x27;: arguments
            });
        },
        fillText: function () {
            storage.push({
                type: &quot;function&quot;,
                name: &quot;fillText&quot;,
                &#x27;arguments&#x27;: arguments
            });
        },
        setVariable: function (variable, value) {
            storage.push({
                type: &quot;variable&quot;,
                name: variable,
                &#x27;arguments&#x27;: value
            });
        }
    };
}

/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/
_html2canvas.Renderer = function(parseQueue, options){


    var queue = [];

    function sortZ(zStack){
        var subStacks = [],
        stackValues = [],
        zStackChildren = zStack.children,
        s,
        i,
        stackLen,
        zValue,
        zLen,
        stackChild,
        b,
        subStackLen;


        for (s = 0, zLen = zStackChildren.length; s &lt; zLen; s+=1){

            stackChild = zStackChildren[s];

            if (stackChild.children &amp;&amp; stackChild.children.length &gt; 0){
                subStacks.push(stackChild);
                stackValues.push(stackChild.zindex);
            }else{
                queue.push(stackChild);
            }

        }

        stackValues.sort(function(a, b) {
            return a - b;
        });

        for (i = 0, stackLen = stackValues.length; i &lt; stackLen; i+=1){
            zValue = stackValues[i];
            for (b = 0, subStackLen = subStacks.length; b &lt;= subStackLen; b+=1){

                if (subStacks[b].zindex === zValue){
                    stackChild = subStacks.splice(b, 1);
                    sortZ(stackChild[0]);
                    break;

                }
            }
        }

    }


    sortZ(parseQueue.zIndex);
    if ( typeof options._renderer._create !== &quot;function&quot; ) {
        throw new Error(&quot;Invalid renderer defined&quot;);
    }
    return options._renderer._create( parseQueue, options, document, queue, _html2canvas );

};

/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/


html2canvas = function( elements, opts ) {

    var queue,
    canvas,
    options = {
        // general
        logging: false,
        elements: elements,

        // preload options
        proxy: &quot;http://html2canvas.appspot.com/&quot;,
        timeout: 0,    // no timeout
        useCORS: false, // try to load images as CORS (where available), before falling back to proxy
        allowTaint: false, // whether to allow images to taint the canvas, won&#x27;t need proxy if set to true

        // parse options
        svgRendering: false, // use svg powered rendering where available (FF11+)
        iframeDefault: &quot;default&quot;,
        ignoreElements: &quot;IFRAME|OBJECT|PARAM&quot;,
        useOverflow: true,
        letterRendering: false,

        // render options

        flashcanvas: undefined, // path to flashcanvas
        width: null,
        height: null,
        taintTest: true, // do a taint test with all images before applying to canvas
		renderer: &quot;Canvas&quot;
    }, renderer;

    options = _html2canvas.Util.Extend(opts, options);

	if (typeof options.renderer === &quot;string&quot; &amp;&amp; _html2canvas.Renderer[options.renderer] !== undefined) {
		options._renderer = _html2canvas.Renderer[options.renderer]( options );
	} else if (typeof options.renderer === &quot;function&quot;) {
		options._renderer = options.renderer( options );
	} else {
		throw(&quot;Unknown renderer&quot;);
	}

    _html2canvas.logging = options.logging;
    options.complete = function( images ) {

        if (typeof options.onpreloaded === &quot;function&quot;) {
            if ( options.onpreloaded( images ) === false ) {
                return;
            }
        }
        queue = _html2canvas.Parse( images, options );

        if (typeof options.onparsed === &quot;function&quot;) {
            if ( options.onparsed( queue ) === false ) {
                return;
            }
        }

        canvas = _html2canvas.Renderer( queue, options );

        if (typeof options.onrendered === &quot;function&quot;) {
            options.onrendered( canvas );
        }


    };

    // for pages without images, we still want this to be async, i.e. return methods before executing
    window.setTimeout( function(){
        _html2canvas.Preload( options );
    }, 0 );

    return {
        render: function( queue, opts ) {
            return _html2canvas.Renderer( queue, _html2canvas.Util.Extend(opts, options) );
        },
        parse: function( images, opts ) {
            return _html2canvas.Parse( images, _html2canvas.Util.Extend(opts, options) );
        },
        preload: function( opts ) {
            return _html2canvas.Preload( _html2canvas.Util.Extend(opts, options) );
        },
        log: h2clog
    };
};

html2canvas.log = h2clog; // for renderers
html2canvas.Renderer = {
    Canvas: undefined // We are assuming this will be used
};

/*
  html2canvas v0.34 &lt;http://html2canvas.hertzen.com&gt;
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/


_html2canvas.Renderer.Canvas = function( options ) {

    options = options || {};

    var doc = document,
    canvas = options.canvas || doc.createElement(&#x27;canvas&#x27;),
    usingFlashcanvas = false,
    _createCalled = false,
    canvasReadyToDraw = false,
    methods,
    flashMaxSize = 2880; // flash bitmap limited to 2880x2880px // http://stackoverflow.com/questions/2033792/argumenterror-error-2015-invalid-bitmapdata


    if (canvas.getContext){
        h2clog(&quot;html2canvas: Renderer: using canvas renderer&quot;);
        canvasReadyToDraw = true;
    } else if ( options.flashcanvas !== undefined ){
        usingFlashcanvas = true;
        h2clog(&quot;html2canvas: Renderer: canvas not available, using flashcanvas&quot;);
        var script = doc.createElement(&quot;script&quot;);
        script.src = options.flashcanvas;

        script.onload = (function(script, func){
            var intervalFunc;

            if (script.onload === undefined) {
                // IE lack of support for script onload

                if( script.onreadystatechange !== undefined ) {

                    intervalFunc = function() {
                        if (script.readyState !== &quot;loaded&quot; &amp;&amp; script.readyState !== &quot;complete&quot;) {
                            window.setTimeout( intervalFunc, 250 );

                        } else {
                            // it is loaded
                            func();

                        }

                    };

                    window.setTimeout( intervalFunc, 250 );

                } else {
                    h2clog(&quot;html2canvas: Renderer: Can&#x27;t track when flashcanvas is loaded&quot;);
                }

            } else {
                return func;
            }

        })(script, function(){

            if (typeof window.FlashCanvas !== &quot;undefined&quot;) {
                h2clog(&quot;html2canvas: Renderer: Flashcanvas initialized&quot;);
                window.FlashCanvas.initElement( canvas );

                canvasReadyToDraw = true;
                if ( _createCalled !== false ) {
                    methods._create.apply( null, _createCalled );
                }
            }
        });

        doc.body.appendChild( script );

    }

    methods = {
        _create: function( zStack, options, doc, queue, _html2canvas ) {

            if ( !canvasReadyToDraw ) {
                _createCalled = arguments;
                return canvas;
            }

            var ctx = canvas.getContext(&quot;2d&quot;),
            storageContext,
            i,
            queueLen,
            a,
            newCanvas,
            bounds,
            testCanvas = document.createElement(&quot;canvas&quot;),
            hasCTX = ( testCanvas.getContext !== undefined ),
            storageLen,
            renderItem,
            testctx = ( hasCTX ) ? testCanvas.getContext(&quot;2d&quot;) : {},
            safeImages = [],
            fstyle;

            canvas.width = canvas.style.width = (!usingFlashcanvas) ? options.width || zStack.ctx.width : Math.min(flashMaxSize, (options.width || zStack.ctx.width) );
            canvas.height = canvas.style.height = (!usingFlashcanvas) ? options.height || zStack.ctx.height : Math.min(flashMaxSize, (options.height || zStack.ctx.height) );

            fstyle = ctx.fillStyle;
            ctx.fillStyle = zStack.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = fstyle;

            if ( options.svgRendering &amp;&amp; zStack.svgRender !== undefined ) {
                // TODO: enable async rendering to support this
                ctx.drawImage( zStack.svgRender, 0, 0 );
            } else {
                for ( i = 0, queueLen = queue.length; i &lt; queueLen; i+=1 ) {

                    storageContext = queue.splice(0, 1)[0];
                    storageContext.canvasPosition = storageContext.canvasPosition || {};

                    //this.canvasRenderContext(storageContext,parentctx);

                    // set common settings for canvas
                    ctx.textBaseline = &quot;bottom&quot;;

                    if (storageContext.clip){
                        ctx.save();
                        ctx.beginPath();
                        // console.log(storageContext);
                        ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);
                        ctx.clip();

                    }

                    if (storageContext.ctx.storage){

                        for (a = 0, storageLen = storageContext.ctx.storage.length; a &lt; storageLen; a+=1){

                            renderItem = storageContext.ctx.storage[a];


                            switch(renderItem.type){
                                case &quot;variable&quot;:
                                    ctx[renderItem.name] = renderItem[&#x27;arguments&#x27;];
                                    break;
                                case &quot;function&quot;:
                                    if (renderItem.name === &quot;fillRect&quot;) {

                                        if (!usingFlashcanvas || renderItem[&#x27;arguments&#x27;][0] + renderItem[&#x27;arguments&#x27;][2] &lt; flashMaxSize  &amp;&amp; renderItem[&#x27;arguments&#x27;][1] + renderItem[&#x27;arguments&#x27;][3] &lt; flashMaxSize) {
                                            ctx.fillRect.apply( ctx, renderItem[&#x27;arguments&#x27;] );
                                        }
                                    }else if(renderItem.name === &quot;fillText&quot;) {
                                        if (!usingFlashcanvas || renderItem[&#x27;arguments&#x27;][1] &lt; flashMaxSize  &amp;&amp; renderItem[&#x27;arguments&#x27;][2] &lt; flashMaxSize) {
                                            ctx.fillText.apply( ctx, renderItem[&#x27;arguments&#x27;] );
                                        }
                                    }else if(renderItem.name === &quot;drawImage&quot;) {

                                        if (renderItem[&#x27;arguments&#x27;][8] &gt; 0 &amp;&amp; renderItem[&#x27;arguments&#x27;][7]){
                                            if ( hasCTX &amp;&amp; options.taintTest ) {
                                                if ( safeImages.indexOf( renderItem[&#x27;arguments&#x27;][ 0 ].src ) === -1 ) {
                                                    testctx.drawImage( renderItem[&#x27;arguments&#x27;][ 0 ], 0, 0 );
                                                    try {
                                                        testctx.getImageData( 0, 0, 1, 1 );
                                                    } catch(e) {
                                                        testCanvas = doc.createElement(&quot;canvas&quot;);
                                                        testctx = testCanvas.getContext(&quot;2d&quot;);
                                                        continue;
                                                    }

                                                    safeImages.push( renderItem[&#x27;arguments&#x27;][ 0 ].src );

                                                }
                                            }
                                            ctx.drawImage.apply( ctx, renderItem[&#x27;arguments&#x27;] );
                                        }
                                    }


                                    break;
                                default:

                            }

                        }

                    }
                    if (storageContext.clip){
                        ctx.restore();
                    }

                }
            }

            h2clog(&quot;html2canvas: Renderer: Canvas renderer done - returning canvas obj&quot;);

            queueLen = options.elements.length;

            if (queueLen === 1) {
                if (typeof options.elements[ 0 ] === &quot;object&quot; &amp;&amp; options.elements[ 0 ].nodeName !== &quot;BODY&quot; &amp;&amp; usingFlashcanvas === false) {
                    // crop image to the bounds of selected (single) element
                    bounds = _html2canvas.Util.Bounds( options.elements[ 0 ] );
                    newCanvas = doc.createElement(&#x27;canvas&#x27;);
                    newCanvas.width = bounds.width;
                    newCanvas.height = bounds.height;
                    ctx = newCanvas.getContext(&quot;2d&quot;);

                    ctx.drawImage( canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height );
                    canvas = null;
                    return newCanvas;
                }
            } /*else {
        // TODO clip and resize multiple elements

            for ( i = 0; i &lt; queueLen; i+=1 ) {
                if (options.elements[ i ] instanceof Element) {

                }

            }
        }
        */



            return canvas;
        }
    };

    return methods;

};

window.html2canvas = html2canvas;
}(window, document));


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
