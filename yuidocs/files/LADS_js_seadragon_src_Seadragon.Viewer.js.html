<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>LADS/js/seadragon/src/Seadragon.Viewer.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../LADS/images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Autolinker.html">Autolinker</a></li>
            
                <li><a href="../classes/CryptoJS.html">CryptoJS</a></li>
            
                <li><a href="../classes/LADS.Layout.Artmode.html">LADS.Layout.Artmode</a></li>
            
                <li><a href="../classes/LADS.Layout.InternetFailurePage.js.html">LADS.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/LADS.Layout.StartPage.html">LADS.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG_embed.html">TAG_embed</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: LADS/js/seadragon/src/Seadragon.Viewer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonViewer,
    SeadragonControlAnchor;

(function () {

    // Constants

    var SIGNAL = &quot;----seadragon----&quot;;

    // Private static

    var browser = SeadragonUtils.getBrowser();

    // Controls

    SeadragonControlAnchor = Seadragon.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4
    };

    /**
     * Adds the given element to the given container based on the given anchor,
     * such that all new elements anchored to a right edge are shown to the left
     * of existing elements anchored to the same edge.
     */
    function addToAnchor(elmt, anchor, container) {
        if (anchor === SeadragonControlAnchor.TOP_RIGHT || anchor === SeadragonControlAnchor.BOTTOM_RIGHT) {
            container.insertBefore(elmt, container.firstChild);
        } else {
            container.appendChild(elmt);
        }
    }

    function Control(elmt, anchor, container) {
        // Fields
        var wrapper = SeadragonUtils.makeNeutralElement(&quot;span&quot;);

        // Properties
        this.elmt = elmt;
        this.anchor = anchor;
        this.container = container;
        this.wrapper = wrapper;

        // Constructor
        wrapper.style.display = &quot;inline-block&quot;;
        wrapper.appendChild(elmt);
        if (anchor === SeadragonControlAnchor.NONE) {
            wrapper.style.width = wrapper.style.height = &quot;100%&quot;;    // IE6 fix
        }

        addToAnchor(wrapper, anchor, container);
    }

    Control.prototype.destroy = function () {
        this.wrapper.removeChild(this.elmt);
        this.container.removeChild(this.wrapper);
    };

    Control.prototype.isVisible = function () {
        // see note in setVisible() below about using &quot;display: none&quot;
        return this.wrapper.style.display !== &quot;none&quot;;
    };

    Control.prototype.setVisible = function (visible) {
        // using &quot;display: none&quot; instead of &quot;visibility: hidden&quot; so that mouse
        // events are no longer blocked by this invisible control.
        this.wrapper.style.display = visible ? &quot;inline-block&quot; : &quot;none&quot;;
    };

    Control.prototype.setOpacity = function (opacity) {
        // like with setVisible() above, we really should be working with the
        // wrapper element and not the passed in element directly, so that we
        // don&#x27;t conflict with the developer&#x27;s own opacity settings. but this
        // doesn&#x27;t work in IE always, so for our controls, use a hack for now...
        if (this.elmt[SIGNAL] &amp;&amp; browser === SeadragonBrowser.IE) {
            SeadragonUtils.setElementOpacity(this.elmt, opacity, true);
        } else {
            SeadragonUtils.setElementOpacity(this.wrapper, opacity, true);
        }
    };

    // Navigation control

    var FULL_PAGE = &quot;fullpage&quot;;
    var HOME = &quot;home&quot;;
    var ZOOM_IN = &quot;zoomin&quot;;
    var ZOOM_OUT = &quot;zoomout&quot;;

    var REST = &quot;_rest.png&quot;;
    var GROUP = &quot;_grouphover.png&quot;;
    var HOVER = &quot;_hover.png&quot;;
    var DOWN = &quot;_pressed.png&quot;;

    function makeNavControl(viewer) {
        var group = null;
        var zooming = false;    // whether we should be continuously zooming
        var zoomFactor = null;  // how much we should be continuously zooming by
        var lastZoomTime = null;

        function onHome() {
            if (viewer.viewport) {
                viewer.viewport.goHome();
            }
        }

        function onFullPage() {
            viewer.setFullPage(!viewer.isFullPage());
            group.emulateExit();  // correct for no mouseout event on change

            if (viewer.viewport) {
                viewer.viewport.applyConstraints();
            }
        }

        function beginZoomingIn() {
            lastZoomTime = Date.now();
            zoomFactor = SeadragonConfig.zoomPerSecond;
            zooming = true;
            scheduleZoom();
        }

        function beginZoomingOut() {
            lastZoomTime = Date.now();
            zoomFactor = 1.0 / SeadragonConfig.zoomPerSecond;
            zooming = true;
            scheduleZoom();
        }

        function endZooming() {
            zooming = false;
        }

        function scheduleZoom() {
            window.setTimeout(doZoom, 10);
        }

        function doZoom() {
            if (zooming &amp;&amp; viewer.viewport) {
                var currentTime = Date.now();
                var deltaTime = currentTime - lastZoomTime;
                var adjustedFactor = Math.pow(zoomFactor, deltaTime / 1000);

                viewer.viewport.zoomBy(adjustedFactor);
                viewer.viewport.applyConstraints();
                lastZoomTime = currentTime;
                scheduleZoom();
            }
        }

        function doSingleZoomIn() {
            if (viewer.viewport) {
                zooming = false;
                viewer.viewport.zoomBy(SeadragonConfig.zoomPerClick / 1.0);
                viewer.viewport.applyConstraints();
            }
        }

        function doSingleZoomOut() {
            if (viewer.viewport) {
                zooming = false;
                viewer.viewport.zoomBy(1.0 / SeadragonConfig.zoomPerClick);
                viewer.viewport.applyConstraints();
            }
        }

        function lightUp() {
            group.emulateEnter();
            group.emulateExit();
        }

        function url(prefix, postfix) {
            return SeadragonConfig.imagePath + prefix + postfix;
        }

        var zoomIn = new SeadragonButton(SeadragonStrings.getString(&quot;Tooltips.ZoomIn&quot;),
                url(ZOOM_IN, REST), url(ZOOM_IN, GROUP), url(ZOOM_IN, HOVER),
                url(ZOOM_IN, DOWN), beginZoomingIn, endZooming, doSingleZoomIn,
                beginZoomingIn, endZooming);

        var zoomOut = new SeadragonButton(SeadragonStrings.getString(&quot;Tooltips.ZoomOut&quot;),
                url(ZOOM_OUT, REST), url(ZOOM_OUT, GROUP), url(ZOOM_OUT, HOVER),
                url(ZOOM_OUT, DOWN), beginZoomingOut, endZooming, doSingleZoomOut,
                beginZoomingOut, endZooming);

        var goHome = new SeadragonButton(SeadragonStrings.getString(&quot;Tooltips.Home&quot;),
                url(HOME, REST), url(HOME, GROUP), url(HOME, HOVER),
                url(HOME, DOWN), null, onHome, null, null, null);

        var fullPage = new SeadragonButton(SeadragonStrings.getString(&quot;Tooltips.FullPage&quot;),
                url(FULL_PAGE, REST), url(FULL_PAGE, GROUP), url(FULL_PAGE, HOVER),
                url(FULL_PAGE, DOWN), null, onFullPage, null, null, null);

        group = new SeadragonButtonGroup([zoomIn, zoomOut, goHome, fullPage]);
        group.elmt[SIGNAL] = true;   // hack to get our controls to fade

        viewer.addEventListener(&quot;open&quot;, lightUp);

        return group.elmt;
    }

    // Viewer
    // TAG: added ignore constraints to ignore constraints for mouse in authoring mode of RIN
    SeadragonViewer = Seadragon.Viewer = function (container, ignoreConstraints) {

        // hack to decrease bounds so image doesn&#x27;t disappear
        if (ignoreConstraints) {
            //Seadragon.Config.minZoomDimension = null;
            Seadragon.Config.minZoomImageRatio = 0.1;
            //Seadragon.Config.maxZoomPixelRatio = 10;
            ////Seadragon.Config.visibilityRatio = 0.8;
        } else {
            Seadragon.Config.minZoomImageRatio = 0.8;
        }

        // Fields

        var self = this;

        var parent = SeadragonUtils.getElement(container);
        container = SeadragonUtils.makeNeutralElement(&quot;div&quot;);
        self.container = container;
        var canvas = SeadragonUtils.makeNeutralElement(&quot;div&quot;);
        self.canvas = canvas;

        var controlsTL = SeadragonUtils.makeNeutralElement(&quot;div&quot;);
        var controlsTR = SeadragonUtils.makeNeutralElement(&quot;div&quot;);
        var controlsBR = SeadragonUtils.makeNeutralElement(&quot;div&quot;);
        var controlsBL = SeadragonUtils.makeNeutralElement(&quot;div&quot;);

        var source = null;
        var drawer = null;
        var viewport = null;
        var profiler = null;

        var eventManager = new SeadragonEventManager();
        var innerTracker = new SeadragonMouseTracker(canvas);
        var outerTracker = new SeadragonMouseTracker(container);

        var controls = [];
        //var controlsShouldFade = true;
        //var controlsFadeBeginTime = null;
        var navControl = null;

        var controlsFadeDelay = 1000;   // begin fading after 1 second
        var controlsFadeLength = 2000;  // fade over 2 second period
        var controlsFadeBeginTime = null;
        var controlsShouldFade = false;

        var bodyWidth = document.body.style.width;
        var bodyHeight = document.body.style.height;
        var bodyOverflow = document.body.style.overflow;
        var docOverflow = document.documentElement.style.overflow;

        var fsBoundsDelta = new SeadragonPoint(1, 1);
        var prevContainerSize = null;

        var lastOpenStartTime = 0;
        var lastOpenEndTime = 0;

        var mouseDownPixel = null;
        var mouseDownCenter = null;

        var animating = false;
        var forceRedraw = false;
        var mouseInside = false;

        // Properties

        this.container = parent;
        this.elmt = container;

        this.source = null;
        this.drawer = null;
        this.viewport = null;
        this.profiler = null;

        this.tracker = innerTracker;

        self.loopId = null;

        var requestAnimationFrame =
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function(callback) {
                var currTime = Date.now();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                  timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            }

        var cancelAnimationFrame =
            window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.mozCanelAnimationFrame ||
            window.oCancelAnimationFrame ||
            window.msCancelAnimationFrame ||
            function (id) {
                clearTimeout(id);
            };

        // Helpers -- UI

        function initialize() {
            // copy style objects to improve perf
            var canvasStyle = canvas.style;
            var containerStyle = container.style;
            var controlsTLStyle = controlsTL.style;
            var controlsTRStyle = controlsTR.style;
            var controlsBRStyle = controlsBR.style;
            var controlsBLStyle = controlsBL.style;

            containerStyle.width = &quot;100%&quot;;
            containerStyle.height = &quot;100%&quot;;
            containerStyle.position = &quot;relative&quot;;
            containerStyle.left = &quot;0px&quot;;
            containerStyle.top = &quot;0px&quot;;
            containerStyle.textAlign = &quot;left&quot;;  // needed to protect against
            // incorrect centering

            canvasStyle.width = &quot;100%&quot;;
            canvasStyle.height = &quot;100%&quot;;
            canvasStyle.overflow = &quot;hidden&quot;;
            canvasStyle.position = &quot;absolute&quot;;
            canvasStyle.top = &quot;0px&quot;;
            canvasStyle.left = &quot;0px&quot;;

            controlsTLStyle.position = controlsTRStyle.position =
                    controlsBRStyle.position = controlsBLStyle.position =
                    &quot;absolute&quot;;

            controlsTLStyle.top = controlsTRStyle.top = &quot;0px&quot;;
            controlsTLStyle.left = controlsBLStyle.left = &quot;0px&quot;;
            controlsTRStyle.right = controlsBRStyle.right = &quot;0px&quot;;
            controlsBLStyle.bottom = controlsBRStyle.bottom = &quot;0px&quot;;

            // mouse tracker handler for canvas (pan and zoom)

            
            innerTracker.clickHandler = onCanvasClick;
            innerTracker.pressHandler = onCanvasPress;
            innerTracker.dragHandler = onCanvasDrag;
            innerTracker.releaseHandler = onCanvasRelease;
            innerTracker.scrollHandler = onCanvasScroll;
            innerTracker.setTracking(true);     // default state
            
            // create default navigation control
            navControl = makeNavControl(self);
            navControl.style.marginRight = &quot;4px&quot;;
            navControl.style.marginBottom = &quot;4px&quot;;
            self.addControl(navControl, SeadragonControlAnchor.BOTTOM_RIGHT);

            // mouse tracker handler for container (controls fading)
            
            outerTracker.enterHandler = onContainerEnter;
            outerTracker.exitHandler = onContainerExit;
            outerTracker.releaseHandler = onContainerRelease;
            outerTracker.setTracking(true); // always tracking
            window.setTimeout(beginControlsAutoHide, 1);    // initial fade out
            

            //append to DOM only at end
            container.appendChild(canvas);
            container.appendChild(controlsTL);
            container.appendChild(controlsTR);
            container.appendChild(controlsBR);
            container.appendChild(controlsBL);
            parent.innerHTML = &quot;&quot;;          // clear any existing content...
            parent.appendChild(container);  // ...then add the real container
        }

        function setMessage(message) {
            var textNode = document.createTextNode(message);

            canvas.innerHTML = &quot;&quot;;
            canvas.appendChild(document.createElement(&#x27;div&#x27;));
            //canvas.appendChild(SeadragonUtils.makeCenteredNode(textNode));

            /*var textStyle = textNode.parentNode.style;

            // explicit styles for error message
            //textStyle.color = &quot;white&quot;;    // TEMP uncommenting this; very obtrusive
            textStyle.fontFamily = &quot;verdana&quot;;
            textStyle.fontSize = &quot;13px&quot;;
            textStyle.fontSizeAdjust = &quot;none&quot;;
            textStyle.fontStyle = &quot;normal&quot;;
            textStyle.fontStretch = &quot;normal&quot;;
            textStyle.fontVariant = &quot;normal&quot;;
            textStyle.fontWeight = &quot;normal&quot;;
            textStyle.lineHeight = &quot;1em&quot;;
            textStyle.textAlign = &quot;center&quot;;
            textStyle.textDecoration = &quot;none&quot;;*/
        }

        // Helpers -- CORE

        function beforeOpen() {
            if (source) {
                onClose();
            }

            lastOpenStartTime = Date.now();   // to ignore earlier opens

            // show loading message after a delay if it still hasn&#x27;t loaded
            window.setTimeout(function () {
                if (lastOpenStartTime &gt; lastOpenEndTime) {
                    setMessage(SeadragonStrings.getString(&quot;Messages.Loading&quot;));
                }
            }, 2000);

            return lastOpenStartTime;
        }

        function onOpen(time, _source, error) {
            lastOpenEndTime = Date.now();

            if (time &lt; lastOpenStartTime) {
                SeadragonDebug.log(&quot;Ignoring out-of-date open.&quot;);
                eventManager.trigger(&quot;ignore&quot;, self);
                return;
            } else if (!_source) {
                setMessage(error);
                eventManager.trigger(&quot;error&quot;, self);
                return;
            }

            // clear any previous message
            canvas.innerHTML = &quot;&quot;;
            prevContainerSize = SeadragonUtils.getElementSize(container);

            // UPDATE: if the container is collapsed, we should delay opening
            // since we don&#x27;t know yet what the home zoom should be, so opening
            // when the container gets layout will allow us to gracefully and
            // correctly start at home. this also prevents viewport NaN values.
            // what timeout value should we use? it&#x27;s arbitrary, but given that
            // this generally only occurs in embed scenarios where the image is
            // opened before the page has even finished loading, we&#x27;ll use very
            // small timeout values to be crisp and responsive. note that this
            // polling is necessary; there is no good cross-browser event here.
            if (prevContainerSize.x === 0 || prevContainerSize.y === 0) {
                window.setTimeout(function () {
                    onOpen(time, _source, error);
                }, 10);
                return;
            }

            // assign fields
            source = _source;
            viewport = new SeadragonViewport(prevContainerSize, source.dimensions, self);
            drawer = new SeadragonDrawer(source, viewport, canvas, self, ignoreConstraints);
            profiler = new SeadragonProfiler();

            // assign properties
            self.source = source;
            self.viewport = viewport;
            self.drawer = drawer;
            self.profiler = profiler;

            // begin updating
            animating = false;
            forceRedraw = true;
            eventManager.trigger(&quot;open&quot;, self);
            if (!self.loopId) self.loopId = requestAnimationFrame(updateOnce);
            //scheduleUpdate(updateMulti);
        }

        function onClose() {
            // TODO need destroy() methods to prevent leaks? check for null if so.

            // nullify fields and properties
            self.source = source = null;
            self.viewport = viewport = null;
            self.drawer = drawer = null;
            self.profiler = profiler = null;

            // clear all tiles and any message
            canvas.innerHTML = &quot;&quot;;
        }

        /**
         * Schedules a complete redraw of the image
         */
        function scheduleUpdate() {
            if (!self.loopId) {
                self.loopId = requestAnimationFrame(updateOnce);
            }
            forceRedraw = true;
        }
        this.scheduleUpdate = scheduleUpdate;

        function updateOnce() {
            self.loopId = requestAnimationFrame(updateOnce);

            if (!source) {
                return;
            }

            var containerSize = SeadragonUtils.getElementSize(container);

            // UPDATE: don&#x27;t break if the viewer was collapsed or hidden!
            // in that case, go ahead still update normally as we were before,
            // but don&#x27;t notify the viewport of the resize! prevents NaN bug.
            if (!containerSize.equals(prevContainerSize) &amp;&amp;
                    containerSize.x &gt; 0 &amp;&amp; containerSize.y &gt; 0) {
                viewport.resize(containerSize, true); // maintain image position
                prevContainerSize = containerSize;
                eventManager.trigger(&quot;resize&quot;, self);
            }

            var animated = viewport.update();
            var animEnd = animating &amp;&amp; !animated;

            if (!animating &amp;&amp; animated) {
                // we weren&#x27;t animating, and now we did ==&gt; animation start
                eventManager.trigger(&quot;animationstart&quot;, self);
                abortControlsAutoHide();
            }

            if (animated) {
                // viewport moved
                drawer.update(true, false);
                eventManager.trigger(&quot;animation&quot;, self);
            } else if (forceRedraw || drawer.needsUpdate()) {
                // need to load or blend images, etc.
                var fullUpdate = animEnd || forceRedraw;
                drawer.update(fullUpdate, fullUpdate);
            }
            else {
                // no changes, so stop drawing
                cancelAnimationFrame(self.loopId);
                self.loopId = null;
            }

            if (animEnd) {
                // we were animating, and now we&#x27;re not anymore ==&gt; animation finish
                eventManager.trigger(&quot;animationfinish&quot;, self);

                // if the mouse has left the container, begin fading controls
                //if (!mouseInside) {
                //    beginControlsAutoHide();
                //}
            }

            animating = animated;
            forceRedraw = false;
        }

        // Controls

        function getControlIndex(elmt) {
            for (var i = controls.length - 1; i &gt;= 0; i--) {
                if (controls[i].elmt === elmt) {
                    return i;
                }
            }

            return -1;
        }

        function scheduleControlsFade() {
            window.setTimeout(updateControlsFade, 20);
        }

        function updateControlsFade() {
            if (controlsShouldFade) {
                var currentTime = Date.now();
                var deltaTime = currentTime - controlsFadeBeginTime;
                var opacity = 1.0 - deltaTime / controlsFadeLength;

                opacity = Math.min(1.0, opacity);
                opacity = Math.max(0.0, opacity);

                for (var i = controls.length - 1; i &gt;= 0; i--) {
                    controls[i].setOpacity(opacity);
                }

                if (opacity &gt; 0) {
                    scheduleControlsFade();    // fade again
                }
            }
        }

        function abortControlsAutoHide() {
            controlsShouldFade = false;
            for (var i = controls.length - 1; i &gt;= 0; i--) {
                controls[i].setOpacity(1.0);
            }
        }

        function beginControlsAutoHide() {
            if (!SeadragonConfig.autoHideControls) {
                return;
            }

            controlsShouldFade = true;
            controlsFadeBeginTime = Date.now() + controlsFadeDelay;
            window.setTimeout(scheduleControlsFade, controlsFadeDelay);
        }

        // Mouse interaction with container

        function onContainerEnter(tracker, position, buttonDownElmt, buttonDownAny) {
            mouseInside = true;
            abortControlsAutoHide();
        }

        function onContainerExit(tracker, position, buttonDownElmt, buttonDownAny) {
            // fade controls out over time, only if the mouse isn&#x27;t down from
            // within the container (e.g. panning, or using a control)
            if (!buttonDownElmt) {
                mouseInside = false;
                if (!animating) {
                    //beginControlsAutoHide();
                }
            }
        }

        function onContainerRelease(tracker, position, insideElmtPress, insideElmtRelease) {
            // the mouse may have exited the container and we ignored it if the
            // mouse was down from within the container. now when the mouse is
            // released, we should fade the controls out now.
            if (!insideElmtRelease) {
                mouseInside = false;
                if (!animating) {
                    beginControlsAutoHide();
                }
            }
        }

        // Mouse interaction with canvas

        function onCanvasClick(tracker, position, quick, shift) {
            if (viewport &amp;&amp; quick) {    // ignore clicks where mouse moved
                var zoomPerClick = SeadragonConfig.zoomPerClick;
                var factor = shift ? 1.0 / zoomPerClick : zoomPerClick;
                viewport.zoomBy(factor, viewport.pointFromPixel(position, true));
                //if (!ignoreConstraints) {
                    viewport.applyConstraints();
                //}
            }
        }

        function onCanvasPress(tracker, position) {
            if (viewport) {
                mouseDownPixel = position;
                mouseDownCenter = viewport.getCenter();
            }
        }

        function onCanvasDrag(tracker, position, delta, shift) {
            if (viewport) {
                // note that in both cases, we&#x27;re negating delta pixels since
                // dragging is opposite of panning. analogy is adobe viewer,
                // dragging up scrolls down.
                if (SeadragonConfig.constrainDuringPan) {
                    var deltaPixels = position.minus(mouseDownPixel);
                    var deltaPoints = viewport.deltaPointsFromPixels(deltaPixels.negate(), true);
                    viewport.panTo(mouseDownCenter.plus(deltaPoints));
                    //if (!ignoreConstraints) {
                        viewport.applyConstraints();
                    //}
                } else {
                    viewport.panBy(viewport.deltaPointsFromPixels(delta.negate(), true));
                }
            }
        }

        function onCanvasRelease(tracker, position, insideElmtPress, insideElmtRelease) {
            if (insideElmtPress &amp;&amp; viewport &amp;&amp; !ignoreConstraints) {
                viewport.applyConstraints();
            }
        }

        function onCanvasScroll(tracker, position, delta, shift) {
            if (viewport) {
                var factor = Math.pow(SeadragonConfig.zoomPerScroll, delta);
                viewport.zoomBy(factor, viewport.pointFromPixel(position, true));
                //if (!ignoreConstraints) {
                    viewport.applyConstraints();
                //}
            }
        }

        // Keyboard interaction

        function onPageKeyDown(event) {
            event = SeadragonUtils.getEvent(event);
            if (event.keyCode === 27) {    // 27 means esc key
                self.setFullPage(false);
            }
        }

        // Methods -- IMAGE

        this.isOpen = function () {
            return !!source;
        };

        this.openDzi = function (xmlUrlOrJsonObj, xmlString) {
            var currentTime = beforeOpen();
            var callback = SeadragonUtils.createCallback(null, onOpen, currentTime);

            if (typeof(xmlUrlOrJsonObj) === &#x27;string&#x27;) {
                SeadragonDziTileSource.createFromXml(xmlUrlOrJsonObj, xmlString, callback);
            } else {
                SeadragonDziTileSource.createFromJson(xmlUrlOrJsonObj, callback);
            }
        };

        this.openTileSource = function (tileSource) {
            var currentTime = beforeOpen();
            window.setTimeout(function () {
                onOpen(currentTime, tileSource);
            }, 1);
        };

        this.close = function () {
            if (!source) {
                return;
            }

            onClose();
        };

        // Methods -- CONTROLS

        this.addControl = function (elmt, anchor) {
            elmt = SeadragonUtils.getElement(elmt);

            if (getControlIndex(elmt) &gt;= 0) {
                return;     // they&#x27;re trying to add a duplicate control
            }

            var div = null;

            switch (anchor) {
                case SeadragonControlAnchor.TOP_RIGHT:
                    div = controlsTR;
                    elmt.style.position = &quot;relative&quot;;
                    break;
                case SeadragonControlAnchor.BOTTOM_RIGHT:
                    div = controlsBR;
                    elmt.style.position = &quot;relative&quot;;
                    break;
                case SeadragonControlAnchor.BOTTOM_LEFT:
                    div = controlsBL;
                    elmt.style.position = &quot;relative&quot;;
                    break;
                case SeadragonControlAnchor.TOP_LEFT:
                    div = controlsTL;
                    elmt.style.position = &quot;relative&quot;;
                    break;
                case SeadragonControlAnchor.NONE:
                default:
                    div = container;
                    elmt.style.position = &quot;absolute&quot;;
                    break;
            }

            controls.push(new Control(elmt, anchor, div));
        };

        this.removeControl = function (elmt) {
            elmt = SeadragonUtils.getElement(elmt);
            var i = getControlIndex(elmt);

            if (i &gt;= 0) {
                controls[i].destroy();
                controls.splice(i, 1);
            }
        };

        this.clearControls = function () {
            while (controls.length &gt; 0) {
                controls.pop().destroy();
            }
        };

        this.getNavControl = function () {
            return navControl;
        };

        // Methods -- UI

        this.isDashboardEnabled = function () {
            for (var i = controls.length - 1; i &gt;= 0; i--) {
                if (controls[i].isVisible()) {
                    return true;
                }
            }

            return false;
        };

        this.isFullPage = function () {
            return container.parentNode === document.body;
        };

        this.isMouseNavEnabled = function () {
            return innerTracker.isTracking();
        };

        this.isVisible = function () {
            return container.style.visibility !== &quot;hidden&quot;;
        };

        this.setDashboardEnabled = function (enabled) {
            for (var i = controls.length - 1; i &gt;= 0; i--) {
                controls[i].setVisible(enabled);
            }
        };

        this.setFullPage = function (fullPage) {
            if (fullPage === self.isFullPage()) {
                return;
            }

            // copy locally to improve perf
            var body = document.body;
            var bodyStyle = body.style;
            var docStyle = document.documentElement.style;
            var containerStyle = container.style;
            var canvasStyle = canvas.style;

            if (fullPage) {
                // change overflow, but preserve what current values are
                bodyOverflow = bodyStyle.overflow;
                docOverflow = docStyle.overflow;
                bodyStyle.overflow = &quot;hidden&quot;;
                docStyle.overflow = &quot;hidden&quot;;

                // IE6 needs the body width/height to be 100% also
                bodyWidth = bodyStyle.width;
                bodyHeight = bodyStyle.height;
                bodyStyle.width = &quot;100%&quot;;
                bodyStyle.height = &quot;100%&quot;;

                // always show black background, etc., for fullpage
                canvasStyle.backgroundColor = &quot;black&quot;;
                canvasStyle.color = &quot;white&quot;;

                // make container attached to the window, immune to scrolling,
                // and above any other things with a z-index set.
                containerStyle.position = &quot;fixed&quot;;
                containerStyle.zIndex = &quot;99999999&quot;;

                body.appendChild(container);
                prevContainerSize = SeadragonUtils.getWindowSize();

                // add keyboard listener for esc key, to exit full page.
                // add it on document because browsers won&#x27;t give an arbitrary
                // element (e.g. this viewer) keyboard focus, and adding it to
                // window doesn&#x27;t work properly in IE.
                SeadragonUtils.addEvent(document, &quot;keydown&quot;, onPageKeyDown);

                onContainerEnter();     // mouse will be inside container now
            } else {
                // restore previous values for overflow
                bodyStyle.overflow = bodyOverflow;
                docStyle.overflow = docOverflow;

                // IE6 needed to overwrite the body width/height also
                bodyStyle.width = bodyWidth;
                bodyStyle.height = bodyHeight;

                // return to inheriting style
                canvasStyle.backgroundColor = &quot;&quot;;
                canvasStyle.color = &quot;&quot;;

                // make container be inline on page again, and auto z-index
                containerStyle.position = &quot;relative&quot;;
                containerStyle.zIndex = &quot;&quot;;

                parent.appendChild(container);
                prevContainerSize = SeadragonUtils.getElementSize(parent);

                // remove keyboard listener for esc key
                SeadragonUtils.removeEvent(document, &quot;keydown&quot;, onPageKeyDown);

                onContainerExit();      // mouse will likely be outside now
            }

            if (viewport) {
                var oldBounds = viewport.getBounds();
                viewport.resize(prevContainerSize);
                var newBounds = viewport.getBounds();

                if (fullPage) {
                    // going to fullpage, remember how much bounds changed by.
                    fsBoundsDelta = new SeadragonPoint(newBounds.width / oldBounds.width,
                        newBounds.height / oldBounds.height);
                } else {
                    // leaving fullpage, negate how much the fullpage zoomed by.
                    // note that we have to negate the bigger of the two changes.
                    // we have to zoom about the center of the new bounds, but
                    // that&#x27;s NOT the zoom point. so we have to manually update
                    // first so that that center becomes the viewport center.
                    viewport.update();
                    viewport.zoomBy(Math.max(fsBoundsDelta.x, fsBoundsDelta.y),
                            null, true);
                }

                forceRedraw = true;
                eventManager.trigger(&quot;resize&quot;, self);
                updateOnce();
            }
        };

        this.setMouseNavEnabled = function (enabled) {
            innerTracker.setTracking(enabled);
        };

        this.setVisible = function (visible) {
            // important: don&#x27;t explicitly say &quot;visibility: visible&quot;, because
            // the W3C spec actually says children of hidden elements that have
            // &quot;visibility: visible&quot; should still be rendered. that&#x27;s usually
            // not what we (or developers) want. browsers are inconsistent in
            // this regard, but IE seems to follow this spec.
            container.style.visibility = visible ? &quot;&quot; : &quot;hidden&quot;;
        };

        this.showMessage = function (message, delay) {
            if (!delay) {
                setMessage(message);
                return;
            }

            window.setTimeout(function () {
                if (!self.isOpen()) {
                    setMessage(message);
                }
            }, delay);
        };

        // Methods -- EVENT HANDLING

        this.addEventListener = function (eventName, handler) {
            eventManager.addListener(eventName, handler);
        };

        this.removeEventListener = function (eventName, handler) {
            eventManager.removeListener(eventName, handler);
        };

        this.unload = function () {
            if (self.loopId) {
                cancelAnimationFrame(self.loopId);
                self.loopId = null;
            }
        }

        // Constructor

        initialize();

    };

})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
